[["index.html", "现代应用统计与 R 语言 欢迎", " 现代应用统计与 R 语言 黄湘云 2021-07-18 欢迎 Book in early development. Planned release in 202X.1 图 0.1: 统计学的世界 最新一次编译发生在 2021-07-18 05:42:13。↩︎ "],["sec-style.html", "本书风格", " 本书风格 可以说，点估计、区间估计、假设检验、统计功效是每一个学数理统计的学生都绕不过去的坎，离开学校从事数据相关的工作，它们仍然是必备的工具。所以，本书会覆盖相关内容，但是和高校的教材最大的区别是更加注重它们之间的区别和联系，毕竟每一个统计概念都是经过了千锤百炼，而我们的主流教材始终如一地遵循的一个基本套路，就是突然给出一大堆定义、命题或定理，紧接着冗长的证明过程，然后给出一些难以找到实际应用背景的例子。三板斧抡完后就是给学生布置大量的习题，这种教学方式无论对于立志从事理论工作的还是将来投身于工业界的学生都是不合适的。 极大似然估计最初由德国数据学家 Gauss 于 1821 年提出，但未得到重视，后来， R. A. Fisher 在 1922 年再次提出极大似然的思想，探讨了它的性质，使它得到广泛的研究和应用。(茆诗松, 程依明, and 濮晓龙 2006) 这是国内某著名数理统计教材在极大似然估计开篇第一段的内容，后面是各种定义、定理、公式推导。教材简短一句话，这里面有很多信息值得发散，一个数学家提出了统计学领域极其重要的一个核心思想，他是在研究什么的时候提出了这个想法，为什么后来没有得到重视，整整 100 年以后，Fisher 又是怎么提出这一思想的呢？他做了什么使得这个思想被广泛接受和应用？虽然这可能有点离题，但是读者可以获得很多别的启迪，要知道统计领域核心概念的形成绝不是一蹴而就的，这一点也绝不局限于统计科学，任何一门科学都是这样的，比如物理学之于光的波粒二象性。历史上，各门各派的学者历经多年的思想碰撞才最终沉淀出现在的结晶。笔者认为，学校要想培养出有原创理论创新的人才，在对待前辈的成果上，我们要不吝笔墨和口水，传道不等于满堂灌和刷分机，用寥寥数节课或者数页纸来梳理学者们几十年乃至上百年的智慧结晶是非常值得的，我们甚至可以从当时的社会、人文去剖析。非常欣赏有人在收集关于统计学历史的材料，读者不妨去看看 https://github.com/sctyner/history_of_statistics。 另一个不得不提的人是 Allison Horst，她以风趣幽默的漫画形式，以画龙点睛之手法勾勒出基本的统计概念和思想，详见 https://github.com/allisonhorst/stats-illustrations，是我见过最好的科普读物。 Bradley Efron 在他的课程中谈及现代统计的研究层次，第一层次是基于正态分布假设的，这种类型已经研究的很清楚了，往往可以得到精确的结果，第二层次是将正态分布推广到指数族，这种类型的也研究的比较多了，常见的情况都研究的比较清楚，罕见的情况也是大量存在的，特别是在实际应用当中，总的来说只能得到部分准确的结果，第三层次对分布没有任何限定，只要满足成为一个统计分布的条件，这种情况下就只能求助于一般的数学工具和渐进理论。 图 0.2: 现代统计建模的三重境界：修改自 2019 年冬季 Bradley Efron 的课程笔记（第一部分） http://statweb.stanford.edu/~ckirby/brad/STATS305B_Part-1_corrected-2.pdf 下面以区间估计为例，希望能为传道做一点事情。区间估计的意义是解决点估计可靠性问题，它用置信系数解决了对估计结果的信心问题，弥补了点估计的不足。置信系数是最大的置信水平。 1934 年 C. J. Clopper 和 E. S. Pearson 给出二项分布 \\(B(n, p)\\) 参数 \\(p\\) 的置信带 (Clopper and Pearson 1934)，图 0.3 提炼了文章的主要结果。 图 0.3: 给定置信系数 \\(1- \\alpha = 0.95\\) 和样本量 \\(n = 10\\) 的情况下，二项分布参数 \\(p\\) 的置信带。样本量为 10，正面朝上的次数为 2，置信水平为 0.95 的情况下，参数 \\(p\\) 的精确区间估计为 \\((p_1, p_2) = (0.03, 0.55)\\)。 区间半径这么长，区间估计的意义何在？增加样本量可以使得半径更短，那么至少应该有多少样本量才可以让估计变得有意义呢？就是说用估计比不用估计更好呢？答案是 39 个，留给读者思考一下为什么？读者可能已经注意到，置信带是关于点 \\((5, 0.5)\\) 中心对称的，这又是为什么，并且两头窄中间胖，像个酒桶？ Base R 提供的 uniroot() 函数只能求取一元非线性方程的一个根，而 rootSolve 包提供的 uniroot.all() 函数可以求取所有的根。在给定分位点下，我们需要满足方程的最小的概率值。 Base R 提供的 binom.test() 函数可以精确计算置信区间，而 prop.test() 函数可近似计算置信区间。 # 近似计算 Wilson 区间 prop.test(x = 2, n = 10, p = 0.95, conf.level = 0.95, correct = TRUE) ## Warning in prop.test(x = 2, n = 10, p = 0.95, conf.level = 0.95, correct = ## TRUE): Chi-squared approximation may be incorrect ## ## 1-sample proportions test with continuity correction ## ## data: 2 out of 10, null probability 0.95 ## X-squared = 103, df = 1, p-value &lt;2e-16 ## alternative hypothesis: true p is not equal to 0.95 ## 95 percent confidence interval: ## 0.03543 0.55782 ## sample estimates: ## p ## 0.2 # 精确计算 binom.test(x = 2, n = 10, p = 0.95, conf.level = 0.95) ## ## Exact binomial test ## ## data: 2 and 10 ## number of successes = 2, number of trials = 10, p-value = 2e-09 ## alternative hypothesis: true probability of success is not equal to 0.95 ## 95 percent confidence interval: ## 0.02521 0.55610 ## sample estimates: ## probability of success ## 0.2 图 0.4: 二项分布 \\(B(n,\\theta)\\) 成功概率 \\(\\theta\\)，固定样本量 \\(n = 10\\)，分不同的分位点 \\(q = 2, 4, 6\\) 绘制概率随成功概率 \\(\\theta\\) 的变化 实际达到的置信度水平随真实的未知参数值和样本量的变化而剧烈波动，这意味着这种参数估计方法在实际应用中不可靠、真实场景中参数真值是永远未知的，样本量是可控的，并且是可以变化的。根本原因在于这类分布是离散的，比如这里的二项分布。当数据 \\(x\\) 是离散的情况，置信区间的端点\\(\\ell(x)\\) 和 \\(u(x)\\) 也是离散的。这种缺陷是无法避免的，清晰的置信区间和离散的数据之间存在无法调和的冲突。 覆盖概率 \\(P_{\\theta}(X = x)\\) 和参数真值 \\(\\theta\\) 的关系 (Brown, Cai, and DasGupta 2001; Geyer and Meeden 2005) 比如总体为二项分布 \\(B(n, \\theta)\\) 其中 n = 10，在置信水平 \\(\\alpha = 0.95\\) 下，问参数 \\(\\theta\\) 的覆盖概率是多少？随参数 \\(\\theta\\) 的变化情况如何？https://d.cosx.org/d/421502-coverage-probability 还是以抛硬币的为例，我来做这个实验，抛10次，获得 7 次正面向上，他做这个实验，10 次中 4 次正面，每个人来做这个实验可能都会有所不同，实际上有 2^10 = 1024 个结果（含位置变化），每个结果都可以用来估计未知的参数 \\(p\\) 及其置信区间，和相应的覆盖概率。 假设参数的真值是 0.7，做一次实验，得到正面朝上的结果，有6次 set.seed(2019) rbinom(n = 1, size = 10, prob = 0.7) ## [1] 6 这个检验的原假设是 p = 0.7，样本落在拒绝域的概率是 0.4997 &gt; 0.05 即不能拒绝原假设。 binom.test(x = 6, n = 10, p = 0.7, conf.level = 0.95) ## ## Exact binomial test ## ## data: 6 and 10 ## number of successes = 6, number of trials = 10, p-value = 0.5 ## alternative hypothesis: true probability of success is not equal to 0.7 ## 95 percent confidence interval: ## 0.2624 0.8784 ## sample estimates: ## probability of success ## 0.6 比例的真实值 \\(p\\) 落在区间 \\((\\hat{p} - Z_{1-\\alpha/2} * \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}, \\hat{p} + Z_{1-\\alpha/2} * \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}})\\) 的概率是 0.95。 c( 0.6 - qnorm(p = 1 - 0.05 / 2, mean = 0, sd = 1) * sqrt(0.6 * (1 - 0.6) / 10), 0.6 + qnorm(p = 1 - 0.05 / 2, mean = 0, sd = 1) * sqrt(0.6 * (1 - 0.6) / 10) ) ## [1] 0.2964 0.9036 多重比较与检验 多重比较 p.adjust() 函数 Adjust P-values for Multiple Comparisons 单因素多重比较 oneway.test() set.seed(123) x &lt;- rnorm(50, mean = c(rep(0, 25), rep(3, 25))) p &lt;- 2 * pnorm(sort(-abs(x))) # ?p.adjust round(p, 3) ## [1] 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.000 0.001 0.002 ## [13] 0.003 0.004 0.005 0.007 0.007 0.009 0.009 0.011 0.021 0.049 0.061 0.063 ## [25] 0.074 0.083 0.086 0.119 0.189 0.206 0.221 0.286 0.305 0.466 0.483 0.492 ## [37] 0.532 0.575 0.578 0.619 0.636 0.645 0.656 0.689 0.719 0.818 0.827 0.897 ## [49] 0.912 0.944 # round(p.adjust(p), 3) # round(p.adjust(p, &quot;BH&quot;), 3) 混合正态分布的参数估计 图 0.5: 上帝在掷骰子吗？ 两个二元正态分布的碰撞，点的密度估计值代表概率密度值， 图 0.6: 散点图：faithful 数据集 统计检验，决策风险，显著性水平 Charles J. Geyer 的文章 Fuzzy and Randomized Confidence Intervals and P-Values (Geyer and Meeden 2005) 文章中的图 1 名义覆盖概率的计算见 (Blyth and Hutchinson 1960) 参考文献 "],["sec-audience.html", "本书定位", " 本书定位 学习本书需要读者具备基本的概率、统计知识，比如上过一学期的概率论和数理统计学，也需要读者接触过编程知识，比如至少上过一学期的 C 语言、Python 语言或 Matlab 语言。了解基本的线性代数，比如矩阵的加、减、乘、逆四则运算、线性子空间、矩阵的 LU、SVD、Eigen 等分解。 "],["sec-abstract.html", "内容概要", " 内容概要 第 1 章介绍本书的写作背景、语言环境、全书的记号约定、如何获取帮助、作者简介等信息。 第 2 章介绍全书的数学公式符号。 第 3 章介绍文件操作。 第 4 章介绍 R 语言的数据结构。 第 5 章介绍数据操作，包括 Base R 、data.table 和 magrittr。 第 6 章介绍数据导入导出， data.table 之于 csv 文件， openxlsx 之于 xlsx 文件。 第 7 章介绍数据可视化，分四个部分，基础元素、常用图形、字体和颜色设置。 第 9 章介绍动态文档，即 R Markdown 及其生态系统。 第 10 章介绍交互式网页图形，以常用的 plotly 和 highcharter 为主，重点介绍 R 和 JavaScript 库的对应关系。 第 13 章介绍交互式数据表格，分两节介绍交互式的 DT 和 reactable，静态的 gt 和 kableExtra，掌握这几个 R 包足以应付日常工作。 第 14 章介绍交互式数据报表开发，符合工业标准的最佳实践。 "],["sec-acknowledgments.html", "致谢名单", " 致谢名单 特别感谢 XX，还有很多人通过提交 PR 或 Issues 的方式参与了本书的创作过程，没有这一点一滴的持续改进，本书不会达到现在的样子，所以我将他们列在致谢名单中，详见表 0.1，人名按照提交量（commit 的个数）倒序排列。 表 0.1: 致谢名单 贡献者 提交量 Yadong Liu 1 Yihui Xie 1 黄湘云 于北京 "],["sec-licenses.html", "授权说明", " 授权说明 本书采用 知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 许可，请君自重，别没事儿拿去传个什么新浪爱问、百度文库以及 XX 经济论坛，项目中代码使用 MIT 协议 开源 "],["sec-session.html", "运行信息", " 运行信息 xfun::session_info(packages = c( &quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;bookdown&quot;, &quot;equatiomatic&quot;, &quot;data.table&quot;, &quot;DT&quot;, &quot;kableExtra&quot;, &quot;reactable&quot;, &quot;patchwork&quot;, &quot;plotly&quot;, &quot;shiny&quot;, &quot;ggplot2&quot;, &quot;dplyr&quot;, &quot;tidyverse&quot; ), dependencies = FALSE) ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Locale: ## LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## LC_PAPER=en_US.UTF-8 LC_NAME=C ## LC_ADDRESS=C LC_TELEPHONE=C ## LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## Package version: ## bookdown_0.22 data.table_1.14.0 dplyr_1.0.7 DT_0.18 ## equatiomatic_0.2.0 ggplot2_3.3.5 kableExtra_1.3.4 knitr_1.33 ## patchwork_1.1.1 plotly_4.9.4.1 reactable_0.2.3 rmarkdown_2.9 ## shiny_1.6.0 tidyverse_1.3.1 ## ## Pandoc version: 2.14.0.3 "],["chap-preface.html", "第 1 章 前言", " 第 1 章 前言 荃者所以在鱼，得鱼而忘荃；蹄者所以在兔；得兔而忘蹄；言者所以在意，得意而忘言。吾安得夫忘言之人而与之言哉！ — 摘自 《庄子·杂篇·物》 庄子谈学习，余深以为然，故引之。 The fish trap exists because of the fish; once you’ve gotten the fish, you can forget the trap. The rabbit snare exists because of the rabbit; once you’ve gotten the rabbit, you can forget the snare. Words exist because of meaning; once you’ve gotten the meaning, you can forget the words. Where can I find a man who has forgotten words so I can have a word with him ?2 — Chuang Tzu 译文摘自 Eric D. Kolaczyk↩︎ "],["sec-r-or-python.html", "1.1 语言抉择", " 1.1 语言抉择 行业内可以做统计分析和建模的软件汗牛充栋，比较顶级的收费产品有 SAS 和 SPSS，在科学计算领域的 Matlab 和 Mathematica 也有相当强的统计功能，而用户基数最大的是微软 Excel，抛开微软公司的商业手段不说，Excel 的市场份额却是既成事实。 Brian D. Ripley 20 多年前的一句话很有意思，放在当下也是适用的。 Let’s not kid ourselves: the most widely used piece of software for statistics is Excel. — Brian D. Ripley (Ripley 2002) 有鉴于 Excel 在人文、社会、经济和管理等领域的影响力，熟悉 R 语言的人把它看作超级收费版的 Excel，这实在是一点也不过分。事实上，我司就是一个很好的明证，一个在线教育类的互联网公司，各大业务部门都在使用 Excel 作为主要的数据分析工具。然而，Excel 的不足也十分突出，工作过程无法保存和重复利用，Excel 也不是数据库，数据集稍大，操作起来愈发困难，对于复杂的展示，需要借助内嵌的 VBA，由于缺乏版本控制，随着时间的推移，几乎不可维护。所以，我们还是放弃 Excel 吧，Jenny Bryan 更在 2016 年国际 R 语言大会上的直截了当地喊出了这句话3。Nathan Stephens 对 Excel 的缺陷不足做了全面的总结4。 Some people familiar with R describe it as a supercharged version of Microsoft’s Excel spreadsheet software. — Ashlee Vance5 另一方面，我们谈谈开源领域的佼佼者 — R (https://cran.r-project.org/)，Python (https://www.python.org/) 和 Octave (http://www.gnu.org/software/octave/)。Python 号称万能的胶水语言，从系统运维到深度学习都有它的广泛存在，它被各大主流 Linux 系统内置，语言风格上更接近于基数庞大的开发人员，形成了强大的生态平台。 Octave 号称是可以替代 Matlab 的科学计算软件，在兼容 Matlab 的方面确实做的很不错，然而，根据 Julia 官网给出的各大编程语言的测试 https://julialang.org/benchmarks/，性能上不能相提并论。 图 1.1: R 语言扩展包生态系统 R 提供了丰富的图形接口，包括 Tcl/Tk , Gtk, Shiny 等，以及基于它们的衍生品 rattle（RGtk2）、Rcmdr（tcl/tk）、radiant（shiny）。更多底层介绍，见 John Chamber 的著作《Extending R》。 TikZ 在绘制示意图方面有很大优势，特别是示意图里包含数学公式，这更是 LaTeX 所擅长的方面 JASP https://jasp-stats.org 是一款免费的统计软件，源代码托管在 Github 上 https://github.com/jasp-stats/jasp-desktop，主要由阿姆斯特丹大学 E. J. Wagenmakers 教授 https://www.ejwagenmakers.com/ 领导的团队维护开发，实现了很多贝叶斯和频率统计方法，相似的图形用户界面使得 JASP 可以作为 SPSS 的替代，目前实现的功能见 https://jasp-stats.org/current-functionality/，统计方法见博客 https://www.bayesianspectacles.org/。 国内可视化分析平台，比如 hiplot 基于 R 语言实现可视化分析，各类图形的介绍见文档，极大地降低数据分析人员探索分析的门槛，节省了时间，同时非专业内的人也可借助其完成分析探索的过程，只需明白各类图形的含义即可。美团也建设了自己的可视化分析平台帮助运营人员，详见文档 Patrick Burns 收集整理了 R 语言中奇葩的现象，写成 The R Inferno 直译过来就是《R 之炼狱》。这些奇葩的怪现象可以看做是 R 风格的一部分，对于编程人员来说就是一些建议和技巧，参考之可以避开某些坑。 Paul E. Johnson 整理了一份真正的 R 语言建议，记录了他自己从 SAS 转换到 R 的过程中遇到的各种问题 http://pj.freefaculty.org/R/Rtips.html。Michail Tsagris 和 Manos Papadakis 也收集了 70 多条 R 编程的技巧和建议，力求以更加 R 范地将语言特性发挥到极致 (Tsagris and Papadakis 2018)，Martin Mächler 提供了一份 Good Practices in R Programming。 Python 社区广泛流传着 Tim Peters 的 《Python 之禅》，它已经整合进每一版 Python 软件中，只需在 Python 控制台里执行 import this 可以获得。 Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren’t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one– and preferably only one –obvious way to do it. Although that way may not be obvious at first unless you’re Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea – let’s do more of those! — The Zen of Python 总之，编程语言到一定境界都是殊途同归的，对美的认识也是趋同的，道理更是相通的，Python 社区的 Pandas https://github.com/pandas-dev/pandas 和 Matplotlib https://github.com/matplotlib/matplotlib 也有数据框和图形语法的影子。Pandas https://github.com/pandas-dev/pandas 明确说了要提供与 data.frame 类似的数据结构和对应统计函数等，而 Matplotlib 偷了 ggplot2 绘图样式 https://matplotlib.org/3.2.2/gallery/style_sheets/ggplot.html。 参考文献 "],["sec-data-science.html", "1.2 数据科学", " 1.2 数据科学 John M. Chambers 谈了数据科学的源起以及和 S、R 语言的渊源 (Chambers 2020)。 参考文献 "],["sec-r-help.html", "1.3 获取帮助", " 1.3 获取帮助 R 社区提供了丰富的帮助资源，可以在 R 官网搜集的高频问题 https://cran.r-project.org/faqs.html 中查找，也可在线搜索 https://cran.r-project.org/search.html 或 https://rseek.org/ ，更多获取帮助方式见 https://www.r-project.org/help.html。爆栈网问题以标签分类，比如 r-plotly、r-markdown、 data.table 和 ggplot2，还可以关注一些活跃的社区大佬，比如 谢益辉。 "],["sec-writing-details.html", "1.4 写作环境", " 1.4 写作环境 图 1.2: 书籍项目架构图 本书 R Markdown 源文件托管在 Github 仓库里，本地使用 RStudio IDE 编辑，bookdown 组织各个章节的 Rmd 文件和输出格式，使用 Git 进行版本控制。每次提交修改到 Github 上都会触发 Travis 自动编译书籍，将一系列 Rmd 文件经 knitr 调用 R 解释器执行里面的代码块，并将输出结果返回，Pandoc 将 Rmd 文件转化为 md 、 html 或者 tex 文件。若想输出 pdf 文件，还需要准备 TeX 排版环境，最后使用 Netlify 托管书籍网站，和 Travis 一起实现连续部署，使得每次修改都会同步到网站。最近一次编译时间 2021年07月18日05时42分17秒，本书用 R version 4.1.0 (2021-05-18) 编译，完整运行环境如下： xfun::session_info(packages = c( &quot;knitr&quot;, &quot;rmarkdown&quot;, &quot;bookdown&quot; ), dependencies = FALSE) ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Locale: ## LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## LC_PAPER=en_US.UTF-8 LC_NAME=C ## LC_ADDRESS=C LC_TELEPHONE=C ## LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## Package version: ## bookdown_0.22 knitr_1.33 rmarkdown_2.9 ## ## Pandoc version: 2.14.0.3 借助 bookdown (Xie 2016) 可以将 Rmd 文件组织起来， rmarkdown (Allaire et al. 2021)和 knitr (Xie 2015) 将源文件编译成 Markdown 文件， Pandoc 将 Markdown 文件转化成 HTML 和 TeX 文件， TinyTeX (Xie 2019) 可以将 TeX 文件进一步编译成 PDF 文档，书中大量的图形在用 ggplot2 包制作 (Wickham 2016)，而统计理论相关的示意图用 Base R 创作。 最后，本书在三个位置提供网页版， 网站 Github Pages 发布最近一次在 Travis 构建成功的版本 https://xiangyunhuang.github.io/masr/，网站 Bookdown 发布本地手动创建的版本 https://bookdown.org/xiangyun/masr/ ，网站 Netlify 发布最新的开发版 https://masr.netlify.app/。 参考文献 "],["sec-conventions.html", "1.5 记号约定", " 1.5 记号约定 正文中的代码、函数、参数及参数值以等宽正体表示，如 data(list = c(&#39;iris&#39;, &#39;BOD&#39;))， 其中函数名称 data()，参数及参数值 list = c(&#39;iris&#39;, &#39;BOD&#39;) ，R 程序包用粗体表示，如 graphics。 ruler() ----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8 12345678901234567890123456789012345678901234567890123456789012345678901234567890 "],["sec-contribute.html", "1.6 复现环境", " 1.6 复现环境 构建容器 本书借助 Github Action 从 Dockerfile 构建容器镜像，然后将镜像文件推送到 Github Package。完成这些操作首先需要从 https://github.com/settings/tokens 新建拥有 GitHub Package6 读写删的权限的 TOKEN（俗称访问令牌或密钥），命名为 GITHUB_PKG，并将此令牌保存到本地 TOKEN.txt 文件中，以备后用。 镜像内默认暴露 8181 端口供外部连接使用，进入容器后，默认工作路径是 /home/docker/。创建好镜像后，要先登陆 GitHub Package 然后才有权限将镜像拉取下来 # 登陆 GitHub Package cat ~/TOKEN.txt | docker login https://docker.pkg.github.com -u XiangyunHuang --password-stdin # 拉取镜像 docker pull docker.pkg.github.com/xiangyunhuang/masr/masr-book:devel 读者可以先查看下容器内的信息 docker run --rm -u root -v &quot;/${PWD}://home/docker/&quot; \\ docker.pkg.github.com/xiangyunhuang/masr/masr-book:devel \\ bash -c &quot;locale; fc-list | sort&quot; 运行容器 下面从镜像创建一个叫 masr-book 的容器，并让它在后台运行，允许以真正的 root 账户权限交互式执行命令，停止容器后，自动销毁容器。 此处，不再介绍 Docker 容器的使用，用容器打包本书所有软件环境仅供读者完整复现本书之用，感兴趣的读者可以去参考书籍Docker 从入门到实践。 docker run -itd -p 8282:8787 --rm --name=masr-book --privileged=true \\ docker.pkg.github.com/xiangyunhuang/masr/masr-book:devel /sbin/init 接着登陆进入 masr-book 容器， docker exec -it masr-book bash 一番骚操作后，用户退出容器，然后停止容器。 docker stop masr-book 使用 RStudio Server 启动容器后，接着获取容器 masr-book 的 IP 地址，然后依据端口号 8282 从网页进入 RStudio Sever，比如 http://192.168.100.23:8282 docker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; masr-book https://docs.github.com/en/packages/using-github-packages-with-your-projects-ecosystem/configuring-docker-for-use-with-github-packages↩︎ "],["sec-help-me.html", "1.7 如何发问", " 1.7 如何发问 The phrase “does not work” is not very helpful, it can mean quite a few things including: Your computer exploded. No explosion, but smoke is pouring out the back and microsoft’s “NoSmoke” utility is not compatible with your power supply. The computer stopped working. The computer sits around on the couch all day eating chips and watching talk shows. The computer has started picketing your house shouting catchy slogans and demanding better working conditions and an increase in memory. Everything went dark and you cannot check the cables on the back of the computer because the lights are off due to the power outage. R crashed, but the other programs are still working. R gave an error message and stopped processing your code after running for a while. R gave an error message without running any of your code (and is waiting for your next command). R is still running your code and the time has exceeded your patience so you think it has hung. R completed and returned a result, but also gave warnings. R completed your command, but gave an incorrect answer. R completed your command but the answer is different from what you expect (but is correct according to the documentation). There are probably others. Running your code I think the answer is the last one. — Greg Snow7 来自 R 社区论坛收集的智语 fortunes::fortune(324)。↩︎ "],["sec-about-author.html", "1.8 作者简介", " 1.8 作者简介 热心开源事业，统计之都副主编，经常混迹于统计之都论坛、Github 和爆栈网。个人主页 https://xiangyun.rbind.io/ "],["chap-notations.html", "第 2 章 符号说明", " 第 2 章 符号说明 Fabio Mulazzani: I need to obtain all the 9.somethingExp157 permutations that can be given from the numbers from 1 to 100. Ted Harding: To an adequate approximation there are 10158 of them. Simply to obtain them all (at a rate of 1010 per second, which is faster than the CPU frequency of most desktop computers) would take 10148 seconds, or slightly longer than \\(3\\times 10^{140}\\) years. Current estimates of the age of the Universe are of the order of \\(1.5\\times 10^{10}\\) years, so the Universe will have to last about \\(2\\times 10^{130}\\) times as long as it has already existed, before the task could be finished. So: why do you want to do this? — Fabio Mulazzani and Ted Harding8 数学符号约定参考花书 https://github.com/goodfeli/dlbook_notation Flexible Imputation of Missing Data 的 符号约定章节 矩阵、向量用粗体大写表示，特殊情况下，Y 只有一列 \\[ \\mathsf{Y} = \\mathbf{\\mathsf{X}}\\beta + \\epsilon \\] Y 叫做因变量或者响应变量 response variables，X 叫做自变量、协变量 covariate 或者预报变量 predictor variables 线性回归模型 \\[y = X \\beta + \\epsilon\\] 其中 \\(y\\) 是 \\(n \\times 1\\) 的观测向量， \\(X\\) 为 \\(n \\times p\\) 的设计矩阵，\\(\\beta\\) 为未知参数向量，\\(\\beta_0\\) 为常数项， \\(\\beta_1, \\ldots, \\beta_{p-1}\\) 为回归系数， \\(\\epsilon\\) 为 \\(n \\times 1\\) 随机误差向量，其均值为 0，即 \\(E(\\epsilon_i) = 0\\) 模型假设 误差项方差齐性，即 \\[Var(\\epsilon_i) = \\sigma^2, \\quad i = 1, 2, \\ldots, n\\] 误差项彼此不相关，即 \\[Cov(\\epsilon_i, \\epsilon_j) = 0, \\quad i \\neq j,\\quad i,j = 1, \\ldots, n\\] 线性模型中线性二字实质上是指 y 关于未知参数 \\(\\beta_i\\) 的关系是线性的。 \\(A,B,C,D\\) 斜体表示普通的集合，\\(X,Y,Z\\) 表示矩阵，\\(a,b,c,d\\) 表示常数，\\(\\alpha,\\beta,\\theta,\\phi,\\kappa\\) 表示模型或者分布函数的参数，\\(\\Theta\\) 表示参数空间，\\(\\mathbb{R}^{n},\\mathbb{C}^{n}\\) 表示特殊的 \\(n\\) 维实（复）数域，\\(\\mathscr{A,B,C,D}\\) 表示一般的数域，\\(\\mathcal{S,P,G}\\) 分别表示随机过程、概率空间和图 表 2.1: 数学符号表 符号 含义 符号 含义 \\(\\mathbf{A}\\) 粗体 \\(\\Omega\\) 全集 \\(\\mathit{A}\\) 集合 \\(\\mathbb{R,C}\\) 实（复）数集 \\(\\mathcal{A}\\) 集族 \\(\\varnothing\\) 空集 \\(\\mathsf{A}\\) 矩阵 \\(\\mathsf{A}^{-}\\) 矩阵的广义逆 \\(\\mathsf{A}^\\top\\) 矩阵转置 \\(\\bar{x}\\) 平均值 \\(\\mathsf{A}^{-1}\\) 矩阵的逆 \\(\\vert a \\vert\\) 标量绝对值 \\(\\mathsf{A}^{\\star}\\) 伴随矩阵 \\(\\mathop{\\mathrm{diag}}(\\mathsf{A})\\) 矩阵的对角 \\(\\lVert \\mathsf{A} \\rVert_{1}\\) 矩阵的1范数 \\(\\mathsf{I}\\) 单位矩阵 \\(\\lVert \\mathsf{A} \\rVert_{2}\\) 矩阵的2范数 \\(\\mathsf{I}_{n}\\) \\(n\\) 阶单位矩阵 \\(\\lVert \\mathsf{A} \\rVert_{\\infty}\\) 矩阵的无穷范数 \\(\\mathsf{1}\\) 全1矩阵 \\(\\lVert \\mathsf{X} \\rVert_{1}\\) 向量的1范数 \\(\\mathsf{1}_{n}\\) \\(n\\) 阶全1矩阵 \\(\\lVert \\mathsf{X} \\rVert_{2}\\) 向量的2范数 \\(\\lVert \\mathsf{X} \\rVert_{\\infty}\\) 向量的无穷范数 \\(\\langle\\mathsf{X},\\mathsf{Y}\\rangle\\) 向量的内积 \\(f(\\mathsf{X})\\) 随机变量的函数 \\(\\mathsf{X} \\wedge \\mathsf{Y}\\) 向量的外积 \\(\\nabla{\\mathsf{X}}\\) 向量微分或梯度 \\(\\beta\\) 模型系数 \\(\\theta\\) 模型或分布参数 \\(\\alpha\\) 模型截距 \\(\\Theta\\) 参数空间 \\(\\hat{\\beta}_{ls}\\) 模型系数的LS估计 \\(f(x)\\) 标量值函数 \\(\\hat{\\beta}_{mle}\\) 模型系数的MLE估计 \\(f(\\mathsf{X})\\) 向量的函数 \\(\\hat{\\beta}_{bayes}\\) 模型系数的Bayes估计 \\(\\mathcal{X}\\) 概率空间 \\(\\rho\\) 相关系数 \\(\\kappa\\) 贝塞尔函数的阶 \\(\\phi\\) 尺度参数 \\(u\\) 距离 \\(\\lVert \\mathsf{x}_1 -\\mathsf{x}_2\\rVert\\) \\(\\mathbb{R}^2\\) 二维实数域 \\(S(x)\\) 空间过程 \\(\\mathcal{S}\\) \\(\\mathcal{S} = \\{S(x):x \\in \\mathbb{R}^2\\}\\) \\(\\mathcal{S}^{\\star}\\) 随机过程 \\(\\mathcal{S}\\) 的近似 \\(\\triangleq\\) 定义为或记为 \\(\\hat{\\beta}_{ridge}\\) \\(\\beta\\) 的岭回归估计 \\(A \\geq 0\\) 矩阵 A 半正定 \\(\\hat{\\beta}_{lar}\\) \\(\\beta\\) 的最小角回归估计 \\(A &gt; 0\\) 矩阵 A 正定 \\(\\hat{\\beta}_{subset}\\) \\(\\beta\\) 的最优子集回归估计 \\(A\\otimes B\\) 矩阵 A 与 B 的 Kronecher 积 MSE 均方误差 \\(\\frac{1}{n}\\sum_{i=1}^{n}(y_i - \\hat{y_i})^2\\) \\(\\mathcal{M}(A)\\) 矩阵 A 的列向量张成的子空间 RMSE 均方根误差 \\(\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}(y_i - \\hat{y_i})^2}\\) \\(\\|A\\|\\) 矩阵 A 的范数 MAE 平均绝对误差 \\(\\frac{1}{n}\\sum_{i=1}^{n}|y_i-\\hat{y_i}|\\) \\(|A|\\) 矩阵 A 的行列式 LSE 最小二乘估计 \\(rk(A)\\) 矩阵 A 的秩 BLUE 最佳线性无偏估计 \\(tr(A)\\) 方阵 A 的迹 MVUE 最小方差无偏估计 \\(A^{-1}\\) 矩阵 A 的逆 UMVUE 一致最小方差无偏估计 \\(A^{-}\\) 矩阵 A 的广义逆 MINQUE 最小范数二次无偏估计 \\(\\hat{\\beta}_{ols}\\) \\(\\beta\\) 的普通最小二乘估计 OLS 普通最小二乘估计 \\(\\hat{\\beta}_{pca}\\) \\(\\beta\\) 的主成分分析估计 PLS 偏最小二乘估计 \\(\\hat{\\beta}_{pls}\\) \\(\\beta\\) 的偏最小二乘估计 GLS 广义最小二乘估计 \\(\\hat{\\beta}_{svm}\\) \\(\\beta\\) 的支持向量机估计 WLS 带权最小二乘估计 \\(\\hat{\\beta}_{lasso}\\) \\(\\beta\\) 的 Lasso 估计 - - 多元统计分析 高惠璇 矩阵符号表示，深度学习符号表示 https://github.com/XiangyunHuang/dlbook 举例，线性模型的表示，此处 \\(Y\\) 为 \\(n\\times 1\\)列向量，\\(X\\) 为\\(p\\times n\\)的矩阵，\\(\\beta\\) 为 \\(p\\times 1\\)的列向量 ，\\(\\epsilon\\) 为\\(n\\times1\\)列向量 \\[Y = X&#39;\\beta + \\epsilon\\] \\[\\mathsf{A} = \\varGamma^\\top\\Lambda\\varGamma\\] \\[\\mathsf{u} = (u_1,u_2,\\cdots,u_n)\\] \\[\\mathsf{x} = (x_1,x_2,\\cdots,x_n)\\] 期望 \\(\\mathsf{E}\\) 正态分布 \\(\\mathcal{N}(\\mathsf{x};\\mu,\\Sigma)\\) 对数 \\(\\mathsf{\\log}\\) 协方差 \\(\\mathsf{Cov},\\mathsf{Var}\\) 矩阵 \\[\\mathsf{Y} = (\\mathsf{y}^{(1)},\\mathsf{y}^{(n)},\\cdots,\\mathsf{y}^{(n)})\\] 其中 \\(\\mathsf{y}^{(i)} = (y_{1i},y_{2i},\\cdots,y_{ni})\\) 表示第 \\(i\\) 列 梅隆函数(Matern function)是描述空间相关性的常用函数，它带有两参数\\(\\kappa\\) 和 \\(\\phi\\)，具体形式如下： \\[\\rho(u) = \\big\\{2^{\\kappa-1}\\Gamma(\\kappa)\\big\\}^{-1}(u/\\phi)^{\\kappa}K_{\\kappa}(u/\\phi)\\] 其中，\\(K_{\\kappa}(\\cdot)\\) 表示 \\(\\kappa\\) 阶修正的贝塞尔函数 https://plotly.com/r/logos/↩︎ "],["chap-file-operations.html", "第 3 章 文件操作", " 第 3 章 文件操作 "],["chap-data-structure.html", "第 4 章 数据结构", " 第 4 章 数据结构 网站 https://r-coder.com/ 主要介绍 Base R，特点是全面细致，排版精美 "],["sec-character.html", "4.1 字符", " 4.1 字符 "],["sec-vector.html", "4.2 向量", " 4.2 向量 "],["sec-matrix.html", "4.3 矩阵", " 4.3 矩阵 "],["sec-array.html", "4.4 数组", " 4.4 数组 "],["sec-list.html", "4.5 列表", " 4.5 列表 x &lt;- list(a = 1, b = 2, c = list(d = c(1, 2, 3), e = &quot;hello&quot;)) print(x) ## $a ## [1] 1 ## ## $b ## [1] 2 ## ## $c ## $c$d ## [1] 1 2 3 ## ## $c$e ## [1] &quot;hello&quot; base::print.simple.list(x) ## _ ## a 1 ## b 2 ## c.d1 1 ## c.d2 2 ## c.d3 3 ## c.e hello "],["sec-date.html", "4.6 日期", " 4.6 日期 上个季度最后一天 # https://d.cosx.org/d/421162/16 as.Date(cut(as.Date(c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), &quot;quarter&quot;)) - 1 ## [1] &quot;2019-12-31&quot; &quot;2020-03-31&quot; 本季度第一天 as.Date(cut(as.Date(c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), &quot;quarter&quot;)) ## [1] &quot;2020-01-01&quot; &quot;2020-04-01&quot; 类似地，本月第一天和上月最后一天 # 本月第一天 as.Date(cut(as.Date(c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), &quot;month&quot;)) ## [1] &quot;2020-02-01&quot; &quot;2020-05-01&quot; # 上月最后一天 as.Date(cut(as.Date(c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), &quot;month&quot;)) - 1 ## [1] &quot;2020-01-31&quot; &quot;2020-04-30&quot; timeDate 提供了很多日期计算函数，比如季初、季末、月初、月末等 library(timeDate) # 季初 as.Date(format(timeFirstDayInQuarter(charvec = c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), format = &quot;%Y-%m-%d&quot;)) # 季末 as.Date(format(timeLastDayInQuarter(charvec = c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), format = &quot;%Y-%m-%d&quot;)) # 月初 as.Date(format(timeFirstDayInMonth(charvec = c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), format = &quot;%Y-%m-%d&quot;)) # 月末 as.Date(format(timeLastDayInMonth(charvec = c(&quot;2020-02-01&quot;, &quot;2020-05-02&quot;)), format = &quot;%Y-%m-%d&quot;)) cut.Date() 是一个泛型函数，查看它的所有 S3 方法 methods(cut) ## [1] cut.Date cut.default cut.dendrogram* cut.POSIXt ## see &#39;?methods&#39; for accessing help and source code 格式化输出日期类型数据 formatC(round(runif(1, 1e8, 1e9)), digits = 10, big.mark = &quot;,&quot;) ## [1] &quot;406,412,288&quot; # Sys.setlocale(locale = &quot;C&quot;) # 如果是 Windows 系统，必须先设置，否则转化结果是 NA as.Date(paste(&quot;1990-January&quot;, 1, sep = &quot;-&quot;), format = &quot;%Y-%B-%d&quot;) ## [1] &quot;1990-01-01&quot; 获取当日零点 format(as.POSIXlt(Sys.Date()), &quot;%Y-%m-%d %H:%M:%S&quot;) ## [1] &quot;2021-07-18 00:00:00&quot; 从 POSIXt 数据对象中，抽取小时和分钟部分，返回字符串 strftime(x = Sys.time(), format = &quot;%H:%M&quot;) ## [1] &quot;05:42&quot; 表 4.1: 日期表格 代码 含义 代码 含义 %a Abbreviated weekday %A Full weekday %b Abbreviated month %B Full month %c Locale-specific date and time %d Decimal date %H Decimal hours (24 hour) %I Decimal hours (12 hour) %j Decimal day of the year %m Decimal month %M Decimal minute %p Locale-specific AM/PM %S Decimal second %U Decimal week of the year (starting on Sunday) %w Decimal Weekday (0=Sunday) %W Decimal week of the year (starting on Monday) %x Locale-specific Date %X Locale-specific Time %y 2-digit year %Y 4-digit year %z Offset from GMT %Z Time zone (character) 本节介绍了 R 本身提供的基础日期操作，第28章着重介绍一般的时间序列类型的数据对象及其操作。 "],["chap-data-manipulation.html", "第 5 章 数据操作", " 第 5 章 数据操作 library(magrittr) data.table 大大加强了 Base R 提供的数据操作，poorman 提供最常用的数据操作，但是不依赖 dplyr，openxlsx 可以读写 XLSX 文档，fst，arrow 和 feather 提供更加高效的数据读写性能。 更多参考材料见A data.table and dplyr tour， Big Data in Economics: Data cleaning and wrangling 和 DataCamp’s data.table cheatsheet 图 5.1: Tidyverse 和 Base R 的关系 "],["sec-apply-family.html", "5.1 apply 族", " 5.1 apply 族 函数 输入 输出 apply 矩阵、数据框 向量 lapply 向量、列表 列表 sapply 向量、列表 向量、矩阵 mapply 多个向量 列表 tapply 数据框、数组 向量 vapply 列表 矩阵 eapply 列表 列表 rapply 嵌套列表 嵌套列表 除此之外，还有 dendrapply() 专门处理层次聚类或分类回归树型结构， 而函数 kernapply() 用于时间序列的平滑处理 # Reproduce example 10.4.3 from Brockwell and Davis (1991) [@Brockwell_1991_Time] spectrum(sunspot.year, kernel = kernel(&quot;daniell&quot;, c(11,7,3)), log = &quot;no&quot;) 图 5.2: 太阳黑子的频谱 将函数应用到多个向量，返回一个列表，生成四组服从正态分布 \\(\\mathcal{N}(\\mu_i,\\sigma_i)\\) 的随机数，它们的均值和方差依次是 \\(\\mu_i = \\sigma_i = 1 \\ldots 4\\) means &lt;- 1:4 sds &lt;- 1:4 set.seed(2020) samples &lt;- mapply(rnorm, mean = means, sd = sds, MoreArgs = list(n = 50), SIMPLIFY = FALSE) samples ## [[1]] ## [1] 1.37697212 1.30154837 -0.09802317 -0.13040590 -1.79653432 1.72057350 ## [7] 1.93912102 0.77062225 2.75913135 1.11736679 0.14687718 1.90925918 ## [13] 2.19637296 0.62841610 0.87673977 2.80004312 2.70399588 -2.03876461 ## [19] -1.28897495 1.05830349 3.17436525 2.09818265 1.31822032 0.92685244 ## [25] 1.83426874 1.19875064 2.29784138 1.93671831 0.85256681 1.11043199 ## [31] 0.18749534 0.25629783 2.09534507 3.43537371 1.38811847 1.29062767 ## [37] 0.71440171 1.07601472 0.43970140 1.44718837 1.90850113 0.49494040 ## [43] 0.69899599 0.27396402 -0.18007703 1.25307471 0.62928870 1.02217956 ## [49] 1.66004412 1.48879364 ## ## [[2]] ## [1] 1.62242017 3.20271904 0.65247989 2.95210048 2.23750646 2.24245257 ## [7] 1.62790641 -0.65654238 0.86615410 3.15766787 5.81807446 2.50151409 ## [13] -1.19663012 8.40326349 3.91047075 2.73728923 3.84583814 1.58895731 ## [19] 2.18593340 2.33652436 3.59167825 5.29201121 -1.43384863 1.36331379 ## [25] 0.19172006 0.59201441 -1.55619892 0.55548967 2.09230842 2.48731604 ## [31] 3.25666261 1.95072284 6.62830662 2.35442051 -0.04882953 6.54936260 ## [37] -1.77811333 4.18790320 5.69233405 3.04206535 -1.06592422 -1.87872994 ## [43] 2.97383308 4.49047338 1.56545315 0.44081377 2.69774900 3.36344850 ## [49] 0.93707723 0.64521316 ## ## [[3]] ## [1] -2.18635182 0.02621703 1.24348331 4.15056524 5.23999476 0.21473726 ## [7] 1.98547111 7.63534205 3.79952663 3.89860180 2.03159394 7.30604230 ## [13] 6.01958161 -2.15824091 3.89676139 0.52582309 -0.59876950 -0.82916135 ## [19] 2.63046580 9.49782660 2.06315108 4.10231768 6.80831778 -3.79456152 ## [25] -0.86954973 3.56365781 5.25492857 8.35404401 7.52481521 0.14051487 ## [31] 3.31026822 1.18331851 2.70719812 2.62965568 -0.13403855 2.77538898 ## [37] 8.28040600 -1.29635876 10.98660308 -0.87357460 3.04530532 2.88095828 ## [43] 9.57432097 -2.92931265 4.39099699 2.21336353 -0.40714352 3.63389844 ## [49] 3.29828378 -6.17005096 ## ## [[4]] ## [1] 2.6114534 -3.7865046 3.1356934 -1.7967859 5.3817362 4.7528096 ## [7] -0.5114111 4.2018014 1.2692036 6.5922153 6.4414579 1.9493723 ## [13] 7.0176236 4.7524199 -3.7131425 8.9432854 5.3131093 0.5803420 ## [19] -3.5827529 7.3867697 8.9761004 4.9450398 0.9572258 7.0888838 ## [25] 6.6462270 -2.3749335 -4.7613877 -0.7070158 8.2000205 3.9771877 ## [31] 2.8959507 7.3940852 -0.1957386 -2.9343453 13.6565563 3.2174329 ## [37] 7.7071478 1.1461455 -1.1989669 7.5371856 8.8025661 -0.6813591 ## [43] 7.0458875 7.4803610 1.0910292 6.5064829 -0.3657709 1.9356219 ## [49] 4.0677359 6.6439628 我们借用图5.3来看一下 mapply 的效果，多组随机数生成非常有助于快速模拟。 par(mfrow = c(2, 2), mar = c(2, 2, 2, 2)) invisible(lapply(samples, function(x) { plot(x, pch = 16, col = &quot;grey&quot;) abline(h = mean(x), lwd = 2, col = &quot;darkorange&quot;) })) 图 5.3: lapply 函数 分别计算每个样本的平均值 sapply(samples, mean) ## [1] 1.125622 2.184323 2.731533 3.432760 分别计算每个样本的1，2，3 分位点 lapply(samples, quantile, probs = 1:3/4) ## [[1]] ## 25% 50% 75% ## 0.6286342 1.1580587 1.8899430 ## ## [[2]] ## 25% 50% 75% ## 0.6470298 2.2399795 3.2431767 ## ## [[3]] ## 25% 50% 75% ## 0.05479149 2.74129355 4.33088906 ## ## [[4]] ## 25% 50% 75% ## -0.001718463 4.022461769 6.924774426 仅用 sapply() 函数替换上面的 lapply()，我们可以得到一个矩阵，值得注意的是函数 quantile() 和 fivenum() 算出来的结果有一些差异 sapply(samples, quantile, probs = 1:3/4) ## [,1] [,2] [,3] [,4] ## 25% 0.6286342 0.6470298 0.05479149 -0.001718463 ## 50% 1.1580587 2.2399795 2.74129355 4.022461769 ## 75% 1.8899430 3.2431767 4.33088906 6.924774426 vapply(samples, fivenum, c(Min. = 0, &quot;1st Qu.&quot; = 0, Median = 0, &quot;3rd Qu.&quot; = 0, Max. = 0)) ## [,1] [,2] [,3] [,4] ## Min. -2.0387646 -1.8787299 -6.17005096 -4.7613877 ## 1st Qu. 0.6284161 0.6452132 0.02621703 -0.1957386 ## Median 1.1580587 2.2399795 2.74129355 4.0224618 ## 3rd Qu. 1.9085011 3.2566626 4.39099699 7.0176236 ## Max. 3.4353737 8.4032635 10.98660308 13.6565563 vapply 和 sapply 类似，但是预先指定返回值类型，这样可以更加安全，有时也更快。 以数据集 presidents 为例，它是一个 ts 对象类型的时间序列数据，记录了 1945 年至 1974 年每个季度美国总统的支持率，这组数据中存在缺失值，以 NA 表示。支持率的变化趋势见图 5.4。 plot(presidents) 图 5.4: 1945-1974美国总统的支持率 计算这 30 年每个季度的平均支持率 tapply(presidents, cycle(presidents), mean, na.rm = TRUE) ## 1 2 3 4 ## 58.44828 56.43333 57.22222 53.07143 cycle() 函数计算序列中每个观察值在周期中的位置，presidents 的周期为 4，根据位置划分组，然后分组求平均，也可以化作如下计算步骤，虽然看起来复杂，但是数据操作的过程很清晰，不再看起来像是一个黑箱。 # Base R cbind(expand.grid(quarter = c(&quot;Qtr1&quot;, &quot;Qtr2&quot;, &quot;Qtr3&quot;, &quot;Qtr4&quot;), year = 1945:1974), rate = as.vector(presidents)) %&gt;% reshape(., v.names = &quot;rate&quot;, idvar = &quot;year&quot;, timevar = &quot;quarter&quot;, direction = &quot;wide&quot;, sep = &quot;&quot;) %&gt;% `colnames&lt;-`(., gsub(pattern = &quot;(rate)&quot;, x = colnames(.), replacement = &quot;&quot;)) %&gt;% `[`(., -1) %&gt;% apply(., 2, mean, na.rm = TRUE) ## Qtr1 Qtr2 Qtr3 Qtr4 ## 58.44828 56.43333 57.22222 53.07143 tapply 函数来做分组求和 # 一个变量分组求和 tapply(warpbreaks$breaks, warpbreaks[, 3, drop = FALSE], sum) ## tension ## L M H ## 655 475 390 # 两个变量分组计数 with(warpbreaks, table(wool, tension)) ## tension ## wool L M H ## A 9 9 9 ## B 9 9 9 # 两个变量分组求和 aggregate(breaks ~ wool + tension, data = warpbreaks, sum) %&gt;% reshape(., v.names = &quot;breaks&quot;, idvar = &quot;wool&quot;, timevar = &quot;tension&quot;, direction = &quot;wide&quot;, sep = &quot;&quot;) %&gt;% `colnames&lt;-`(., gsub(pattern = &quot;(breaks)&quot;, x = colnames(.), replacement = &quot;&quot;)) ## wool L M H ## 1 A 401 216 221 ## 2 B 254 259 169 "],["sec-subset.html", "5.2 子集过滤", " 5.2 子集过滤 iris[iris$Species == &#39;setosa&#39; &amp; iris$Sepal.Length &gt; 5.5, grepl(&#39;Sepal&#39;, colnames(iris))] ## Sepal.Length Sepal.Width ## 15 5.8 4.0 ## 16 5.7 4.4 ## 19 5.7 3.8 subset(iris, subset = Species == &#39;setosa&#39; &amp; Sepal.Length &gt; 5.5, select = grepl(&#39;Sepal&#39;, colnames(iris))) ## Sepal.Length Sepal.Width ## 15 5.8 4.0 ## 16 5.7 4.4 ## 19 5.7 3.8 "],["sec-option-with.html", "5.3 with 选项", " 5.3 with 选项 注意 data.table 与 Base R 不同的地方 # https://github.com/Rdatatable/data.table/issues/4513 # https://d.cosx.org/d/421532-datatable-base-r library(data.table) iris &lt;- as.data.table(iris) iris[Species == &quot;setosa&quot; &amp; Sepal.Length &gt; 5.5, grepl(&quot;Sepal&quot;, colnames(iris))] ## [1] TRUE TRUE FALSE FALSE FALSE 需要使用 with = FALSE 选项 iris[Species == &quot;setosa&quot; &amp; Sepal.Length &gt; 5.5, grepl(&quot;Sepal&quot;, colnames(iris)), with = FALSE] ## Sepal.Length Sepal.Width ## 1: 5.8 4.0 ## 2: 5.7 4.4 ## 3: 5.7 3.8 不使用 with 选项，用函数 mget() 将字符串转变量 iris[Species == &quot;setosa&quot; &amp; Sepal.Length &gt; 5.5, mget(grep(&quot;Sepal&quot;, colnames(iris), value = TRUE))] ## Sepal.Length Sepal.Width ## 1: 5.8 4.0 ## 2: 5.7 4.4 ## 3: 5.7 3.8 更加 data.table 风格的方式见 iris[Species == &#39;setosa&#39; &amp; Sepal.Length &gt; 5.5, .SD, .SDcols = patterns(&#39;Sepal&#39;)] ## Sepal.Length Sepal.Width ## 1: 5.8 4.0 ## 2: 5.7 4.4 ## 3: 5.7 3.8 with 还可以这样用，直接修改、添加一列 df &lt;- expand.grid(x = 1:10, y = 1:10) df$z &lt;- with(df, x^2 + y^2) df &lt;- subset(df, z &lt; 100) df &lt;- df[sample(nrow(df)), ] head(df) library(ggplot2) ggplot(df, aes(x, y, z = z)) + geom_contour() "],["sec-aggregate.html", "5.4 分组聚合", " 5.4 分组聚合 methods(&quot;aggregate&quot;) ## [1] aggregate.data.frame aggregate.default* aggregate.formula* ## [4] aggregate.ts ## see &#39;?methods&#39; for accessing help and source code args(&quot;aggregate.data.frame&quot;) ## function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) ## NULL args(&quot;aggregate.ts&quot;) ## function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption(&quot;ts.eps&quot;), ## ...) ## NULL # getAnywhere(aggregate.formula) 按 Species 分组，对 Sepal.Length 中大于平均值的数取平均 aggregate(Sepal.Length ~ Species, iris, function(x) mean(x[x &gt; mean(x)])) ## Species Sepal.Length ## 1 setosa 5.313636 ## 2 versicolor 6.375000 ## 3 virginica 7.159091 library(data.table) dt &lt;- data.table( x = rep(1:3, each = 3), y = rep(1:3, 3), z = rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 3), w = rep(c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;), each = 3) ) dt[, .(x_sum = sum(x), y_sum = sum(y)), by = .(z, w)] ## z w x_sum y_sum ## 1: A a 4 2 ## 2: B a 4 4 ## 3: C a 4 6 ## 4: A b 2 1 ## 5: B b 2 2 ## 6: C b 2 3 dt[, .(x_sum = sum(x), y_sum = sum(y)), by = mget(c(&quot;z&quot;, &quot;w&quot;))] ## z w x_sum y_sum ## 1: A a 4 2 ## 2: B a 4 4 ## 3: C a 4 6 ## 4: A b 2 1 ## 5: B b 2 2 ## 6: C b 2 3 shiny 前端传递字符串向量，借助 mget() 函数根据选择的变量分组统计计算，只有一个变量可以使用 get() 传递变量给 data.table library(shiny) ui &lt;- fluidPage( fluidRow( column( 6, selectInput(&quot;input_vars&quot;, label = &quot;变量&quot;, # 给筛选框取名 choices = c(z = &quot;z&quot;, w = &quot;w&quot;), # 待选的值 selected = &quot;z&quot;, # 指定默认值 multiple = TRUE # 允许多选 ), DT::dataTableOutput(&quot;output_table&quot;) ) ) ) library(data.table) library(magrittr) dt &lt;- data.table( x = rep(1:3, each = 3), y = rep(1:3, 3), z = rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), 3), w = rep(c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;), each = 3) ) server &lt;- function(input, output, session) { output$output_table &lt;- DT::renderDataTable( { dt[, .(x_sum = sum(x), y_sum = sum(y)), by = mget(input$input_vars)] %&gt;% DT::datatable() }, server = FALSE ) } # 执行 shinyApp(ui = ui, server = server) reactable 制作表格 library(shiny) library(reactable) ui &lt;- fluidPage( reactableOutput(&quot;table&quot;) ) server &lt;- function(input, output) { output$table &lt;- renderReactable({ reactable(iris, filterable = TRUE, # 过滤 searchable = TRUE, # 搜索 showPageSizeOptions = TRUE, # 页面大小 pageSizeOptions = c(5, 10, 15), # 页面大小可选项 defaultPageSize = 10, # 默认显示10行 highlight = TRUE, # 高亮选择 striped = TRUE, # 隔行高亮 fullWidth = FALSE, # 默认不要全宽填充，适应数据框的宽度 defaultSorted = list( Sepal.Length = &quot;asc&quot;, # 由小到大排序 Petal.Length = &quot;desc&quot; # 由大到小 ), columns = list( Sepal.Width = colDef(style = function(value) { # Sepal.Width 添加颜色标记 if (value &gt; 3.5) { color &lt;- &quot;#008000&quot; } else if (value &gt; 2) { color &lt;- &quot;#e00000&quot; } else { color &lt;- &quot;#777&quot; } list(color = color, fontWeight = &quot;bold&quot;) }) ) ) }) } shinyApp(ui, server) # 修改自 Code: https://gist.github.com/jthomasmock/f085dce3e70e42ca49b052bbe25de49f library(magrittr) library(reactable) library(htmltools) # barchart function from: https://glin.github.io/reactable/articles/building-twitter-followers.html bar_chart &lt;- function(label, width = &quot;100%&quot;, height = &quot;14px&quot;, fill = &quot;#00bfc4&quot;, background = NULL) { bar &lt;- div(style = list(background = fill, width = width, height = height)) chart &lt;- div(style = list(flexGrow = 1, marginLeft = &quot;6px&quot;, background = background), bar) div(style = list(display = &quot;flex&quot;, alignItems = &quot;center&quot;), label, chart) } data &lt;- mtcars %&gt;% subset(select = c(&quot;cyl&quot;, &quot;mpg&quot;)) %&gt;% subset(subset = sample(x = c(TRUE, FALSE), size = 6, replace = T)) reactable( data, defaultPageSize = 20, columns = list( cyl = colDef(align = &quot;center&quot;), mpg = colDef( name = &quot;mpg&quot;, defaultSortOrder = &quot;desc&quot;, minWidth = 250, cell = function(value, index) { width &lt;- paste0(value * 100 / max(mtcars$mpg), &quot;%&quot;) value &lt;- format(value, width = 9, justify = &quot;right&quot;, nsmall = 1) # output the value of another column # that aligns with current value cyl_val &lt;- data$cyl[index] # Color based on the row&#39;s cyl value color_fill &lt;- if (cyl_val == 4) { &quot;#3686d3&quot; # blue } else if (cyl_val == 6) { &quot;#88398a&quot; # purple } else { &quot;#fcab27&quot; # orange } bar_chart(value, width = width, fill = color_fill, background = &quot;#e1e1e1&quot;) }, align = &quot;left&quot;, style = list(fontFamily = &quot;monospace&quot;, whiteSpace = &quot;pre&quot;) ) ) ) "],["sec-merge-two-tables.html", "5.5 合并操作", " 5.5 合并操作 dat1 &lt;- data.frame(x = c(0, 0, 10, 10, 20, 20, 30, 30), y = c(1, 1, 2, 2, 3, 3, 4, 4)) dat2 &lt;- data.frame(x = c(0, 10, 20, 30), z = c(3, 4, 5, 6)) data.frame(dat1, z = dat2$z[match(dat1$x, dat2$x)]) ## x y z ## 1 0 1 3 ## 2 0 1 3 ## 3 10 2 4 ## 4 10 2 4 ## 5 20 3 5 ## 6 20 3 5 ## 7 30 4 6 ## 8 30 4 6 merge(dat1, dat2) ## x y z ## 1 0 1 3 ## 2 0 1 3 ## 3 10 2 4 ## 4 10 2 4 ## 5 20 3 5 ## 6 20 3 5 ## 7 30 4 6 ## 8 30 4 6 保留两个数据集中的所有行 "],["sec-reshape.html", "5.6 长宽转换", " 5.6 长宽转换 args(&quot;reshape&quot;) ## function (data, varying = NULL, v.names = NULL, timevar = &quot;time&quot;, ## idvar = &quot;id&quot;, ids = 1L:NROW(data), times = seq_along(varying[[1L]]), ## drop = NULL, direction, new.row.names = NULL, sep = &quot;.&quot;, ## split = if (sep == &quot;&quot;) { ## list(regexp = &quot;[A-Za-z][0-9]&quot;, include = TRUE) ## } else { ## list(regexp = sep, include = FALSE, fixed = TRUE) ## }) ## NULL PlantGrowth 数据集的重塑操作也可以使用内置的函数 reshape() 实现 PlantGrowth$id &lt;- rep(1:10, 3) reshape( data = PlantGrowth, idvar = &quot;group&quot;, v.names = &quot;weight&quot;, timevar = &quot;id&quot;, direction = &quot;wide&quot;, sep = &quot;&quot; ) %&gt;% knitr::kable(., caption = &quot;不同生长环境下植物的干重&quot;, row.names = FALSE, col.names = gsub(&quot;(weight)&quot;, &quot;&quot;, names(.)), align = &quot;c&quot; ) 表 5.1: 不同生长环境下植物的干重 group 1 2 3 4 5 6 7 8 9 10 ctrl 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 trt1 4.81 4.17 4.41 3.59 5.87 3.83 6.03 4.89 4.32 4.69 trt2 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26 或者，我们也可以使用 tidyr 包提供的 pivot_wider() 函数 tidyr::pivot_wider( data = PlantGrowth, id_cols = id, names_from = group, values_from = weight ) 或者，我们还可以使用 data.table 包提供的 dcast() 函数，用于将长格式的数据框重塑为宽格式的 PlantGrowth_DT &lt;- as.data.table(PlantGrowth) # 纵 dcast(PlantGrowth_DT, id ~ group, value.var = &quot;weight&quot;) ## id ctrl trt1 trt2 ## 1: 1 4.17 4.81 6.31 ## 2: 2 5.58 4.17 5.12 ## 3: 3 5.18 4.41 5.54 ## 4: 4 6.11 3.59 5.50 ## 5: 5 4.50 5.87 5.37 ## 6: 6 4.61 3.83 5.29 ## 7: 7 5.17 6.03 4.92 ## 8: 8 4.53 4.89 6.15 ## 9: 9 5.33 4.32 5.80 ## 10: 10 5.14 4.69 5.26 # 横 dcast(PlantGrowth_DT, group ~ id, value.var = &quot;weight&quot;) ## group 1 2 3 4 5 6 7 8 9 10 ## 1: ctrl 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 ## 2: trt1 4.81 4.17 4.41 3.59 5.87 3.83 6.03 4.89 4.32 4.69 ## 3: trt2 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26 "],["sec-filter-columns.html", "5.7 对符合条件的列操作", " 5.7 对符合条件的列操作 # 数值型变量的列的位置 which(sapply(iris, is.numeric)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 2 3 4 iris[,sapply(iris, is.numeric), with = F][Sepal.Length &gt; 7.5] ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1: 7.6 3.0 6.6 2.1 ## 2: 7.7 3.8 6.7 2.2 ## 3: 7.7 2.6 6.9 2.3 ## 4: 7.7 2.8 6.7 2.0 ## 5: 7.9 3.8 6.4 2.0 ## 6: 7.7 3.0 6.1 2.3 class(iris) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 用 magrittr 提供的管道符号连接 data.table 的数据操作与 ggplot2 的数据可视化 library(ggplot2) iris %&gt;% as.data.table(.) %&gt;% .[Species == &quot;setosa&quot;] %&gt;% # 行过滤 .[Sepal.Length &gt; 5.5] %&gt;% # 行过滤 .[, mget(grep(&quot;Sepal&quot;, colnames(.), value = TRUE))] %&gt;% # 列过滤 # .[, grepl(&quot;Sepal&quot;, colnames(.)), with = FALSE] %&gt;% ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + # 绘图 geom_point() "],["sec-case-when.html", "5.8 CASE WHEN 和 fcase", " 5.8 CASE WHEN 和 fcase CASE WHEN 是 SQL 中的条件判断语句，data.table 中的函数 fcase() 可与之等价。值得注意的是，fcase() 需要 data.table 版本 1.13.0 及以上。 dat &lt;- data.table( weights = c(56.8, 57.2, 46.3, 38.5), gender = c(&quot;1&quot;, &quot;0&quot;, &quot;&quot;, &quot;0&quot;) ) # 1 表示男，0表示女，空表示未知 transform(dat, gender_cn = fcase( gender == &quot;1&quot;, &quot;男&quot;, gender == &quot;0&quot;, &quot;女&quot;, gender == &quot;&quot;, &quot;未知&quot; )) ## weights gender gender_cn ## 1: 56.8 1 男 ## 2: 57.2 0 女 ## 3: 46.3 未知 ## 4: 38.5 0 女 "],["sec-datatable-in-action.html", "5.9 数据操作实战", " 5.9 数据操作实战 Toby Dylan Hocking 在 useR! 2020 大会上分享的幻灯片 https://github.com/tdhock/r-devel-emails "],["sec-faq-operations.html", "5.10 高频数据操作", " 5.10 高频数据操作 以数据集 dat 为例介绍常用的数据操作 set.seed(2020) dat = data.frame(num_a = rep(seq(4), each = 4), num_b = rep(seq(4), times = 4), group_a = sample(x = letters[1:3], size = 16, replace = T), group_b = sample(x = LETTERS[1:3], size = 16, replace = T)) dat = as.data.table(dat) dat ## num_a num_b group_a group_b ## 1: 1 1 c B ## 2: 1 2 b B ## 3: 1 3 a B ## 4: 1 4 a C ## 5: 2 1 b B ## 6: 2 2 b C ## 7: 2 3 a B ## 8: 2 4 a A ## 9: 3 1 b C ## 10: 3 2 b B ## 11: 3 3 b B ## 12: 3 4 a B ## 13: 4 1 b C ## 14: 4 2 c B ## 15: 4 3 b C ## 16: 4 4 a C 5.10.1 循环合并 问题来源 Faster version of Reduce(merge, list(DT1,DT2,DT3,…)) called mergelist (a la rbindlist) 5.10.2 分组计数 dat[, .(length(num_a)) , by = .(group_a)] # dat[, .N , by = .(group_a)] ## group_a V1 ## 1: c 2 ## 2: b 8 ## 3: a 6 dat[, .(length(num_a)) , by = .(group_b)] ## group_b V1 ## 1: B 9 ## 2: C 6 ## 3: A 1 dat[, .(length(num_a)), by = .(group_a, group_b)] ## group_a group_b V1 ## 1: c B 2 ## 2: b B 4 ## 3: a B 3 ## 4: a C 2 ## 5: b C 4 ## 6: a A 1 5.10.3 分组抽样 以 group_a 为组别， a、 b、 c 分别有 6、 8、 2 条记录 # 无放回的抽样 dt_sample_1 &lt;- dat[, .SD[sample(x = .N, size = 2, replace = FALSE)], by = group_a] # 有放回的随机抽样 dt_sample_2 &lt;- dat[, .SD[sample(x = .N, size = 3, replace = TRUE)], by = group_a] 可能存在该组样本不平衡，有的组的样本量不足你想要的样本量。每个组无放回地抽取 4 个样本，如果该组样本量不足 4，则全部抽取全部样本量。 dat[, .SD[sample(x = .N, size = min(4, .N))], by = group_a] ## group_a num_a num_b group_b ## 1: c 1 1 B ## 2: c 4 2 B ## 3: b 3 2 B ## 4: b 2 2 C ## 5: b 2 1 B ## 6: b 3 3 B ## 7: a 1 3 B ## 8: a 2 3 B ## 9: a 2 4 A ## 10: a 1 4 C 还可以按照指定的比例抽取样本量9 5.10.4 分组排序 data.table 包的分组排序问题 https://d.cosx.org/d/421650-datatable/3 dat[with(dat, order(-ave(num_a, group_a, FUN = max), -num_a)), ] ## num_a num_b group_a group_b ## 1: 4 1 b C ## 2: 4 2 c B ## 3: 4 3 b C ## 4: 4 4 a C ## 5: 3 1 b C ## 6: 3 2 b B ## 7: 3 3 b B ## 8: 3 4 a B ## 9: 2 1 b B ## 10: 2 2 b C ## 11: 2 3 a B ## 12: 2 4 a A ## 13: 1 1 c B ## 14: 1 2 b B ## 15: 1 3 a B ## 16: 1 4 a C # num_a 降序排列，然后对 group_a 升序排列 dat[with(dat, order(-num_a, group_a)), ] ## num_a num_b group_a group_b ## 1: 4 4 a C ## 2: 4 1 b C ## 3: 4 3 b C ## 4: 4 2 c B ## 5: 3 4 a B ## 6: 3 1 b C ## 7: 3 2 b B ## 8: 3 3 b B ## 9: 2 3 a B ## 10: 2 4 a A ## 11: 2 1 b B ## 12: 2 2 b C ## 13: 1 3 a B ## 14: 1 4 a C ## 15: 1 2 b B ## 16: 1 1 c B # 简写 dat[order(-num_a, group_a)] ## num_a num_b group_a group_b ## 1: 4 4 a C ## 2: 4 1 b C ## 3: 4 3 b C ## 4: 4 2 c B ## 5: 3 4 a B ## 6: 3 1 b C ## 7: 3 2 b B ## 8: 3 3 b B ## 9: 2 3 a B ## 10: 2 4 a A ## 11: 2 1 b B ## 12: 2 2 b C ## 13: 1 3 a B ## 14: 1 4 a C ## 15: 1 2 b B ## 16: 1 1 c B setorder() 函数直接修改原始数据记录的排序 setorder(dat, -num_a, group_a) 参考多个列分组排序10 如果数据集 dat 包含缺失值，考虑去掉缺失值 dat[, .(length(!is.na(num_a))) , by = .(group_a)] ## group_a V1 ## 1: c 2 ## 2: b 8 ## 3: a 6 如果数据集 dat 包含重复值，考虑去掉重复值 dat[, .(length(unique(num_a))) , by = .(group_a)] ## group_a V1 ## 1: c 2 ## 2: b 4 ## 3: a 4 按 Species 分组，对 Sepal.Length 降序排列，取 Top 3 iris = as.data.table(iris) iris[order(-Sepal.Length), .SD[1:3], by=&quot;Species&quot;] ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1: virginica 7.9 3.8 6.4 2.0 ## 2: virginica 7.7 3.8 6.7 2.2 ## 3: virginica 7.7 2.6 6.9 2.3 ## 4: versicolor 7.0 3.2 4.7 1.4 ## 5: versicolor 6.9 3.1 4.9 1.5 ## 6: versicolor 6.8 2.8 4.8 1.4 ## 7: setosa 5.8 4.0 1.2 0.2 ## 8: setosa 5.7 4.4 1.5 0.4 ## 9: setosa 5.7 3.8 1.7 0.3 对 iris 各个列排序 ind &lt;- do.call(what = &quot;order&quot;, args = iris[,c(5,1,2,3)]) iris[ind, ] ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1: 4.3 3.0 1.1 0.1 setosa ## 2: 4.4 2.9 1.4 0.2 setosa ## 3: 4.4 3.0 1.3 0.2 setosa ## 4: 4.4 3.2 1.3 0.2 setosa ## 5: 4.5 2.3 1.3 0.3 setosa ## --- ## 146: 7.7 2.6 6.9 2.3 virginica ## 147: 7.7 2.8 6.7 2.0 virginica ## 148: 7.7 3.0 6.1 2.3 virginica ## 149: 7.7 3.8 6.7 2.2 virginica ## 150: 7.9 3.8 6.4 2.0 virginica https://stackoverflow.com/questions/18258690/take-randomly-sample-based-on-groups↩︎ https://stackoverflow.com/questions/1296646/how-to-sort-a-dataframe-by-multiple-columns↩︎ "],["chap-data-transportation.html", "第 6 章 数据搬运", " 第 6 章 数据搬运 美团使用的大数据工具有很多，最常用的 Hive、Spark、Kylin、Impala、Presto 等，详见 https://tech.meituan.com/2018/08/02/mt-r-practice.html。下面主要介绍如何在 R 中连接 MySQL、Presto 和 Spark。 sparklyr.flint 支持 Spark 的时间序列库 flint，sparkxgb 为 Spark 上的 XGBoost 提供 R 接口，sparkwarc 支持加载 Web ARChive 文件到 Spark 里 sparkavro 支持从 Apache Avro (https://avro.apache.org/) 读取文件到 Spark 里，sparkbq 是一个 sparkly 扩展包，集成 Google BigQuery 服务，geospark 提供 GeoSpark 库的 R 接口，并且以 sf 的数据操作方式，rsparkling H2O Sparkling Water 机器学习库的 R 接口。 Spark 性能优化，参考三篇博文 Spark在美团的实践 Spark性能优化指南——基础篇 Spark性能优化指南——高级篇 其他材料 朱俊晖收集的 Spark 资源列表 https://github.com/harryprince/awesome-sparklyr，推荐使用 sparklyr https://github.com/sparklyr/sparklyr 连接 Spark Spark 与 R 语言 https://docs.microsoft.com/en-us/azure/databricks/spark/latest/sparkr/ Mastering Spark with R https://therinspark.com/ "],["sec-spark-with-r.html", "6.1 Spark 与 R 语言", " 6.1 Spark 与 R 语言 6.1.1 sparklyr Spark 依赖特定版本的 Java、Hadoop，三者之间的版本应该要相融。 在 MacOS 上配置 Java 环境，注意 Spark 仅支持 Java 8 至 11，所以安装指定版本的 Java 开发环境 # 安装 openjdk 11 brew install openjdk@11 # 全局设置 JDK 11 sudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk # Java 11 JDK 添加到 .zshrc export CPPFLAGS=&quot;-I/usr/local/opt/openjdk@11/include&quot; export PATH=&quot;/usr/local/opt/openjdk@11/bin:$PATH&quot; 配置 R 环境，让 R 能够识别 Java 环境，再安装 rJava 包 # 配置 sudo R CMD javareconf # 系统软件依赖 brew install pcre2 # 安装 rJava Rscript -e &#39;install.packages(&quot;rJava&quot;, type=&quot;source&quot;)&#39; 最后安装 sparklyr 包，以及 Spark 环境，可以借助 spark_install() 安装 Spark，比如下面 Spark 3.0 连同 hadoop 2.7 一起安装。 install.packages(&#39;sparklyr&#39;) sparklyr::spark_install(version = &#39;3.0&#39;, hadoop_version = &#39;2.7&#39;) 也可以先手动下载 Spark 软件环境，建议选择就近镜像站点下载，比如在北京选择清华站点 https://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.1/spark-3.0.1-bin-hadoop2.7.tgz，此环境自带 R 和 Python 接口。为了供 sparklyr 调用，先设置 SPARK_HOME 环境变量指向 Spark 安装位置，再连接单机版 Spark。 # 排错 https://github.com/sparklyr/sparklyr/issues/2827 options(sparklyr.log.console = FALSE) # 连接 Spark library(sparklyr) library(ggplot2) sc &lt;- spark_connect( master = &quot;local&quot;, # config = list(sparklyr.gateway.address = &quot;127.0.0.1&quot;), spark_home = Sys.getenv(&quot;SPARK_HOME&quot;) ) # diamonds 数据集导入 Spark diamonds_tbl &lt;- copy_to(sc, ggplot2::diamonds, &quot;diamonds&quot;) 做数据的聚合统计，有两种方式。一种是使用用 R 包 dplyr 提供的数据操作语法，下面以按 cut 分组统计钻石的数量为例，说明 dplyr 提供的数据操作方式。 library(dplyr) # 列出数据源下所有的表 tbls src_tbls(sc) diamonds_tbl &lt;- diamonds_tbl %&gt;% group_by(cut) %&gt;% summarise(cnt = n()) %&gt;% collect 另一种是使用结构化查询语言 SQL，这自不必说，大多数情况下，使用和一般的 SQL 没什么两样。 library(DBI) diamonds_preview &lt;- dbGetQuery(sc, &quot;SELECT count(*) as cnt, cut FROM diamonds GROUP BY cut&quot;) diamonds_preview ## cnt cut ## 1 21551 Ideal ## 2 13791 Premium ## 3 4906 Good ## 4 1610 Fair ## 5 12082 Very Good # SQL 中的 AVG 和 R 中的 mean 函数是类似的 diamonds_price &lt;- dbGetQuery(sc, &quot;SELECT AVG(price) as mean_price, cut FROM diamonds GROUP BY cut&quot;) diamonds_price ## mean_price cut ## 1 3457.542 Ideal ## 2 4584.258 Premium ## 3 3928.864 Good ## 4 4358.758 Fair ## 5 3981.760 Very Good   library(ggplot2) library(data.table) diamonds &lt;- as.data.table(diamonds) diamonds[,.(mean_price = mean(price)), by = .(cut)] ## cut mean_price ## 1: Ideal 3457.542 ## 2: Premium 4584.258 ## 3: Good 3928.864 ## 4: Very Good 3981.760 ## 5: Fair 4358.758 将结果数据用 ggplot2 呈现出来 ggplot(diamonds_preview, aes(cut, cnt)) + geom_col() + theme_minimal() diamonds 数据集总共 53940 条数据，下面用 BUCKET 分桶抽样，将原数据随机分成 1000 个桶，取其中的一个桶，由于是随机分桶，所以每次的结果都不一样，解释详见https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-sampling.html diamonds_sample &lt;- dbGetQuery(sc, &quot;SELECT * FROM diamonds TABLESAMPLE (BUCKET 1 OUT OF 1000) LIMIT 6&quot;) diamonds_sample ## carat cut color clarity depth table price x y z ## 1 0.70 Very Good F VS1 64.5 58 2925 5.55 5.59 3.59 ## 2 0.70 Ideal F VS1 61.6 57 2998 5.70 5.73 3.52 ## 3 0.85 Ideal G SI1 62.0 54 3084 6.08 6.11 3.78 ## 4 0.71 Ideal D VS1 62.5 57 3090 5.71 5.68 3.56 ## 5 0.32 Ideal F SI2 61.7 56 561 4.41 4.44 2.73 ## 6 1.10 Premium H SI2 59.2 59 3388 6.80 6.74 4.01 将抽样的结果用窗口函数 RANK() 排序，详见 https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-window.html 窗口函数 https://www.cnblogs.com/ZackSun/p/9713435.html diamonds_rank &lt;- dbGetQuery(sc, &quot; SELECT cut, price, RANK() OVER (PARTITION BY cut ORDER BY price) AS rank FROM diamonds TABLESAMPLE (BUCKET 1 OUT OF 1000) LIMIT 6 &quot;) diamonds_rank ## cut price rank ## 1 Good 4133 1 ## 2 Good 4440 2 ## 3 Good 8973 3 ## 4 Ideal 446 1 ## 5 Ideal 601 2 ## 6 Ideal 608 3 LATERAL VIEW 把一列拆成多行 https://liam.page/2020/03/09/LATERAL-VIEW-in-Hive-SQL/ https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-lateral-view.html 创建数据集 # 先删除存在的表 person dbGetQuery(sc, &quot;DROP TABLE IF EXISTS person&quot;) # 创建表 person dbGetQuery(sc, &quot;CREATE TABLE IF NOT EXISTS person (id INT, name STRING, age INT, class INT, address STRING)&quot;) # 插入数据到表 person dbGetQuery(sc, &quot; INSERT INTO person VALUES (100, &#39;John&#39;, 30, 1, &#39;Street 1&#39;), (200, &#39;Mary&#39;, NULL, 1, &#39;Street 2&#39;), (300, &#39;Mike&#39;, 80, 3, &#39;Street 3&#39;), (400, &#39;Dan&#39;, 50, 4, &#39;Street 4&#39;) &quot;) 查看数据集 dbGetQuery(sc, &quot;SELECT * FROM person&quot;) ## id name age class address ## 1 100 John 30 1 Street 1 ## 2 200 Mary NA 1 Street 2 ## 3 300 Mike 80 3 Street 3 ## 4 400 Dan 50 4 Street 4 行列转换 https://www.cnblogs.com/kimbo/p/6208973.html，LATERAL VIEW 展开 dbGetQuery(sc,&quot; SELECT * FROM person LATERAL VIEW EXPLODE(ARRAY(30, 60)) tabelName AS c_age LATERAL VIEW EXPLODE(ARRAY(40, 80)) AS d_age LIMIT 6 &quot;) ## id name age class address c_age d_age ## 1 100 John 30 1 Street 1 30 40 ## 2 100 John 30 1 Street 1 30 80 ## 3 100 John 30 1 Street 1 60 40 ## 4 100 John 30 1 Street 1 60 80 ## 5 200 Mary NA 1 Street 2 30 40 ## 6 200 Mary NA 1 Street 2 30 80 日期相关的函数 https://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions # 今天 dbGetQuery(sc, &quot;select current_date&quot;) ## current_date() ## 1 2021-07-18 # 昨天 dbGetQuery(sc, &quot;select date_sub(current_date, 1)&quot;) ## date_sub(current_date(), 1) ## 1 2021-07-17 # 本月最后一天 current_date 所属月份的最后一天 dbGetQuery(sc, &quot;select last_day(current_date)&quot;) ## last_day(current_date()) ## 1 2021-07-31 # 星期几 dbGetQuery(sc, &quot;select dayofweek(current_date)&quot;) ## dayofweek(current_date()) ## 1 1 最后，使用完记得关闭 Spark 连接 spark_disconnect(sc) 6.1.2 SparkR 考虑到和第6.1.1节的重合性，以及 sparklyr 的优势，本节代码都不会执行，仅作为补充信息予以描述。完整的介绍见 SparkR 包 if (nchar(Sys.getenv(&quot;SPARK_HOME&quot;)) &lt; 1) { Sys.setenv(SPARK_HOME = &quot;/opt/spark/spark-3.0.1-bin-hadoop2.7&quot;) } library(SparkR, lib.loc = c(file.path(Sys.getenv(&quot;SPARK_HOME&quot;), &quot;R&quot;, &quot;lib&quot;))) sparkR.session(master = &quot;local[*]&quot;, sparkConfig = list(spark.driver.memory = &quot;2g&quot;)) SparkR 要求 Java 版本满足：大于等于8，而小于12，本地 MacOS 安装高版本，比如 oracle-jdk 16.0.1 会报不兼容的错误。 Spark package found in SPARK_HOME: /opt/spark/spark-3.1.1-bin-hadoop3.2 Error in checkJavaVersion() : Java version, greater than or equal to 8 and less than 12, is required for this package; found version: 16.0.1 sparkConfig 有哪些参数可以传递 Property Name Property group spark-submit equivalent spark.master Application Properties --master spark.kerberos.keytab Application Properties --keytab spark.kerberos.principal Application Properties --principal spark.driver.memory Application Properties --driver-memory spark.driver.extraClassPath Runtime Environment --driver-class-path spark.driver.extraJavaOptions Runtime Environment --driver-java-options spark.driver.extraLibraryPath Runtime Environment --driver-library-path 将 data.frame 转化为 SparkDataFrame faithful_sdf &lt;- as.DataFrame(faithful) SparkDataFrame head(faithful_sdf) 查看结构 str(faithful_sdf) "],["sec-database-with-r.html", "6.2 数据库与 R 语言", " 6.2 数据库与 R 语言 Presto 的 R 接口 https://github.com/prestodb/RPresto 和文档 https://prestodb.io/docs/current/index.html，Presto 数据库 install.packages(&#39;RPresto&#39;) MySQL 为例介绍 odbc 的连接和使用，详见 从 R 连接 MySQL -- !preview conn=DBI::dbConnect(odbc::odbc(), driver = &quot;MariaDB&quot;, database = &quot;demo&quot;, -- uid = &quot;root&quot;, pwd = &quot;cloud&quot;, host = &quot;localhost&quot;, port = 3306) SELECT * FROM mtcars LIMIT 10 我的系统已经安装了多款数据库的 ODBC 驱动 dnf install -y unixODBC unixODBC-devel mariadb mariadb-server mariadb-devel mariadb-connector-odbc odbc::odbcListDrivers() # Driver from the mariadb-connector-odbc package # Setup from the unixODBC package [MariaDB] Description = ODBC for MariaDB Driver = /usr/lib/libmaodbc.so Driver64 = /usr/lib64/libmaodbc.so FileUsage = 1 "],["sec-batch-import-csv.html", "6.3 批量读取 csv 文件", " 6.3 批量读取 csv 文件 iris 数据转化为 data.table 类型，按照 Species 分组拆成单独的 csv 文件，各个文件的文件名用鸢尾花的类别名表示 # 批量分组导出 library(data.table) as.data.table(iris)[, fwrite(.SD, paste0(&quot;data/user_&quot;, unique(Species), &quot;.csv&quot;)), by = Species, .SDcols = colnames(iris)] 读取文件夹 data/ 所有 csv 数据文件 library(data.table) merged_df &lt;- do.call(&#39;rbind&#39;, lapply(list.files(pattern = &quot;*.csv&quot;, path = &quot;data/&quot;), fread ) ) # 或者 merged_df &lt;- rbindlist(lapply(list.files(pattern = &quot;*.csv&quot;, path = &quot;data/&quot;), fread )) xdf$date &lt;- as.Date(xdf$date) xdf$ts &lt;- as.POSIXct(as.numeric(xdf$ts), origin = &quot;1978-01-01&quot;) split(xdf[order(xdf$ts), ], interaction(xdf$study, xdf$port)) %&gt;% lapply(function(.x) { .x[nrow(.x), ] }) %&gt;% unname() %&gt;% Filter(function(.x) { nrow(.x) &gt; 0 }, .) %&gt;% do.call(rbind.data.frame, .) library(dplyr) xdf %&gt;% mutate( date = as.Date(date), ts = anytime::anytime(as.numeric(ts)) ) %&gt;% arrange(ts) %&gt;% group_by(study, port) %&gt;% slice(n()) %&gt;% ungroup() library(tibble) library(magrittr) mtcars &lt;- tibble(mtcars) mtcars %&gt;% print(n = 16, width = 69) ## # A tibble: 32 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 11 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 12 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 13 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 14 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 15 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 16 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## # … with 16 more rows mtcars %&gt;% print(., n = nrow(.)/4) ## # A tibble: 32 x 11 ## mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## # … with 24 more rows "],["sec-batch-export-xlsx.html", "6.4 批量导出 xlsx 文件", " 6.4 批量导出 xlsx 文件 将 R 环境中的数据集导出为 xlsx 表格 ## 加载 openxlsx 包 library(openxlsx) ## 创建空白的工作薄，标题为鸢尾花数据集 wb &lt;- createWorkbook(title = &quot;鸢尾花数据集&quot;) ## 添加 sheet 页 addWorksheet(wb, sheetName = &quot;iris&quot;) # 将数据写进 sheet 页 writeData(wb, sheet = &quot;iris&quot;, x = iris, colNames = TRUE) # 导出数据到本地 saveWorkbook(wb, file = &quot;iris.xlsx&quot;, overwrite = TRUE) library(openxlsx) xlsxFile &lt;- system.file(&quot;extdata&quot;, &quot;readTest.xlsx&quot;, package = &quot;openxlsx&quot;) # 导入 dat = read.xlsx(xlsxFile = xlsxFile) # 导出 write.xlsx(dat, xlsxfile) "],["chap-data-visualization.html", "第 7 章 数据可视化", " 第 7 章 数据可视化 library(ggplot2) library(patchwork) `%&gt;%` &lt;- magrittr::`%&gt;%` clean_plotly &lt;- function(p = ggplot2::last_plot(), ...) { plotly::ggplotly(p, ...) %&gt;% plotly::config(displayModeBar = FALSE) } David Robinson 给出为何使用 ggplot211 当然也有 Jeff Leek 指出在某些重要场合不适合 ggplot212 并且给出强有力的 证据，其实不管怎么样，适合自己的才是好的。也不枉费 Garrick Aden-Buie 花费 160 页幻灯片逐步分解介绍 优雅的ggplot2，Malcolm Barrett 也介绍了 ggplot2 基础用法，还有 Selva Prabhakaran 精心总结给出了 50 个 ggplot2 数据可视化的 例子 以及 Victor Perrier 为小白用 ggplot2 操碎了心地开发 RStudio 插件 esquisse 包，Claus O. Wilke 教你一步步创建出版级的图形 https://github.com/clauswilke/practical_ggplot2。 ggplot2 是十分方便的统计作图工具，相比 Base R，为了一张出版级的图形，不需要去调整每个参数，实现快速出图。集成了很多其它统计计算的 R 包，支持丰富的统计分析和计算功能，如回归、平滑等，实现了作图和模型的无缝连接。比如图7.1，使用 loess 局部多项式平滑得到数据的趋势，不仅仅是散点图，代码量也非常少。 ggplot(mpg, aes(displ, hwy)) + geom_point(aes(color = class)) + geom_smooth(se = TRUE, method = &quot;loess&quot;) + labs( title = &quot;Fuel efficiency generally decreases with engine size&quot;, subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;, caption = &quot;Data from fueleconomy.gov&quot; ) 图 7.1: 简洁美观 故事源于一幅图片，我不记得第一次见到这幅图是什么时候了，只因多次在多个场合中见过，所以留下了深刻的印象，后来才知道它出自于一篇博文 — Using R packages and education to scale Data Science at Airbnb，作者 Ricardo Bion 还在其 Github 上传了相关代码13。除此之外还有几篇重要的参考资料： Pablo Barberá 的 Data Visualization with R and ggplot2 Kieran Healy 的新书 Data Visualization: A Practical Introduction Matt Leonawicz 的新作 mapmate, 可以去其主页欣赏系列作品14 tidytuesday 可视化挑战官方项目 还有 tidytuesday ggstatsplot 可视化统计检验、模型的结果 ggpubr 制作出版级统计图形 Thomas Lin Pedersen Drawing Anything with ggplot2 Designing ggplots: making clear figures that communicate ggh4x 提供 ggplot2 的额外定制功能 ggdist Visualizations of distributions and uncertainty gghighlight ggnetwork ggPMX ‘ggplot2’ Based Tool to Facilitate Diagnostic Plots for NLME Models ggpp ggpp: Grammar Extensions to ‘ggplot2’ 如 Berton Gunter 所说，数据可视化只是一种手段，根据数据实际情况作展示才是重要的，并不是要追求酷炫。 3-D bar plots are an abomination. Just because Excel can do them doesn’t mean you should. (Dismount pulpit). — Berton Gunter15 grid 是 lattice 和 ggplot2 的基础，gganimate 是 ggplot2 一个扩展，它将静态图形视为帧，调用第三方工具合成 GIF 动图或 MP4 视频等，要想深入了解 ggplot2，可以去看 Hadley Wickham, Danielle Navarro, and Thomas Lin Pedersen 合著的《ggplot2: elegant graphics for data analysis》第三版 https://ggplot2-book.org/。 http://varianceexplained.org/r/why-I-use-ggplot2/↩︎ https://simplystatistics.org/2016/02/11/why-i-dont-use-ggplot2/↩︎ https://github.com/ricardo-bion/medium_visualization↩︎ https://leonawicz.github.io/↩︎ https://stat.ethz.ch/pipermail/r-help/2007-October/142420.html↩︎ "],["sec-elements.html", "7.1 元素", " 7.1 元素 7.1.1 标签 图形的标签分为横纵轴标签、刻度标签、主标题、副标题等 data.frame( dates = seq.Date( from = as.Date(&quot;1945-01-01&quot;), to = as.Date(&quot;1974-12-31&quot;), by = &quot;quarter&quot; ), presidents = as.vector(presidents) ) %&gt;% ggplot(aes(x = dates, y = presidents)) + geom_line(color = &quot;slategray&quot;, na.rm = TRUE) + geom_point(size = 1.5, color = &quot;darkslategray&quot;, na.rm = TRUE) + scale_x_date(date_breaks = &quot;4 year&quot;, date_labels = &quot;%Y&quot;) + labs( title = &quot;1945年至1974年美国总统每季度支持率&quot;, y = &quot;支持率 (%)&quot;, caption = &quot;数据源: R 包 datasets&quot; ) + theme_minimal(base_size = 10.54, base_family = &quot;source-han-sans-cn&quot;) 图 7.2: 美国总统支持率：自1945年第一季度至1974年第四季度 7.1.2 注释 图中注释的作用在于高亮指出关键点，提请读者注意。文本注释可由 ggrepel 包提供的标签图层 geom_label_repel() 添加，标签数据可独立于之前的数据层，标签所在的位置可以通过参数 direction 和 nudge_y 精调，图 7.3 模拟了一组数据。 set.seed(2020) library(ggrepel) dat &lt;- data.frame( x = seq(100), y = cumsum(rnorm(100)) ) anno_data &lt;- dat %&gt;% subset(x %% 25 == 10) %&gt;% transform(text = &quot;text&quot;) dat %&gt;% ggplot(aes(x, y)) + geom_line() + geom_label_repel(aes(label = text), data = anno_data, direction = &quot;y&quot;, nudge_y = c(-5, 5, 5, 5) ) + theme_minimal() 图 7.3: 文本注释 ggrepel 包的图层 geom_text_repel() 支持所有数据点的注释，并且自动调整文本的位置，防止重叠，增加辨识度，如图 7.4。当然，数据点如果过于密集也不适合全部注释，高亮其中的关键点即可。 mtcars %&gt;% transform(cyl = as.factor(cyl)) %&gt;% ggplot(aes(wt, mpg, label = rownames(mtcars), color = cyl)) + geom_point() + geom_text_repel(max.overlaps = 12) + theme_minimal() 图 7.4: 少量点的情况下可以全部注释，且可以解决注释重叠的问题 Claus Wilke 开发的 ggtext 包支持更加丰富的注释样式，详见网站 https://wilkelab.org/ggtext/ 7.1.3 主题 ggcharts 和 bbplot prettyB 美化 Base R 图形 ggprism "],["sec-fonts.html", "7.2 字体", " 7.2 字体 firatheme 包提供基于 fira sans 字体的 ggplot2 主题，类似的字体主题包还有 trekfont 、 fontHind， fontquiver 包与 fontBitstreamVera（Bitstream Vera 字体）、 fontLiberation（Liberation 字体）包和 fontDejaVu （DejaVu 字体）包一道提供了一些可允许使用的字体文件，这样，我们可以不依赖系统制作可重复的图形。Thomas Lin Pedersen 开发的 systemfonts 可直接使用系统自带的字体。 7.2.1 系统字体 以 CentOS 系统为例，软件仓库中包含 Noto ， DejaVu 、liberation 等字体。可以安装自己喜欢的字体类型，比如： sudo dnf install -y \\ google-noto-mono-fonts \\ google-noto-sans-fonts \\ google-noto-serif-fonts \\ dejavu-sans-mono-fonts \\ dejavu-sans-fonts \\ dejavu-serif-fonts # 或者 sudo dnf install -y dejavu-fonts liberation-fonts liberation 系列的四款字体可以用来替换 Windows 系统上对应的四款字体，对应关系见表 7.1 表 7.1: Windows 系统上四款字体的替代品 CentOS 系统 Windows 系统 衬线体/宋体 liberation-serif-fonts Times New Roman 无衬线体/黑体 liberation-sans-fonts Arial Arial 的细瘦版 liberation-narrow-fonts Arial Narrow 等宽体/微软雅黑 liberation-mono-fonts Courier New 此外，我们还可以从网上获取各种个样的字体，特别地，Boryslav Larin 收录的 awesome-fonts 列表是一个不错的开始，比如图标字体 Font-Awesome， sudo dnf install -y fontawesome-fonts 再安装宏包 fontawesome 后，即可在 LaTeX 文档中使用，下面这个示例推荐用 XeLaTeX 引擎编译。 \\documentclass[border=10pt]{standalone} \\usepackage{fontawesome} \\begin{document} Hello, \\faGithub \\end{document} 而在 R 绘制的图形中，通过指定 par()、 plot()、 title() 等函数的 family 参数值，比如 family = \"DejaVu Sans\" 来调用系统无衬线 DejaVu 字体，效果见图 7.5。 plot(data = pressure, pressure ~ temperature, xlab = &quot;Temperature (deg C)&quot;, ylab = &quot;Pressure (mm of Hg)&quot;, col.lab = &quot;red&quot;, col.axis = &quot;blue&quot;, font.lab = 3, font.axis = 2, family = &quot;DejaVu Sans&quot;) title(main = &quot;Vapor Pressure of Mercury as a Function of Temperature&quot;, family = &quot;DejaVu Serif&quot;, font.main = 3) title(sub = &quot;Data Source: Weast, R. C&quot;, family = &quot;DejaVu Sans Mono&quot;, font.sub = 1) 图 7.5: 调用系统字体绘图 添加网络字体，供 showtext 调用 sysfonts::font_add_google(name = &quot;Noto Sans&quot;, family = &quot;Noto Sans&quot;) sysfonts::font_add_google(name = &quot;Noto Serif&quot;, family = &quot;Noto Serif&quot;) sysfonts::font_add_google(name = &quot;Noto Serif SC&quot;, family = &quot;Noto Serif SC&quot;) sysfonts::font_add_google(name = &quot;Noto Sans SC&quot;, family = &quot;Noto Sans SC&quot;) 在 ggplot2 绘图中的调用方式是类似的，如图 7.6。 p1 &lt;- ggplot(pressure, aes(x = temperature, y = pressure)) + geom_point() + ggtitle(label = &quot;默认字体设置&quot;) p2 &lt;- p1 + theme( axis.title = element_text(family = &quot;Noto Sans&quot;), axis.text = element_text(family = &quot;Noto Serif&quot;) ) + ggtitle(label = &quot;英文字体设置&quot;) p3 &lt;- p1 + labs(x = &quot;温度&quot;, y = &quot;压力&quot;) + theme( axis.title = element_text(family = &quot;source-han-serif-cn&quot;), axis.text = element_text(family = &quot;Noto Serif&quot;) ) + ggtitle(label = &quot;中文字体设置&quot;) p4 &lt;- p1 + labs( x = &quot;温度&quot;, y = &quot;压力&quot;, title = &quot;散点图&quot;, subtitle = &quot;Vapor Pressure of Mercury as a Function of Temperature&quot;, caption = paste(&quot;Data on the relation between temperature in degrees Celsius and&quot;, &quot;vapor pressure of mercury in millimeters (of mercury).&quot;, sep = &quot;\\n&quot; ) ) + theme( axis.title = element_text(family = &quot;source-han-serif-cn&quot;), axis.text.x = element_text(family = &quot;Noto Serif&quot;), axis.text.y = element_text(family = &quot;Noto Sans&quot;), title = element_text(family = &quot;source-han-serif-cn&quot;), plot.subtitle = element_text(family = &quot;Noto Sans&quot;, size = rel(0.7)), plot.caption = element_text(family = &quot;Noto Sans&quot;, size = rel(0.6)) ) + ggtitle(label = &quot;任意字体设置&quot;) (p1 + p2) / (p3 + p4) 图 7.6: 在 ggplot2 绘图系统中设置中英文字体 另外值得一提的是 hrbrthemes 包，除了定制了很多 ggplot2 主题，它还打包了很多的字体主题。比如默认主题 theme_ipsum() 使用 Arial Narrow 字体，如果没有该字体就自动寻找系统中的替代品，如图 7.7 实际使用的是 Nimbus Sans Narrow 字体，因为在 GitHub Action 中，我实际使用的测试环境是 Ubuntu 20.04，该系统自带 Nimbus Sans Narrow 字体，Arial Narrow 毕竟是 Windows 上的闭源字体。 # brew install font-roboto # 导入字体 hrbrthemes::import_roboto_condensed() # sysfonts::font_add_google(name = &quot;Roboto Condensed&quot;, family = &quot;Roboto Condensed&quot;) library(hrbrthemes) ggplot(mtcars, aes(mpg, wt)) + geom_point() + labs( x = &quot;Fuel efficiency (mpg)&quot;, y = &quot;Weight (tons)&quot;, title = &quot;Seminal ggplot2 scatterplot example&quot;, subtitle = &quot;A plot that is only useful for demonstration purposes&quot;, caption = &quot;Brought to you by the letter &#39;g&#39;&quot; ) + theme_ipsum() 图 7.7: 调用 hrbrthemes 包设置字体主题 如果系统没有安装 Arial Narrow 字体，可以导入 hrbrthemes 包自带的一些字体，比如 hrbrthemes::import_roboto_condensed()，然后调用字体主题 theme_ipsum_rc() 。如果不想使用这个包自带的字体，可以用系统中安装的字体去修改主题 theme_ipsum() 和 theme_ipsum_rc() 中的字体设置。如图 7.8 使用了 Liberation Sans Narrow ( MacOS 上没有 Liberation Sans Narrow 字体，用 Liberation Sans 替代了) 字体替换 theme_ipsum() 中的 Arial Narrow 字体。 ggplot(mtcars, aes(mpg, wt)) + geom_point() + labs( x = &quot;Fuel efficiency (mpg)&quot;, y = &quot;Weight (tons)&quot;, title = &quot;Seminal ggplot2 scatterplot example&quot;, subtitle = &quot;A plot that is only useful for demonstration purposes&quot;, caption = &quot;Brought to you by the letter &#39;g&#39;&quot; ) + theme_ipsum(base_family = &quot;Liberation Sans&quot;) 图 7.8: 用 Liberation Sans Narrow 字体替换默认字体 Arial Narrow hrbrthemes 包提供了一个全局字体加载选项 hrbrthemes.loadfonts ，如果设置为 TRUE，即 options(hrbrthemes.loadfonts = TRUE) 会先调用函数 extrafont::loadfonts() 预加载系统字体，就不用一次次手动加载字体了。后续在第 7.2.3 节还会提及 extrafont 包的其它功能。 7.2.2 思源字体 邱怡轩开发的 showtext 包支持丰富的外部字体，支持 Base R 和 ggplot2 图形，图 7.9 嵌入了 5 号思源宋体，图例和坐标轴文本使用 serif 字体，更多详细的使用文档见 (Qiu 2015)。 # 安装 showtext 包 install.packages(&#39;showtext&#39;) # 思源宋体 showtextdb::font_install(showtextdb::source_han_serif()) # 思源黑体 showtextdb::font_install(showtextdb::source_han_sans()) ggplot(iris, aes(Sepal.Length, Sepal.Width)) + geom_point(aes(colour = Species)) + scale_colour_brewer(palette = &quot;Set1&quot;) + labs( title = &quot;鸢尾花数据的散点图&quot;, x = &quot;萼片长度&quot;, y = &quot;萼片宽度&quot;, colour = &quot;鸢尾花类别&quot;, caption = &quot;鸢尾花数据集最早见于 Edgar Anderson (1935) &quot; ) + theme( title = element_text(family = &quot;source-han-sans-cn&quot;), axis.title = element_text(family = &quot;source-han-serif-cn&quot;), legend.title = element_text(family = &quot;source-han-serif-cn&quot;) ) 图 7.9: showtext 包处理图里的中文 斐济是太平洋上的一个岛国，受地壳板块运动的影响，地震活动频繁，图 7.10 清晰展示了它的地震带。 library(maps) library(mapdata) FijiMap &lt;- map_data(&quot;worldHires&quot;, region = &quot;Fiji&quot;) ggplot(FijiMap, aes(x = long, y = lat)) + geom_map(map = FijiMap, aes(map_id = region), size = .2) + geom_point(data = quakes, aes(x = long, y = lat, colour = mag)) + xlim(160, 195) + scale_colour_distiller(palette = &quot;Spectral&quot;) + scale_y_continuous(breaks = (-18:18) * 5) + coord_map(&quot;ortho&quot;, orientation = c(-10, 180, 0)) + labs(colour = &quot;震级&quot;, x = &quot;经度&quot;, y = &quot;纬度&quot;, title = &quot;斐济地震带&quot;) + theme_minimal() + theme( title = element_text(family = &quot;source-han-sans-cn&quot;), axis.title = element_text(family = &quot;source-han-serif-cn&quot;), legend.title = element_text(family = &quot;source-han-sans-cn&quot;), legend.position = c(1, 0), legend.justification = c(1, 0) ) 图 7.10: 斐济地震带 7.2.3 数学字体 Winston Chang 将 Paul Murrell 的 Computer Modern 字体文件打包成 fontcm 包 (Chang, Kryukov, and Murrell 2014)，fontcm 包可以在 Base R 图形中嵌入数学字体，16图形中嵌入重音字符。17 下面先下载、安装、加载字体， library(extrafont) font_addpackage(pkg = &quot;fontcm&quot;) 查看可被 pdf() 图形设备使用的字体列表 # 可用的字体 fonts() ## [1] &quot;Roboto Condensed&quot; &quot;xkcd&quot; &quot;CM Roman&quot; ## [4] &quot;CM Roman Asian&quot; &quot;CM Roman CE&quot; &quot;CM Roman Cyrillic&quot; ## [7] &quot;CM Roman Greek&quot; &quot;CM Sans&quot; &quot;CM Sans Asian&quot; ## [10] &quot;CM Sans CE&quot; &quot;CM Sans Cyrillic&quot; &quot;CM Sans Greek&quot; ## [13] &quot;CM Symbol&quot; &quot;CM Typewriter&quot; &quot;CM Typewriter Asian&quot; ## [16] &quot;CM Typewriter CE&quot; &quot;CM Typewriter Cyrillic&quot; &quot;CM Typewriter Greek&quot; fontcm 包提供数学字体，grDevices::embedFonts() 函数调用 Ghostscript 软件将数学字体嵌入 ggplot2 图形中，达到正确显示数学公式的目的，此方法适用于 pdf 设备保存的图形，对 cairo_pdf() 保存的 PDF 格式图形无效。 library(fontcm) library(ggplot2) library(extrafont) library(patchwork) p &lt;- ggplot(data = data.frame(x = c(1, 5), y = c(1, 5)), aes(x = x, y = y)) + geom_point() + labs(x = &quot;Made with CM fonts&quot;, y = &quot;Made with CM fonts&quot;, title = &quot;Made with CM fonts&quot;) # 公式 eq &lt;- &quot;italic(sum(frac(1, n*&#39;!&#39;), n==0, infinity) == lim(bgroup(&#39;(&#39;, 1 + frac(1, n), &#39;)&#39;)^n, n %-&gt;% infinity))&quot; # 默认字体 p1 &lt;- p + annotate(&quot;text&quot;, x = 3, y = 3, parse = TRUE, label = eq ) # 使用 CM Roman 字体 p2 &lt;- p + annotate(&quot;text&quot;, x = 3, y = 3, parse = TRUE, label = eq, family = &quot;CM Roman&quot; ) + theme( text = element_text(size = 16, family = &quot;CM Roman&quot;), axis.title.x = element_text(face = &quot;italic&quot;), axis.title.y = element_text(face = &quot;bold&quot;) ) p1 + p2 图 7.11: fontcm 处理数学公式 为实现图 7.11 的最终效果，需要启用一个有超级牛力的 fig.process 选项，主要是传递一个函数给它，对用 R 语言生成的图形再操作。 # embed math fonts to pdf embed_math_fonts &lt;- function(fig_path) { if(knitr::is_latex_output()){ embedFonts( file = fig_path, outfile = fig_path, fontpaths = system.file(&quot;fonts&quot;, package = &quot;fontcm&quot;) ) } return(fig_path) } 代码块选项中设置 fig.process=embed_math_fonts 可在绘图后，立即插入字体，此操作仅限于以 pdf 格式保存的图形设备，也适用于 Base R 绘制的图形，见图 7.12。 par(mar = c(4.1, 4.1, 1.5, 0.5), family = &quot;CM Roman&quot;) x &lt;- seq(-4, 4, len = 101) y &lt;- cbind(sin(x), cos(x)) matplot(x, y, type = &quot;l&quot;, xaxt = &quot;n&quot;, main = expression(paste( plain(sin) * phi, &quot; and &quot;, plain(cos) * phi )), ylab = expression(&quot;sin&quot; * phi, &quot;cos&quot; * phi), xlab = expression(paste(&quot;Phase Angle &quot;, phi)), col.main = &quot;blue&quot; ) axis(1, at = c(-pi, -pi / 2, 0, pi / 2, pi), labels = expression(-pi, -pi / 2, 0, pi / 2, pi) ) 图 7.12: 嵌入数学字体 7.2.4 TikZ 设备 与 7.2.3 小节不同，Ralf Stubner 维护的 tikzDevice 包提供了另一种嵌入数学字体的方式，其提供的 tikzDevice::tikz() 绘图设备将图形对象转化为 TikZ 代码，调用 LaTeX 引擎编译成 PDF 文档。安装后，先测试一下 LaTeX 编译环境是否正常。 tikzDevice::tikzTest() ## ## Active compiler: ## /home/runner/.TinyTeX/bin/x86_64-linux/xelatex ## XeTeX 3.141592653-2.6-0.999993 (TeX Live 2021) ## kpathsea version 6.3.3 ## [1] 7.90259 确认没有问题后，下面图 7.13 的坐标轴标签，标题，图例等位置都支持数学公式，使用 tikzDevice 打造出版级的效果图。更多功能的介绍见 https://www.daqana.org/tikzDevice/。 x &lt;- rnorm(10) y &lt;- x + rnorm(5, sd = 0.25) model &lt;- lm(y ~ x) rsq &lt;- summary(model)$r.squared rsq &lt;- signif(rsq, 4) plot(x, y, main = &quot;Hello \\\\LaTeX!&quot;, xlab = &quot;$x$&quot;, ylab = &quot;$y$&quot;, sub = &quot;$\\\\mathcal{N}(x;\\\\mu,\\\\Sigma)$&quot; ) abline(model, col = &quot;red&quot;) mtext(paste(&quot;Linear model: $R^{2}=&quot;, rsq, &quot;$&quot;), line = 0.5) legend(&quot;bottomright&quot;, legend = paste0( &quot;$y = &quot;, round(coef(model)[2], 3), &quot;x +&quot;, round(coef(model)[1], 3), &quot;$&quot; ), bty = &quot;n&quot; ) 图 7.13: 线性回归模型 推荐的全局 LaTeX 环境配置如下： options( tinytex.engine = &quot;xelatex&quot;, tikzDefaultEngine = &quot;xetex&quot;, tikzDocumentDeclaration = &quot;\\\\documentclass[tikz]{standalone}\\n&quot;, tikzXelatexPackages = c( &quot;\\\\usepackage[fontset=adobe]{ctex}&quot;, &quot;\\\\usepackage[default,semibold]{sourcesanspro}&quot;, &quot;\\\\usepackage{amsfonts,mathrsfs,amssymb}\\n&quot; ) ) 设置默认的 LaTeX 编译引擎为 XeLaTeX，相比于 PDFLaTeX，它对中文的兼容性更好，支持多平台下的中文环境，中文字体这里采用了 Adobe 的字体，默认加载了 mathrsfs 宏包支持 \\mathcal、\\mathscr 等命令，此外， LaTeX 发行版采用谢益辉自定义的 TinyTeX。绘制独立的 PDF 图形的过程如下： library(tikzDevice) tf &lt;- file.path(getwd(), &quot;tikz-regression.tex&quot;) tikz(tf, width = 6, height = 5.5, pointsize = 30, standAlone = TRUE) # 绘图代码 dev.off() # 编译成 PDF 图形 tinytex::latexmk(file = &quot;tikz-regression.tex&quot;) 7.2.5 漫画字体 下载 XKCD 字体，并刷新系统字体缓存 mkdir -p ~/.fonts curl -fLo ~/.fonts/xkcd.ttf http://simonsoftware.se/other/xkcd.ttf fc-cache -fsv 将 XKCD 字体导入到 R 环境，以便后续被 ggplot2 图形设备调用。 R -e &#39;library(extrafont);font_import(pattern=&quot;[X/x]kcd.ttf&quot;, prompt = FALSE)&#39; 图 7.14 是一个使用 xkcd 字体的简单例子，更多高级特性请看 xkcd 包文档 (Torres-Manzanera 2018) library(extrafont) library(xkcd) ggplot(aes(mpg, wt), data = mtcars) + geom_point() + theme_xkcd() 图 7.14: 漫画风格的字体方案 7.2.6 表情字体 余光创开发的 emojifont 包和 Hadley 开发的 emo 包，下面给出一个示例 7.15 # remotes::install_github(&quot;hadley/emo&quot;) data.frame( category = c(&quot;pineapple&quot;, &quot;apple&quot;, &quot;watermelon&quot;, &quot;mango&quot;, &quot;pear&quot;), value = c(5, 4, 3, 7, 2) ) %&gt;% transform(category = sapply(category, emo::ji)) %&gt;% ggplot(aes(x = category, y = value)) + geom_text(aes(label = category), size = 12, vjust = -0.5) + theme_minimal() 图 7.15: 表情字体 除了安装 emo 包，系统需要先安装好 emoji 字体，图形才会正确地渲染出来，想调用更多 emoji 图标请参考 Emoji 速查手册，给出 emoji 对应的名字。 sudo dnf install -y google-noto-emoji-color-fonts \\ google-noto-emoji-fonts # MacOS brew cask install font-noto-color-emoji font-noto-emoji 参考文献 "],["sec-colors.html", "7.3 配色", " 7.3 配色 配色真的是一门学问，有的人功力非常深厚，仅用黑白灰就可以创造出一个世界，如中国的水墨画，科波拉执导的《教父》，沃卓斯基姐妹执导的《黑客帝国》等。黑西装、白衬衫和黑领带是《黑客帝国》的经典元素，《教父》开场的黑西装、黑领结和白衬衫，尤其胸前的红玫瑰更是点睛之笔。导演将黑白灰和光影混合形成了层次丰富立体的画面，打造了一场视觉盛宴，无论是呈现在纸上还是银幕上都可以给人留下深刻的印象。正所谓食色性也，花花世界，岂能都是法印眼中的白骨！再说《红楼梦》里，芍药丛中，桃花树下，滴翠亭边，栊翠庵里，处处都是湘云、黛玉、宝钗、妙玉留下的四季诗歌。 为什么需要这么多颜色模式呢？主要取决于颜色输出的通道，比如印刷机，照相机，自然界，网页，人眼等，显示器因屏幕和分辨率的不同呈现的色彩数量是不一样的。读者大概都听说过 RGB、CMYK、AdobeRGB、sRGB、P3 广色域等名词，我想这主要归功于各大电子设备厂商的宣传。普清、高清、超高清、全高清、2K、4K、5K、视网膜屏，而 HSV、HCL 估计听说的人就少很多了。本节的目的是简单阐述背后的色彩原理，颜色模式及其之间的转化，在应对天花乱坠的销售时少交一些智商税，同时，告诉读者如何在 R 环境中使用色彩。早些时候我在统计之都论坛上发帖 – R语言绘图用调色板大全 https://d.cosx.org/d/419378，如果读者希望拿来即用，不妨去看看。 filled.contour(volcano, nlevels = 10, color.palette = terrain.colors) filled.contour(volcano, nlevels = 10, color.palette = heat.colors) filled.contour(volcano, nlevels = 10, color.palette = topo.colors) filled.contour(volcano, nlevels = 10, color.palette = cm.colors) 图 7.16: R 3.6.0 以前的调色板 filled.contour(volcano, nlevels = 10, color.palette = function(n, ...) hcl.colors(n, &quot;Grays&quot;, rev = TRUE, ...)) filled.contour(volcano, nlevels = 10, color.palette = function(n, ...) hcl.colors(n, &quot;YlOrRd&quot;, rev = TRUE, ...)) filled.contour(volcano, nlevels = 10, color.palette = function(n, ...) hcl.colors(n, &quot;purples&quot;, rev = TRUE, ...)) filled.contour(volcano, nlevels = 10, color.palette = function(n, ...) hcl.colors(n, &quot;viridis&quot;, rev = FALSE, ...)) 图 7.17: R 3.6.0 以后的调色板 hcl.colors() 函数是在 R 3.6.0 引入的，之前的 R 软件版本中没有，同时内置了 110 个调色板，详见 hcl.pals()。 7.3.1 调色板 R 预置的灰色有224种，挑出其中的调色板 grep(&quot;^gr(a|e)y&quot;, grep(&quot;gr(a|e)y&quot;, colors(), value = TRUE), value = TRUE, invert = TRUE) ## [1] &quot;darkgray&quot; &quot;darkgrey&quot; &quot;darkslategray&quot; &quot;darkslategray1&quot; ## [5] &quot;darkslategray2&quot; &quot;darkslategray3&quot; &quot;darkslategray4&quot; &quot;darkslategrey&quot; ## [9] &quot;dimgray&quot; &quot;dimgrey&quot; &quot;lightgray&quot; &quot;lightgrey&quot; ## [13] &quot;lightslategray&quot; &quot;lightslategrey&quot; &quot;slategray&quot; &quot;slategray1&quot; ## [17] &quot;slategray2&quot; &quot;slategray3&quot; &quot;slategray4&quot; &quot;slategrey&quot; gray_colors &lt;- paste0(rep(c(&quot;slategray&quot;, &quot;darkslategray&quot;), each = 4), seq(4)) barplot(1:8, col = gray_colors, border = NA) 图 7.18: 灰度调色板 gray 与 grey 是一样的，类似 color 和 colour 的关系，可能是美式和英式的差别，且看 all.equal(col2rgb(paste0(&quot;gray&quot;, seq(100))), col2rgb(paste0(&quot;grey&quot;, seq(100)))) ## [1] TRUE gray100 代表白色，gray0 代表黑色，提取灰色调色板，去掉首尾部分是必要的 barplot(1:8, col = gray.colors(8, start = .3, end = .9), main = &quot;gray.colors function&quot;, border = NA) 图 7.19: 提取 10 种灰色做调色板 首先选择一组合适的颜色，比如从桃色到梨色，选择6种颜色，以此为基础，可以借助 grDevices::colorRampPalette() 函数扩充至想要的数目，用 graphics::rect() 函数预览这组颜色配制的调色板 # Colors from https://github.com/johannesbjork/LaCroixColoR colors_vec &lt;- c(&quot;#FF3200&quot;, &quot;#E9A17C&quot;, &quot;#E9E4A6&quot;, &quot;#1BB6AF&quot;, &quot;#0076BB&quot;, &quot;#172869&quot;) # 代码来自 ?colorspace::rainbow_hcl pal &lt;- function(n = 20, colors = colors, border = &quot;light gray&quot;, ...) { colorname &lt;- (grDevices::colorRampPalette(colors))(n) plot(0, 0, type = &quot;n&quot;, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, ... ) rect(0:(n - 1) / n, 0, 1:n / n, 1, col = colorname, border = border) } par(mar = rep(0, 4)) pal(n = 20, colors = colors_vec, xlab = &quot;Colors from Peach to Pear&quot;, ylab = &quot;&quot;) 图 7.20: 桃色至梨色的渐变 colorRampPalette() 自制调色板 create_palette &lt;- function(n = 1000, colors = c(&quot;blue&quot;, &quot;orangeRed&quot;)) { color_palette &lt;- colorRampPalette(colors)(n) barplot(rep(1, times = n), col = color_palette, border = color_palette, axes = FALSE) } par(mfrow = c(3, 1), mar = c(0.1, 0.1, 0.5, 0.1), xaxs = &quot;i&quot;, yaxs = &quot;i&quot;) create_palette(n = 1000, colors = c(&quot;blue&quot;, &quot;orangeRed&quot;)) create_palette(n = 1000, colors = c(&quot;darkgreen&quot;, &quot;yellow&quot;, &quot;orangered&quot;)) create_palette(n = 1000, colors = c(&quot;blue&quot;, &quot;white&quot;, &quot;orangered&quot;)) 图 7.21: colorRampPalette 自制调色板 par(mar = c(0, 4, 0, 0)) RColorBrewer::display.brewer.all() 图 7.22: RColorBrewer 调色板 # 代码来自 ?palettes demo.pal &lt;- function(n, border = if (n &lt; 32) &quot;light gray&quot; else NA, main = paste(&quot;color palettes: alpha = 1, n=&quot;, n), ch.col = c( &quot;rainbow(n, start=.7, end=.1)&quot;, &quot;heat.colors(n)&quot;, &quot;terrain.colors(n)&quot;, &quot;topo.colors(n)&quot;, &quot;cm.colors(n)&quot;, &quot;gray.colors(n, start = 0.3, end = 0.9)&quot; )) { nt &lt;- length(ch.col) i &lt;- 1:n j &lt;- n / nt d &lt;- j / 6 dy &lt;- 2 * d plot(i, i + d, type = &quot;n&quot;, axes = FALSE, ylab = &quot;&quot;, xlab = &quot;&quot;, main = main) for (k in 1:nt) { rect(i - .5, (k - 1) * j + dy, i + .4, k * j, col = eval(parse(text = ch.col[k])), border = border ) text(2 * j, k * j + dy / 4, ch.col[k]) } } n &lt;- if (.Device == &quot;postscript&quot;) 64 else 16 # Since for screen, larger n may give color allocation problem par(mar = c(0, 0, 2, 0)) demo.pal(n) 图 7.23: grDevices 调色板 par(mfrow = c(33, 1), mar = c(0, 0, .8, 0)) for (i in seq(32)) { pal(n = length((1 + 20 * (i - 1)):(20 * i)), colors()[(1 + 20 * (i - 1)):(20 * i)], main = paste(1 + 20 * (i - 1), &quot;to&quot;, 20 * i)) } pal(n = 17, colors()[641:657], main = &quot;641 to 657&quot;) 图 7.24: grDevices 调色板 library(colorspace) ## a few useful diverging HCL palettes par(mar = c(0,0,2,0), mfrow = c(16, 2)) pal(n = 16, diverge_hcl(16), main = &quot;diverging HCL palettes&quot;) pal(n = 16, diverge_hcl(16, h = c(246, 40), c = 96, l = c(65, 90))) pal(n = 16, diverge_hcl(16, h = c(130, 43), c = 100, l = c(70, 90))) pal(n = 16, diverge_hcl(16, h = c(180, 70), c = 70, l = c(90, 95))) pal(n = 16, diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95))) pal(n = 16, diverge_hcl(16, h = c(128, 330), c = 98, l = c(65, 90))) pal(n = 16, diverge_hcl(16, h = c(255, 330), l = c(40, 90))) pal(n = 16, diverge_hcl(16, c = 100, l = c(50, 90), power = 1)) ## sequential palettes pal(n = 16, sequential_hcl(16), main= &quot;sequential palettes&quot;) pal(n = 16, heat_hcl(16, h = c(0, -100), l = c(75, 40), c = c(40, 80), power = 1)) pal(n = 16, terrain_hcl(16, c = c(65, 0), l = c(45, 95), power = c(1/3, 1.5))) pal(n = 16, heat_hcl(16, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5))) ## compare base and colorspace palettes ## (in color and desaturated) ## diverging red-blue colors pal(n = 16, diverge_hsv(16), main = &quot;diverging red-blue colors&quot;) pal(n = 16, diverge_hcl(16, c = 100, l = c(50, 90))) pal(n = 16, desaturate(diverge_hsv(16))) pal(n = 16, desaturate(diverge_hcl(16, c = 100, l = c(50, 90)))) ## diverging cyan-magenta colors pal(n = 16, cm.colors(16), main = &quot;diverging cyan-magenta colors&quot;) pal(n = 16, diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95))) pal(n = 16, desaturate(cm.colors(16))) pal(n = 16, desaturate(diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95)))) ## heat colors pal(n = 16, heat.colors(16), main = &quot;heat colors&quot;) pal(n = 16, heat_hcl(16)) pal(n = 16, desaturate(heat.colors(16))) pal(n = 16, desaturate(heat_hcl(16))) ## terrain colors pal(n = 16, terrain.colors(16), main = &quot;terrain colors&quot;) pal(n = 16, terrain_hcl(16)) pal(n = 16, desaturate(terrain.colors(16))) pal(n = 16, desaturate(terrain_hcl(16))) pal(n = 16, rainbow_hcl(16, start = 30, end = 300), main = &quot;dynamic&quot;) pal(n = 16, rainbow_hcl(16, start = 60, end = 240), main = &quot;harmonic&quot;) pal(n = 16, rainbow_hcl(16, start = 270, end = 150), main = &quot;cold&quot;) pal(n = 16, rainbow_hcl(16, start = 90, end = -30), main = &quot;warm&quot;) 图 7.25: colorspace 调色板 除之前提到的 grDevices 包， colorspace (https://hclwizard.org/) 包 (Stauffer et al. 2009; Zeileis, Hornik, and Murrell 2009; Zeileis et al. 2019)，RColorBrewer 包 (Neuwirth 2014) https://colorbrewer2.org/，viridis 包、colourvalues、wesanderson、dichromat 包、pals 包，palr 包，colorRamps 包、ColorPalette 包、colortools 包就不一一详细介绍了。 colormap 包基于 node.js 的 colormap 模块提供 44 个预定义的调色板 paletteer 包收集了很多 R 包提供的调色板，同时也引入了很多依赖。 yarrr 包主要是为书籍 《YaRrr! The Pirate’s Guide to R》 https://github.com/ndphillips/ThePiratesGuideToR 提供配套资源，兼顾收集了一组调色板。 RColorBrewer 调色板数量必须至少 3 个，这是上游 colorbrewer 的 问题，具体体现在调用 RColorBrewer::brewer.pal(n = 2, name = \"Set2\") 时会有警告。 plotly 调用 [1] &quot;#66C2A5&quot; &quot;#FC8D62&quot; &quot;#8DA0CB&quot; Warning message: In RColorBrewer::brewer.pal(n = 2, name = &quot;Set2&quot;) : minimal value for n is 3, returning requested palette with 3 different levels par(mar = c(1, 2, 1, 0), mfrow = c(3, 2)) set.seed(1234) x &lt;- sample(seq(8), 8, replace = FALSE) barplot(x, col = palette(), border = &quot;white&quot;) barplot(x, col = heat.colors(8), border = &quot;white&quot;) barplot(x, col = gray.colors(8), border = &quot;white&quot;) barplot(x, col = &quot;lightblue&quot;, border = &quot;white&quot;) barplot(x, col = colorspace::sequential_hcl(8), border = &quot;white&quot;) barplot(x, col = colorspace::diverge_hcl(8, h = c(130, 43), c = 100, l = c(70, 90) ), border = &quot;white&quot;) 图 7.26: 源起 与图 8.14 对比，图7.27 的层次更加丰富，识别性更高 expand.grid(months = month.abb, years = 1949:1960) %&gt;% transform(num = as.vector(AirPassengers)) %&gt;% ggplot(aes(x = years, y = months, fill = num)) + scale_fill_distiller(palette = &quot;Spectral&quot;) + geom_tile(color = &quot;white&quot;, size = 0.4) + scale_x_continuous( expand = c(0.01, 0.01), breaks = seq(1949, 1960, by = 1), labels = 1949:1960 ) + theme_minimal( base_size = 10.54, base_family = &quot;source-han-serif-cn&quot; ) + labs(x = &quot;年&quot;, y = &quot;月&quot;, fill = &quot;人数&quot;) 图 7.27: Spectral 调色板 再举栗子，图 7.28 是正负例对比，其中好在哪里呢？这张图要表达美国黄石国家公园的老忠实泉间歇喷发的时间规律，那么好的标准就是层次分明，以突出不同颜色之间的时间差异。这个差异，还要看起来不那么费眼睛，一目了然最好。 erupt &lt;- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) + geom_raster() + scale_x_continuous(NULL, expand = c(0, 0)) + scale_y_continuous(NULL, expand = c(0, 0)) + theme(legend.position = &quot;none&quot;) p1 &lt;- erupt + scale_fill_gradientn(colours = gray.colors(7)) p2 &lt;- erupt + scale_fill_distiller(palette = &quot;Spectral&quot;) p3 &lt;- erupt + scale_fill_gradientn(colours = terrain.colors(7)) p4 &lt;- erupt + scale_fill_continuous(type = &#39;viridis&#39;) (p1 + p2) / (p3 + p4) 图 7.28: 美国黄石国家公园的老忠实泉 RColorBrewer 包 提供了有序 (Sequential) 、定性 (Qualitative) 和发散 (Diverging) 三类调色板，一般来讲，分别适用于连续或有序分类变量、无序分类变量、两类分层对比变量的绘图。再加上强大的 ggplot2 包内置的对颜色处理的函数，如 scale_alpha_* 、 scale_colour_* 和 scale_fill_* 等，详见： ls(&quot;package:ggplot2&quot;, pattern = &quot;scale_col(ou|o)r_&quot;) ## [1] &quot;scale_color_binned&quot; &quot;scale_color_brewer&quot; ## [3] &quot;scale_color_continuous&quot; &quot;scale_color_date&quot; ## [5] &quot;scale_color_datetime&quot; &quot;scale_color_discrete&quot; ## [7] &quot;scale_color_distiller&quot; &quot;scale_color_fermenter&quot; ## [9] &quot;scale_color_gradient&quot; &quot;scale_color_gradient2&quot; ## [11] &quot;scale_color_gradientn&quot; &quot;scale_color_grey&quot; ## [13] &quot;scale_color_hue&quot; &quot;scale_color_identity&quot; ## [15] &quot;scale_color_manual&quot; &quot;scale_color_ordinal&quot; ## [17] &quot;scale_color_steps&quot; &quot;scale_color_steps2&quot; ## [19] &quot;scale_color_stepsn&quot; &quot;scale_color_viridis_b&quot; ## [21] &quot;scale_color_viridis_c&quot; &quot;scale_color_viridis_d&quot; ## [23] &quot;scale_colour_binned&quot; &quot;scale_colour_brewer&quot; ## [25] &quot;scale_colour_continuous&quot; &quot;scale_colour_date&quot; ## [27] &quot;scale_colour_datetime&quot; &quot;scale_colour_discrete&quot; ## [29] &quot;scale_colour_distiller&quot; &quot;scale_colour_fermenter&quot; ## [31] &quot;scale_colour_gradient&quot; &quot;scale_colour_gradient2&quot; ## [33] &quot;scale_colour_gradientn&quot; &quot;scale_colour_grey&quot; ## [35] &quot;scale_colour_hue&quot; &quot;scale_colour_identity&quot; ## [37] &quot;scale_colour_manual&quot; &quot;scale_colour_ordinal&quot; ## [39] &quot;scale_colour_steps&quot; &quot;scale_colour_steps2&quot; ## [41] &quot;scale_colour_stepsn&quot; &quot;scale_colour_viridis_b&quot; ## [43] &quot;scale_colour_viridis_c&quot; &quot;scale_colour_viridis_d&quot; ls(&quot;package:ggplot2&quot;, pattern = &quot;scale_fill_&quot;) ## [1] &quot;scale_fill_binned&quot; &quot;scale_fill_brewer&quot; &quot;scale_fill_continuous&quot; ## [4] &quot;scale_fill_date&quot; &quot;scale_fill_datetime&quot; &quot;scale_fill_discrete&quot; ## [7] &quot;scale_fill_distiller&quot; &quot;scale_fill_fermenter&quot; &quot;scale_fill_gradient&quot; ## [10] &quot;scale_fill_gradient2&quot; &quot;scale_fill_gradientn&quot; &quot;scale_fill_grey&quot; ## [13] &quot;scale_fill_hue&quot; &quot;scale_fill_identity&quot; &quot;scale_fill_manual&quot; ## [16] &quot;scale_fill_ordinal&quot; &quot;scale_fill_steps&quot; &quot;scale_fill_steps2&quot; ## [19] &quot;scale_fill_stepsn&quot; &quot;scale_fill_viridis_b&quot; &quot;scale_fill_viridis_c&quot; ## [22] &quot;scale_fill_viridis_d&quot; library(ColorPalette) par(mfrow = c(4, 1), mar = c(0, 0, 2, 0)) pal(generateMonochromaticColors(&quot;lightblue&quot;, 16), main = &quot;generateMonochromaticColors&quot;) pal(complementColors(&quot;lightblue&quot;, 16), main = &quot;complementColors&quot;) pal(tetradicColors(&quot;lightblue&quot;, 16), main = &quot;tetradicColors&quot;) pal(triadicColors(&quot;lightblue&quot;, 16), main = &quot;triadicColors&quot;) library(colorRamps) par(mfrow = c(6, 1), mar = c(0, 0, 2, 0)) n &lt;- 16 pal(matlab.like(n), main = &quot;matlab.like&quot;) pal(matlab.like2(n), main = &quot;matlab.like2&quot;) pal(blue2green2red(n), main = &quot;blue2green2red&quot;) pal(primary.colors(n), main = &quot;primary.colors&quot;) pal(ygobb(n), main = &quot;ygobb&quot;) pal(rgb.tables(n), main = &quot;rgb.tables&quot;) library(viridisLite) n &lt;- 16 par(mfrow = c(4, 1), mar = c(0, 0, 2, 0)) pal(magma(n, alpha = 1, begin = 0, end = 1)) pal(inferno(n, alpha = 1, begin = 0, end = 1)) pal(plasma(n, alpha = 1, begin = 0, end = 1)) pal(viridis(n, alpha = 1, begin = 0, end = 1)) par(mfrow = c(2, 1), mar = c(0, 3, 2, 0)) library(pals) pals::pal.bands( coolwarm, parula, ocean.haline, cubicl, kovesi.rainbow, ocean.phase, brewer.paired(12), stepped, main = &quot;Colormap suggestions&quot; ) # Qualtitative pals::pal.bands( brewer.accent(8), brewer.dark2(8), brewer.paired(12), brewer.pastel1(9), brewer.pastel2(8), brewer.set1(9), brewer.set2(8), brewer.set3(10), labels = c( &quot;brewer.accent&quot;, &quot;brewer.dark2&quot;, &quot;brewer.paired&quot;, &quot;brewer.pastel1&quot;, &quot;brewer.pastel2&quot;, &quot;brewer.set1&quot;, &quot;brewer.set2&quot;, &quot;brewer.set3&quot; ), main = &quot;Brewer qualitative&quot; ) par(mfrow = c(2, 1), mar = c(0, 3, 2, 0)) # Sequential pals::pal.bands( brewer.blues, brewer.bugn, brewer.bupu, brewer.gnbu, brewer.greens, brewer.greys, brewer.oranges, brewer.orrd, brewer.pubu, brewer.pubugn, brewer.purd, brewer.purples, brewer.rdpu, brewer.reds, brewer.ylgn, brewer.ylgnbu, brewer.ylorbr, brewer.ylorrd, main = &quot;Brewer sequential&quot; ) # Diverging pals::pal.bands( brewer.brbg, brewer.piyg, brewer.prgn, brewer.puor, brewer.rdbu, brewer.rdgy, brewer.rdylbu, brewer.rdylgn, brewer.spectral, main = &quot;Brewer diverging&quot; ) colortools::pals() colortools::wheel(colortools::pals(&quot;fish&quot;)[1], bg = &quot;white&quot;) yarrr::piratepal(palette = &quot;all&quot;) library(dichromat) par(mar = c(0, 0, 2, 0), mfrow = c(9, 2)) for (i in seq(17)) { pal(colorschemes[[i]], main = names(colorschemes)[i]) } library(colormap) color_map &lt;- function(colorname, border = &quot;light gray&quot;) { col &lt;- colormap_pal(colormap = colorname)(25) n &lt;- length(col) plot(0, 0, type = &quot;n&quot;, xlim = c(0, 1), ylim = c(0, 1), axes = FALSE, xlab = &quot;&quot;, ylab = &quot;&quot; ) rect(0:(n - 1) / n, 0, 1:n / n, 1, col = col, border = border) text(.5, .5, labels = colorname) } par(mfrow = c(22, 2), mar = c(0, 0, 1, 0)) invisible(lapply(unlist(colormaps), color_map)) 7.3.2 颜色模式 7.3.2.1 RGB 红(red)、绿(green)、蓝(blue)是三原色 rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1) 函数参数说明： red, blue, green, alpha 取值范围\\([0,M]\\)，\\(M\\) 是 maxColorValue names 字符向量，给这组颜色值取名 maxColorValue 红，绿，蓝三色范围的最大值 The colour specification refers to the standard sRGB colorspace (IEC standard 61966). rgb 产生一种颜色，如 rgb(255, 0, 0, maxColorValue = 255) 的颜色是 \"#FF0000\" ，这是一串16进制数，每两个一组，那么一组有 \\(16^2 = 256\\) 种组合，整个一串有 \\(256^3 = 16777216\\) 种组合，这就是RGB表达的所有颜色。 7.3.2.2 HSL 色相饱和度亮度 hue–saturation–luminance (HSL) 7.3.2.3 HSV Create a vector of colors from vectors specifying hue, saturation and value. 色相饱和度值 hsv(h = 1, s = 1, v = 1, alpha) This function creates a vector of colors corresponding to the given values in HSV space. rgb and rgb2hsv for RGB to HSV conversion; hsv函数通过设置色调、饱和度和亮度获得颜色，三个值都是0-1的相对量 RGB HSV HSL 都是不连续的颜色空间，缺点 7.3.2.4 HCL 基于感知的颜色空间替代RGB颜色空间 通过指定色相(hue)，色度(chroma)和亮度(luminance/lightness)，创建一组（种）颜色 hcl(h = 0, c = 35, l = 85, alpha, fixup = TRUE) 函数参数说明： h 颜色的色调，取值范围为[0,360]，0、120、240分别对应红色、绿色、蓝色 c 颜色的色度，其上界取决于色调和亮度 l 颜色的亮度，取值范围[0,100]，给定色调和色度，只有一部分子集可用 alpha 透明度，取值范围[0,1]，0 和1分别表示透明和不透明 This function corresponds to polar coordinates in the CIE-LUV color space 选色为什么这么难 色相与阴影相比是无关紧要的，色相对于标记和分类很有用，但表示（精细的）空间数据或形状的效果较差。颜色是改善图形的好工具，但糟糕的配色方案 (color schemes) 可能会导致比灰度调色板更差的效果。(Stauffer et al. 2009) 黑、白、灰，看似有三种颜色，其实只有一种颜色，黑和白只是灰色的两极，那么如何设置灰色梯度，使得人眼比较好区分它们呢？这样获得的调色板适用于什么样的绘图环境呢？ 7.3.2.5 CMYK 印刷三原色：青 (cyan)、品红 (magenta)、黄 (yellow) 颜色模式转化 col2rgb() 、rgb2hsv() 和 rgb() 函数 hex2RGB() 函数 colorspace col2hcl() 函数 scales col2HSV() colortools col2hex() col2rgb(&quot;lightblue&quot;) # color to RGB ## [,1] ## red 173 ## green 216 ## blue 230 scales::col2hcl(&quot;lightblue&quot;) # color to HCL ## [1] &quot;#ADD8E6&quot; # palr::col2hex(&quot;lightblue&quot;) # color to HEX # colortools::col2HSV(&quot;lightblue&quot;) # color to HSV rgb(173, 216, 230, maxColorValue = 255) # RGB to HEX ## [1] &quot;#ADD8E6&quot; colorspace::hex2RGB(&quot;#ADD8E6&quot;) # HEX to RGB ## R G B ## [1,] 0.6784314 0.8470588 0.9019608 rgb(.678, .847, .902, maxColorValue = 1) # RGB to HEX ## [1] &quot;#ADD8E6&quot; rgb2hsv(173, 216, 230, maxColorValue = 255) # RGB to HSV ## [,1] ## h 0.5409357 ## s 0.2478261 ## v 0.9019608 7.3.3 LaTeX 配色 LaTeX 宏包 xcolor 中定义颜色的常用方式有两种，其一，\\textcolor{green!40!yellow} 表示 40% 的绿色和 60% 的黄色混合色彩，其二，\\textcolor[HTML]{34A853} HEX 表示的色彩直接在 LaTeX 文档中使用的方式，类似地 \\textcolor[RGB]{52,168,83} 也表示 Google 图标中的绿色。 \\documentclass[tikz,border=10pt]{standalone} \\begin{document} \\begin{tikzpicture} \\draw (0,0) rectangle (2,1) node [midway] {\\textcolor[RGB]{52,168,83}{Hello} \\textcolor[HTML]{34A853}{\\TeX}}; \\end{tikzpicture} \\end{document} 对应于 R 中的调用方式为： rgb(52, 168, 83, maxColorValue = 255) ## [1] &quot;#34A853&quot; 7.3.4 ggplot2 配色 boxplot(weight ~ group, data = PlantGrowth, col = &quot;lightgray&quot;, notch = FALSE, varwidth = TRUE ) # 类似 boxplot ggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot(notch = FALSE, varwidth = TRUE, fill = &quot;lightgray&quot;) # 默认调色板 ggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot(notch = FALSE, varwidth = TRUE) # Google 调色板 ggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) + geom_boxplot(notch = FALSE, varwidth = TRUE) + scale_fill_manual(values = c(&quot;#4285f4&quot;, &quot;#34A853&quot;, &quot;#FBBC05&quot;, &quot;#EA4335&quot;)) 图 7.29: 几种不同的箱线图 参考文献 "],["chap-data-visualization-gallery.html", "第 8 章 数据可视化-图库", " 第 8 章 数据可视化-图库 library(ggplot2) library(patchwork) `%&gt;%` &lt;- magrittr::`%&gt;%` clean_plotly &lt;- function(p = ggplot2::last_plot(), ...) { plotly::ggplotly(p, ...) %&gt;% plotly::config(displayModeBar = FALSE) } "],["sec-ggplot2-pie.html", "8.1 饼图", " 8.1 饼图 我对饼图是又爱又恨，爱的是它表示百分比的时候，往往让读者联想到蛋糕，份额这类根深蒂固的情景，从而让数字通俗易懂、深入人心，是一种很好的表达方式，恨的也是这一点，我用柱状图表达不香吗？人眼对角度的区分度远不如柱状图呢，特别是当两个类所占的份额比较接近的时候，所以很多时候，除了用饼图表达份额，还会在旁边标上百分比，从数据可视化的角度来说，如图 8.1 所示，这是信息冗余！ BOD %&gt;% transform(., ratio = demand / sum(demand)) %&gt;% ggplot(., aes(x = &quot;&quot;, y = demand, fill = reorder(Time, demand))) + geom_bar(stat = &quot;identity&quot;, show.legend = FALSE, color = &quot;white&quot;) + coord_polar(theta = &quot;y&quot;) + geom_text(aes(x = 1.6, label = paste0(round(ratio, digits = 4) * 100, &quot;%&quot;)), position = position_stack(vjust = 0.5), color = &quot;black&quot; ) + geom_text(aes(x = 1.2, label = Time), position = position_stack(vjust = 0.5), color = &quot;black&quot; ) + theme_void(base_size = 14) 图 8.1: 饼图 plot_ly(type = \"pie\", ... ) 和添加图层 add_pie() 的效果是一样的 library(data.table) diamonds &lt;- as.data.table(diamonds) dat &lt;- diamonds[, .(cnt = .N), by = .(cut)] plotly::plot_ly() %&gt;% plotly::add_pie( data = dat, labels = ~cut, values = ~cnt, name = &quot;简单饼图1&quot;, domain = list(row = 0, column = 0) ) %&gt;% plotly::add_pie( data = dat, labels = ~cut, values = ~cnt, hole = 0.6, textposition = &quot;inside&quot;, textinfo = &quot;label+percent&quot;, name = &quot;简单饼图2&quot;, domain = list(row = 0, column = 1) ) %&gt;% plotly::layout( title = &quot;多图布局&quot;, showlegend = F, grid = list(rows = 1, columns = 2), xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE), yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE) ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.2: 饼图 设置参数 hole 可以绘制环形饼图，比如 hole = 0.6 "],["sec-ggplot2-map.html", "8.2 地图", " 8.2 地图 USArrests 数据集描述了1973年美国50个州每10万居民中因袭击、抢劫和强奸而逮捕的人，以及城市人口占比。这里的地图是指按照行政区划为边界的示意图，比如图 8.3 library(maps) crimes &lt;- data.frame(state = tolower(rownames(USArrests)), USArrests) # 等价于 crimes %&gt;% tidyr::pivot_longer(Murder:Rape) vars &lt;- lapply(names(crimes)[-1], function(j) { data.frame(state = crimes$state, variable = j, value = crimes[[j]]) }) crimes_long &lt;- do.call(&quot;rbind&quot;, vars) states_map &lt;- map_data(&quot;state&quot;) ggplot(crimes, aes(map_id = state)) + geom_map(aes(fill = Murder), map = states_map) + expand_limits(x = states_map$long, y = states_map$lat) + scale_fill_binned(type = &quot;viridis&quot;) + coord_map() + theme_minimal() 图 8.3: 1975年美国各州犯罪事件 先来看看中国及其周边，见图8.4，这个地图的缺陷就是中国南海及九段线没有标记，台湾和中国大陆不是一种颜色标记，这里的地图数据来自 R 包 maps 和 mapdata，像这样的地图就不宜在国内正式刊物上出现。 library(maps) library(mapdata) east_asia &lt;- map_data(&quot;worldHires&quot;, region = c( &quot;Japan&quot;, &quot;Taiwan&quot;, &quot;China&quot;, &quot;North Korea&quot;, &quot;South Korea&quot; ) ) ggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) + geom_polygon(colour = &quot;black&quot;) + scale_fill_brewer(palette = &quot;Set2&quot;) + theme_minimal() 图 8.4: 中国及其周边 绘制真正的地图需要考虑投影坐标系，观察角度、分辨率、政策法规等一系列因素，它是一种复杂的图形，如图 8.5 所示。 worldmap &lt;- map_data(&quot;world&quot;) # 默认 mercator 投影下的默认视角 c(90, 0, mean(range(x))) ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90) ) # 换观察角度 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map( xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) # 换投影坐标系 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90) ) # 二者皆换 ggplot(worldmap, aes(long, lat, group = group)) + geom_polygon(aes(fill = region), show.legend = FALSE) + coord_map(&quot;ortho&quot;, xlim = c(-120, 40), ylim = c(30, 90), orientation = c(90, 0, 0) ) 图 8.5: 画地图的正确姿势 "],["sec-ggplot2-heatmap.html", "8.3 热图", " 8.3 热图 Zuguang Gu 开发的 ComplexHeatmap 包实现复杂数据的可视化，用以发现关联数据集之间的模式。特别地，比如基因数据、生存数据等，更多应用见开发者的书籍 ComplexHeatmap 完全手册 。 R 包发布在 Bioconductor 上 https://www.bioconductor.org/packages/ComplexHeatmap。使用之前我要确保已经安装 BiocManager 包，这个包负责管理 Bioconductor 上所有的包，需要先安装它，然后安装 ComplexHeatmap 包 (Gu, Eils, and Schlesner 2016)。 if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;ComplexHeatmap&quot;) 参考文献 "],["sec-ggplot2-barplot.html", "8.4 条形图", " 8.4 条形图 # 漫谈条形图 https://cosx.org/2017/10/discussion-about-bar-graph set.seed(2020) dat &lt;- data.frame( age = rep(1:30, 2), gender = rep(c(&quot;man&quot;, &quot;woman&quot;), each = 30), num = sample(x = 1:100, size = 60, replace = T) ) # 重叠 p1 &lt;- ggplot(data = dat, aes(x = age, y = num, fill = gender)) + geom_col(position = &quot;identity&quot;, alpha = 0.5) # 堆积 p2 &lt;- ggplot(data = dat, aes(x = age, y = num, fill = gender)) + geom_col(position = &quot;stack&quot;) # 双柱 p3 &lt;- ggplot(data = dat, aes(x = age, y = num, fill = gender)) + geom_col(position = &quot;dodge&quot;) # 百分比 p4 &lt;- ggplot(data = dat, aes(x = age, y = num, fill = gender)) + geom_col(position = &quot;fill&quot;) + scale_y_continuous(labels = scales::percent_format()) + labs(y = &quot;%&quot;) (p1 + p2) / (p3 + p4) 图 8.6: 条形图的四种常见形态 以数据集 diamonds 为例，按照纯净度 clarity 和切工 cut 分组统计钻石的数量，再按切工分组统计不同纯净度的钻石数量占比，如表 8.1 所示 library(data.table) diamonds &lt;- as.data.table(diamonds) dat &lt;- diamonds[, .(cnt = .N), by = .(cut, clarity)] %&gt;% .[, pct := cnt / sum(cnt), by = .(cut)] %&gt;% .[, pct_pp := paste0(cnt, &quot; (&quot;, scales::percent(pct, accuracy = 0.01), &quot;)&quot;) ] # 分组计数 with(diamonds, table(clarity, cut)) dcast(dat, formula = clarity ~ cut, value.var = &quot;pct_pp&quot;) %&gt;% knitr::kable(align = &quot;crrrrr&quot;, caption = &quot;数值和比例组合呈现&quot;) 表 8.1: 数值和比例组合呈现 clarity Fair Good Very Good Premium Ideal I1 210 (13.04%) 96 (1.96%) 84 (0.70%) 205 (1.49%) 146 (0.68%) SI2 466 (28.94%) 1081 (22.03%) 2100 (17.38%) 2949 (21.38%) 2598 (12.06%) SI1 408 (25.34%) 1560 (31.80%) 3240 (26.82%) 3575 (25.92%) 4282 (19.87%) VS2 261 (16.21%) 978 (19.93%) 2591 (21.45%) 3357 (24.34%) 5071 (23.53%) VS1 170 (10.56%) 648 (13.21%) 1775 (14.69%) 1989 (14.42%) 3589 (16.65%) VVS2 69 (4.29%) 286 (5.83%) 1235 (10.22%) 870 (6.31%) 2606 (12.09%) VVS1 17 (1.06%) 186 (3.79%) 789 (6.53%) 616 (4.47%) 2047 (9.50%) IF 9 (0.56%) 71 (1.45%) 268 (2.22%) 230 (1.67%) 1212 (5.62%) 分别以堆积条形图和百分比堆积条形图展示，添加注释到条形图上，见 8.7 p1 = ggplot(data = dat, aes(x = cut, y = cnt, fill = clarity)) + geom_col(position = &quot;dodge&quot;) + geom_text(aes(label = cnt), position = position_dodge(1), vjust = -0.5) + geom_text(aes(label = scales::percent(pct, accuracy = 0.1)), position = position_dodge(1), vjust = 1, hjust = 0.5 ) + scale_fill_brewer(palette = &quot;Spectral&quot;) + labs(fill = &quot;clarity&quot;, y = &quot;&quot;, x = &quot;cut&quot;) + theme_minimal() + theme(legend.position = &quot;top&quot;) p2 = ggplot(data = dat, aes(y = cut, x = cnt, fill = clarity)) + geom_col(position = &quot;fill&quot;) + geom_text(aes(label = cnt), position = position_fill(1), vjust = -0.5) + geom_text(aes(label = scales::percent(pct, accuracy = 0.1)), position = position_fill(1), vjust = 1, hjust = 0.5 ) + scale_fill_brewer(palette = &quot;Spectral&quot;) + scale_x_continuous(labels = scales::percent) + labs(fill = &quot;clarity&quot;, y = &quot;&quot;, x = &quot;cut&quot;) + theme_minimal() + theme(legend.position = &quot;top&quot;) p1 / p2 图 8.7: 添加注释到条形图 借助 plotly 制作相应的动态百分比堆积条形图 ggplot(data = diamonds, aes(x = cut, fill = clarity)) + geom_bar(position = &quot;dodge2&quot;) + scale_fill_brewer(palette = &quot;Spectral&quot;) 图 8.8: 百分比堆积条形图 plotly::plot_ly(dat, y = ~cut, color = ~clarity, x = ~cnt, colors = &quot;Spectral&quot;, type = &quot;bar&quot;, text = ~ paste0( cnt, &quot;颗 &lt;br&gt;&quot;, &quot;占比：&quot;, scales::percent(pct, accuracy = 0.1), &quot;&lt;br&gt;&quot; ), hoverinfo = &quot;text&quot; ) %&gt;% plotly::layout(barmode = &quot;stack&quot;, barnorm = &quot;percent&quot;) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.8: 百分比堆积条形图 # `type = &quot;histogram&quot;` 以 cut 和 clarity 分组计数 plotly::plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Spectral&quot;, type = &quot;histogram&quot; ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.8: 百分比堆积条形图 # 堆积图 plotly::plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Spectral&quot;, type = &quot;histogram&quot; ) %&gt;% plotly::layout( barmode = &quot;stack&quot;, yaxis = list(title = &quot;cnt&quot;), legend = list(title = list(text = &quot;clarity&quot;)) ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.8: 百分比堆积条形图 # 百分比堆积图 plotly::plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Spectral&quot;, type = &quot;histogram&quot; ) %&gt;% plotly::layout( barmode = &quot;stack&quot;, barnorm = &quot;percent&quot;, yaxis = list(title = &quot;percent&quot;), legend = list(title = list(text = &quot;clarity&quot;)) ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.8: 百分比堆积条形图 library(apexcharter) apex(data = dat, aes(x = cut, y = cnt, fill = clarity), type = &quot;bar&quot;) apexcharter 仿照 ggplot2 的绘图函数，保持用户习惯的一致性 "],["sec-ggplot2-function.html", "8.5 函数图", " 8.5 函数图 蝴蝶图的参数方程如下 \\[\\begin{align} x &amp;= \\sin t \\big(\\mathrm e^{\\cos t} - 2 \\cos 4t + \\sin^5(\\frac{t}{12})\\big) \\\\ y &amp;= \\cos t \\big(\\mathrm e^{\\cos t} - 2 \\cos 4t + \\sin^5(\\frac{t}{12})\\big), t \\in [- \\pi, \\pi] \\end{align}\\] "],["sec-ggplot2-density.html", "8.6 密度图", " 8.6 密度图 heatmaps in ggplot2 二维密度图 ggplot(faithful, aes(x = eruptions, y = waiting)) + stat_density_2d(aes(fill = ..level..), geom = &quot;polygon&quot;) + xlim(1, 6) + ylim(40, 100) ggplot(faithful, aes(x = eruptions, y = waiting)) + stat_density2d(aes(fill = stat(level)), geom = &quot;polygon&quot;) + scale_fill_viridis_c(option = &quot;viridis&quot;) + xlim(1, 6) + ylim(40, 100) 图 8.9: 二维密度图 MASS::kde2d() 实现二维核密度估计，ggplot2 包提供了两种等价的绘图方式 stat_density_2d() 和 .. stat_density2d() 和 stat() plotly::plot_ly( data = faithful, x = ~eruptions, y = ~waiting, type = &quot;histogram2dcontour&quot; ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.10: 二维直方图/密度图/轮廓图 # plot_ly(faithful, x = ~waiting, y = ~eruptions) %&gt;% # add_histogram2d() %&gt;% # add_histogram2dcontour() 延伸一下，热力图 library(KernSmooth) den &lt;- bkde2D(x = faithful, bandwidth = c(0.7, 7)) # 热力图 p1 &lt;- plotly::plot_ly(x = den$x1, y = den$x2, z = den$fhat) %&gt;% plotly::config(displayModeBar = FALSE) %&gt;% plotly::add_heatmap() # 等高线图 p2 &lt;- plotly::plot_ly(x = den$x1, y = den$x2, z = den$fhat) %&gt;% plotly::config(displayModeBar = FALSE) %&gt;% plotly::add_contour() htmltools::tagList(p1, p2) "],["sec-ggplot2-violin.html", "8.7 提琴图", " 8.7 提琴图 2004 年 Daniel Adler 开发 vioplot 包实现提琴图的绘制，它可能是最早实现此功能的 R 包，随后10余年没有更新却一直坚挺在 CRAN 上，非常难得，好在 Thomas Kelly 已经接手维护。另一款绘制提琴图的 R 包是 Peter Kampstra 开发的 beanplot (Kampstra 2008)，也存在很多年了，不过随着时间的变迁，比较现代的方式是 ggplot2 带来的 geom_violin() 扔掉了很多依赖，也是各种图形的汇集地，可以看作是最佳实践。提琴图比起箱线图优势在于呈现更多的分布信息，其次在于更加美观，但是就目前来说箱线图的受众比提琴图要多很多，毕竟前者是包含更多统计信息，如图8.11 所示。 boxplot(count ~ spray, data = InsectSprays) vioplot::vioplot(count ~ spray, data = InsectSprays, col = &quot;lightgray&quot;) ggplot(InsectSprays, aes(x = spray, y = count)) + geom_violin(fill = &quot;lightgray&quot;) + theme_minimal() beanplot::beanplot(count ~ spray, data = InsectSprays, col = &quot;lightgray&quot;) 图 8.11: 几种不同的提琴图 ggnormalviolin 包在给定均值和标准差的情况下，绘制正态分布的概率密度曲线，如图 8.12 所示。 library(ggnormalviolin) with( aggregate( data = iris, Sepal.Length ~ Species, FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x)) ), cbind.data.frame(Sepal.Length, Species) ) %&gt;% ggplot(aes(x = Species, mu = dist_mean, sigma = dist_sd, fill = Species)) + geom_normalviolin() + theme_minimal() 图 8.12: 正态分布的概率密度曲线 参考文献 "],["sec-ggplot2-beeswarm.html", "8.8 蜂群图", " 8.8 蜂群图 在样本点有限的情况下，用蜜蜂图代替普通的抖动图，可视化效果会好很多，如图 8.13 所示。Erik Clarke 开发的 ggbeeswarm 包可以将随机抖动的散点图朝着比较规律的方向聚合，又不丢失数据本身的准确性。 library(ggbeeswarm) p1 &lt;- ggplot(iris, aes(Species, Sepal.Length)) + geom_jitter() + theme_minimal() p2 &lt;- ggplot(iris, aes(Species, Sepal.Length)) + geom_quasirandom() + theme_minimal() p1 + p2 图 8.13: 蜜蜂图可视化效果比抖动图好 "],["sec-ggplot2-tile.html", "8.9 瓦片图", " 8.9 瓦片图 p1 &lt;- expand.grid(months = month.abb, years = 1949:1960) %&gt;% transform(num = as.vector(AirPassengers)) %&gt;% ggplot(aes(x = years, y = months, fill = num)) + scale_fill_continuous(type = &quot;viridis&quot;) + geom_tile(color = &quot;white&quot;, size = 0.4) + scale_x_continuous( expand = c(0.01, 0.01), breaks = seq(1949, 1960, by = 1), labels = 1949:1960 ) + theme_minimal(base_size = 10.54, base_family = &quot;source-han-serif-cn&quot;) + theme(legend.position = &quot;top&quot;) + labs(x = &quot;年&quot;, y = &quot;月&quot;, fill = &quot;人数&quot;) p2 &lt;- expand.grid(months = month.abb, years = 1949:1960) %&gt;% transform(num = as.vector(AirPassengers)) %&gt;% ggplot(aes(x = years, y = months, color = num)) + geom_point(pch = 15, size = 8) + scale_color_distiller(palette = &quot;Spectral&quot;) + scale_x_continuous( expand = c(0.01, 0.01), breaks = seq(1949, 1960, by = 1), labels = 1949:1960 ) + theme_minimal(base_size = 10.54, base_family = &quot;source-han-sans-cn&quot;) + theme(legend.position = &quot;top&quot;) + labs(x = &quot;年&quot;, y = &quot;月&quot;, color = &quot;人数&quot;) p1 + p2 图 8.14: 1949-1960年国际航线乘客数量的月度趋势 "],["sec-ggplot2-calendar.html", "8.10 日历图", " 8.10 日历图 airquality 数据集记录了1973年5月至9月纽约的空气质量，包括气温（华氏度）、风速（米/小时）、紫外线强度、臭氧含量四个指标，图 8.15 展示了每日的气温变化。 airquality %&gt;% transform(Date = seq.Date( from = as.Date(&quot;1973-05-01&quot;), to = as.Date(&quot;1973-09-30&quot;), by = &quot;day&quot; )) %&gt;% transform( Week = as.integer(format(Date, &quot;%W&quot;)), Year = as.integer(format(Date, &quot;%Y&quot;)), Weekdays = factor(weekdays(Date, abbreviate = T), levels = c(&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;) ) ) %&gt;% ggplot(aes(x = Week, y = Weekdays, fill = Temp)) + scale_fill_distiller(name = &quot;Temp (F)&quot;, palette = &quot;Spectral&quot;) + geom_tile(color = &quot;white&quot;, size = 0.4) + facet_wrap(&quot;Year&quot;, ncol = 1) + scale_x_continuous( expand = c(0, 0), breaks = seq(1, 52, length = 12), labels = month.abb ) 图 8.15: 1973年5月至9月纽约的气温变化 图 8.15 横轴的刻度标签换成了月份，一个月为四周，一年 52～53 周，每周的第一天约定为星期一，1973年05月01日为星期二。代码中颇为技巧的在于 format() 函数从 Date 日期类型的数据提取第几周， 用 weekdays() 函数提取星期几，而 month.abb 则是一个内置常量，12个月份的英文缩写。在调用其它 R 包处理日期数据时要特别小心，要留意一周的的第一天是星期几，有的是星期一，有的是星期日，这往往和宗教信仰相关，星期日在西方也叫礼拜天。 上面 Base R 提供的日期函数认为一周的第一天是星期一，而调用 data.table 的话，默认一周是从星期日（礼拜天）开始的。 # https://d.cosx.org/d/421230 weekdays(Sys.Date(), abbreviate = TRUE) ## [1] &quot;Sun&quot; data.table::wday(Sys.Date()) ## [1] 1 "],["sec-ggplot2-ridgeline.html", "8.11 岭线图", " 8.11 岭线图 ggridges 包，于淼 对此图形的来龙去脉做了比较系统的阐述，详见统计之都主站文章叠嶂图的前世今生 library(ggridges) ggplot(lincoln_weather, aes(x = `Mean Temperature [F]`, y = Month, fill = stat(x))) + geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01, gradient_lwd = 1.) + scale_x_continuous(expand = c(0, 0)) + scale_y_discrete(expand = expansion(mult = c(0.01, 0.25))) + scale_fill_viridis_c(name = &quot;Temp. [F]&quot;, option = &quot;C&quot;) + labs( title = &#39;Temperatures in Lincoln NE&#39;, subtitle = &#39;Mean temperatures (Fahrenheit) by month for 2016&#39; ) + theme_ridges(font_size = 13, grid = TRUE) + theme(axis.title.y = element_blank()) 图 8.16: 2016年在内布拉斯加州林肯市的天气变化 通过数据可视化的手段帮助肉眼检查两组数据的分布 p1 &lt;- ggplot(sleep, aes(x = extra, y = group, fill = group)) + geom_density_ridges() + theme_ridges() p2 &lt;- ggplot(diamonds, aes(x = price, y = color, fill = color)) + geom_density_ridges() + theme_ridges() p1 / p2 图 8.17: 比较数据的分布 ridgeline 提供 Base R 绘图方案 "],["sec-ggplot2-ellipse.html", "8.12 椭圆图", " 8.12 椭圆图 type 指定多元分布的类型，type = \"t\" 和 type = \"norm\" 分别表示 t 分布和正态分布，geom = \"polygon\"，以 eruptions &gt; 3 分为两组 ggplot(faithful, aes(x = waiting, y = eruptions)) + geom_point() + stat_ellipse() ggplot(faithful, aes(waiting, eruptions, color = eruptions &gt; 3)) + geom_point() + stat_ellipse(type = &quot;norm&quot;, linetype = 2) + stat_ellipse(type = &quot;t&quot;) + theme(legend.position = &quot;none&quot;) ggplot(faithful, aes(waiting, eruptions, fill = eruptions &gt; 3)) + stat_ellipse(geom = &quot;polygon&quot;) + theme(legend.position = &quot;none&quot;) 图 8.18: 几种不同的椭圆图 "],["sec-ggplot2-chull.html", "8.13 包络图", " 8.13 包络图 ggpubr 包提供了 stat_chull() 图层 library(ggpubr) ggscatter(mpg, x = &quot;displ&quot;, y = &quot;hwy&quot;, color = &quot;drv&quot;)+ stat_chull(aes(color = drv, fill = drv), alpha = 0.1, geom = &quot;polygon&quot;) 图 8.19: 包络图 其背后的原理如下 stat_chull ## function (mapping = NULL, data = NULL, geom = &quot;path&quot;, position = &quot;identity&quot;, ## na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...) ## { ## layer(stat = StatChull, data = data, mapping = mapping, geom = geom, ## position = position, show.legend = show.legend, inherit.aes = inherit.aes, ## params = list(na.rm = na.rm, ...)) ## } ## &lt;bytecode: 0x562ac314fba0&gt; ## &lt;environment: namespace:ggpubr&gt; StatChull &lt;- ggproto(&quot;StatChull&quot;, Stat, compute_group = function(data, scales) { data[chull(data$x, data$y), , drop = FALSE] }, required_aes = c(&quot;x&quot;, &quot;y&quot;) ) stat_chull &lt;- function(mapping = NULL, data = NULL, geom = &quot;polygon&quot;, position = &quot;identity&quot;, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...) { layer( stat = StatChull, data = data, mapping = mapping, geom = geom, position = position, show.legend = show.legend, inherit.aes = inherit.aes, params = list(na.rm = na.rm, ...) ) } ggplot(mpg, aes(displ, hwy)) + geom_point() + stat_chull(fill = NA, colour = &quot;black&quot;) ggplot(mpg, aes(displ, hwy, colour = drv)) + geom_point() + stat_chull(fill = NA) "],["sec-ggplot2-fit.html", "8.14 拟合图", " 8.14 拟合图 xx &lt;- -9:9 yy &lt;- sqrt(abs(xx)) plot(xx, yy, col = &quot;red&quot;, xlab = expression(x), ylab = expression(sqrt(abs(x))) ) lines(spline(xx, yy, n = 101, method = &quot;fmm&quot;, ties = mean), col = &quot;pink&quot;) myspline &lt;- function(formula, data, ...) { dat &lt;- model.frame(formula, data) res &lt;- splinefun(dat[[2]], dat[[1]]) class(res) &lt;- &quot;myspline&quot; res } predict.myspline &lt;- function(object, newdata, ...) { object(newdata[[1]]) } data.frame(x = -9:9) %&gt;% transform(y = sqrt(abs(x))) %&gt;% ggplot(aes(x = x, y = y)) + geom_point(color = &quot;red&quot;, pch = 1, size = 2) + stat_smooth(method = myspline, formula = y~x, se = F, color = &quot;pink&quot;) + labs(x = expression(x), y = expression(sqrt(abs(x)))) + theme_minimal() 图 8.20: 自定义样条函数 下面以真实数据集 trees 为例，介绍 geom_smooth() 支持的拟合方法，比如 \"lm\" 线性回归和 \"nls\" 非线性回归 ggplot(trees, aes(x = log(Girth), y = log(Volume))) + geom_point() + geom_smooth(method = &quot;lm&quot;, formula = y ~ x, se = FALSE) ggplot(trees, aes(x = Girth, y = Volume)) + geom_point() + geom_smooth( method = &quot;nls&quot;, formula = y ~ a * x^2 + b, se = F, method.args = list(start = list(a = 5, b = -36)) ) 图 8.21: 平滑方法 "],["sec-ggplot2-raster.html", "8.15 地形图", " 8.15 地形图 区域之间以轮廓分割，轮廓之间以相同的颜色填充，Cleveland 把这个叫做 level plot， lattice 包中 levelplot() 函数正来源于此。 Auckland’s Maunga Whau Volcano 是火山喷发后留下的碴堆，位于新西兰奥克兰伊甸山郊区。Ross Ihaka 收集了它的地形数据，命名为 volcano，打包在 R 软件环境中，见图 8.22 filled.contour(volcano, color.palette = terrain.colors, plot.title = title( main = &quot;The Topography of Maunga Whau&quot;, xlab = &quot;Meters North&quot;, ylab = &quot;Meters West&quot; ), plot.axes = { axis(1, seq(100, 800, by = 100)) axis(2, seq(100, 600, by = 100)) }, key.title = title(main = &quot;Height\\n(meters)&quot;), key.axes = axis(4, seq(90, 190, by = 10)) ) 图 8.22: image 图形 美国西南部犹他州锡安国家公园的高程珊格数据 elevation，该数据集由 Jakub Nowosad 收集于 spDataLarge 包内，由于该 R 包收集的地理信息数据很多又很大，超出了 CRAN 对 R 包的大小限制，需要从作者制作的 drat 站点下载。 install.packages(&quot;spDataLarge&quot;, repos = &quot;https://nowosad.github.io/drat/&quot;) elevation 数据集通过雷达地形测绘 SRTM (Shuttle Radar Topography Mission) 获得，其分辨率为 90m \\(\\times\\) 90m，属于高精度地形网格数据，更多细节描述见 http://srtm.csi.cgiar.org/，图 8.23 将公园的地形清晰地展示出来了，读者不妨再借助维基百科词条 (https://en.wikipedia.org/wiki/Zion_National_Park) 从整体上了解该公园的情况，结合丰富的实景图可以获得更加直观的感受。 data(&quot;elevation&quot;, package = &quot;spDataLarge&quot;) raster::plot(elevation, asp = NA) 图 8.23: 锡安国家公园的高程珊格数据 "],["sec-ggplot2-treemap.html", "8.16 树状图", " 8.16 树状图 数据集 GNI2014 来自 treemap 包，是一个 data.frame 类型的数据对象，记录了 2014 年每个国家的人口总数 population 和国民人均收入 GNI，数据样例见下方： library(treemap) data(GNI2014, package = &quot;treemap&quot;) subset(GNI2014, subset = grepl(x = country, pattern = &#39;China&#39;)) ## iso3 country continent population GNI ## 7 MAC Macao SAR, China Asia 559846 76270 ## 33 HKG Hong Kong SAR, China Asia 7061200 40320 ## 87 CHN China Asia 1338612970 7400 数据呈现明显的层级结构，从大洲到国家记录人口数量和人均收入，矩阵树图以方块大小表示人口数量，以颜色深浅表示人均收入，见图8.24 treemap(GNI2014, index = c(&quot;continent&quot;, &quot;iso3&quot;), vSize = &quot;population&quot;, vColor = &quot;GNI&quot;, type = &quot;value&quot;, format.legend = list(scientific = FALSE, big.mark = &quot; &quot;) ) 图 8.24: 矩阵树图 数据集 GNI2014 的另一种呈现方式是将数据铺到地图上，可以借助 highcharter 包的 hcmap() 函数来实现，如图8.25所示。 # 代码块不要启用缓存 data(GNI2014, package = &quot;treemap&quot;) library(highcharter) hcmap( &quot;custom/world-robinson-lowres&quot;, data = GNI2014, name = &quot;Gross national income per capita&quot;, value = &quot;GNI&quot;, borderWidth = 0, nullColor = &quot;gray&quot;, joinBy = c(&quot;iso-a3&quot;, &quot;iso3&quot;) ) %&gt;% hc_colorAxis( stops = color_stops( colors = terrain.colors(n = 10) ), type = &quot;logarithmic&quot; ) 图 8.25: 国民人均收入 treemapify 包基于 ggplot2 制作树状图，类似地，该 R 包内置了数据集 G20，记录了世界主要经济体 G20 (https://en.wikipedia.org/wiki/G20) 的经济和人口信息，国家 GDP （单位：百万美元）gdp_mil_usd 和人类发展指数 hdi。相比于 GNI2014，它还包含了两列标签信息：经济发展阶段和所处的半球。图@(fig:treemap-ggplot2)以南北半球 hemisphere 分面，以色彩填充区域 region，以 gdp_mil_usd 表示区域大小 library(treemapify) ggplot(G20, aes( area = gdp_mil_usd, fill = region, label = country, subgroup = region )) + geom_treemap() + geom_treemap_text(grow = T, reflow = T, colour = &quot;black&quot;) + facet_wrap(~hemisphere) + scale_fill_brewer(palette = &quot;Set1&quot;) + theme(legend.position = &quot;bottom&quot;) + labs( title = &quot;The G-20 major economies by hemisphere&quot;, caption = &quot;The area of each tile represents the country&#39;s GDP as a proportion of all countries in that hemisphere&quot;, fill = &quot;Region&quot; ) 图 8.26: 世界主要经济体G20的人口和经济信息 "],["sec-ggplot2-cohort.html", "8.17 留存图", " 8.17 留存图 cohort &lt;- data.frame( cohort = rep(1:5, times = 5:1), week = c(1:5, 1:4, 1:3, 1:2, 1), value = c( 75, 73, 54, 23, 3, 98, 94, 70, 25, 52, 5, 3, 44, 15, 88 ) ) ggplot(cohort, aes(x = week, y = cohort, fill = value)) + geom_tile(color = &quot;white&quot;) + geom_text(aes(label = value), color = &quot;white&quot;) + scale_y_reverse() + scale_fill_binned(type = &quot;viridis&quot;) "],["sec-ggplot2-waterfall.html", "8.18 瀑布图", " 8.18 瀑布图 瀑布图 waterfall 与上月相比，谁增谁减，用瀑布图分别表示占比和绝对数值。瀑布图 waterfall balance &lt;- data.frame( event = c( &quot;Starting\\nCash&quot;, &quot;Sales&quot;, &quot;Refunds&quot;, &quot;Payouts&quot;, &quot;Court\\nLosses&quot;, &quot;Court\\nWins&quot;, &quot;Contracts&quot;, &quot;End\\nCash&quot; ), change = c(2000, 3400, -1100, -100, -6600, 3800, 1400, -2800) ) balance$balance &lt;- cumsum(c(0, balance$change[-nrow(balance)])) # 累计值 balance$time &lt;- 1:nrow(balance) balance$flow &lt;- factor(sign(balance$change)) # 变化为正还是为负 ggplot(balance) + geom_hline(yintercept = 0, colour = &quot;white&quot;, size = 2) + geom_rect(aes( xmin = time - 0.45, xmax = time + 0.45, ymin = balance, ymax = balance + change, fill = flow )) + geom_text(aes( x = time, y = pmin(balance, balance + change) - 50, label = scales::dollar(change) ), hjust = 0.5, vjust = 1, size = 3 ) + scale_x_continuous( name = &quot;&quot;, breaks = balance$time, labels = balance$event ) + scale_y_continuous( name = &quot;Balance&quot;, labels = scales::dollar ) + scale_fill_brewer(palette = &quot;Spectral&quot;) + theme_minimal() 图 8.27: 瀑布图 "],["sec-ggplot2-sankey.html", "8.19 桑基图", " 8.19 桑基图 ggalluvial titanic_wide &lt;- data.frame(Titanic) head(titanic_wide) ## Class Sex Age Survived Freq ## 1 1st Male Child No 0 ## 2 2nd Male Child No 0 ## 3 3rd Male Child No 35 ## 4 Crew Male Child No 0 ## 5 1st Female Child No 0 ## 6 2nd Female Child No 0 library(ggalluvial) ggplot(data = titanic_wide, aes(axis1 = Class, axis2 = Sex, axis3 = Age, y = Freq)) + scale_x_discrete(limits = c(&quot;Class&quot;, &quot;Sex&quot;, &quot;Age&quot;), expand = c(.2, .05)) + xlab(&quot;Demographic&quot;) + geom_alluvium(aes(fill = Survived)) + geom_stratum() + geom_text(stat = &quot;stratum&quot;, aes(label = after_stat(stratum))) + theme_minimal() + ggtitle(&quot;passengers on the maiden voyage of the Titanic&quot;, &quot;stratified by demographics and survival&quot;) 图 8.28: 桑基图 "],["sec-ggplot2-ggmosaic.html", "8.20 马赛克图", " 8.20 马赛克图 library(ggmosaic) ggplot(data = as.data.frame(UCBAdmissions)) + geom_mosaic(aes(weight = Freq, x = product(Gender, Admit), fill = Dept)) + coord_flip() + theme_minimal() + labs(x = &quot;Admit&quot;, y = &quot;Gender&quot;) 图 8.29: UCBAdmissions 马赛克图 "],["sec-ggplot2-bump.html", "8.21 凹凸图", " 8.21 凹凸图 ggbump 排序随位置的变化 # remotes::install_github(&quot;davidsjoberg/ggbump&quot;) library(ggbump) # 代码修改自 https://github.com/davidsjoberg/ggbump df &lt;- data.frame( season = c( &quot;Spring&quot;, &quot;Pre-season&quot;, &quot;Summer&quot;, &quot;Season finale&quot;, &quot;Autumn&quot;, &quot;Winter&quot;, &quot;Spring&quot;, &quot;Pre-season&quot;, &quot;Summer&quot;, &quot;Season finale&quot;, &quot;Autumn&quot;, &quot;Winter&quot;, &quot;Spring&quot;, &quot;Pre-season&quot;, &quot;Summer&quot;, &quot;Season finale&quot;, &quot;Autumn&quot;, &quot;Winter&quot;, &quot;Spring&quot;, &quot;Pre-season&quot;, &quot;Summer&quot;, &quot;Season finale&quot;, &quot;Autumn&quot;, &quot;Winter&quot; ), rank = c( 1, 3, 4, 2, 1, 4, 2, 4, 1, 3, 2, 3, 4, 1, 2, 4, 4, 1, 3, 2, 3, 1, 3, 2 ), player = c( rep(&quot;David&quot;, 6), rep(&quot;Anna&quot;, 6), rep(&quot;Franz&quot;, 6), rep(&quot;Ika&quot;, 6) ) ) # Create factors and order factor df &lt;- transform(df, season = factor(season, levels = unique(season))) # Add manual axis labels to plot ggplot(df, aes(season, rank, color = player)) + geom_bump(size = 2, smooth = 20, show.legend = F) + geom_point(size = 5, aes(shape = player)) + theme_minimal(base_size = 10, base_line_size = 0) + theme(panel.grid.major = element_blank(), axis.ticks = element_blank()) + scale_color_manual(values = RColorBrewer::brewer.pal(name = &quot;Set2&quot;, n = 4)) 图 8.30: 凹凸图 "],["sec-ggplot2-streamgraph.html", "8.22 水流图", " 8.22 水流图 常用于时间序列数据展示的堆积区域图，ggstream 和 streamgraph library(ggstream) ggplot(blockbusters, aes(year, box_office, fill = genre)) + geom_stream() + theme_minimal() 图 8.31: 堆积区域图 "],["sec-ggplot2-vistime.html", "8.23 时间线", " 8.23 时间线 # 交互动态图 https://github.com/shosaco/vistime # 刘思喆 2018 数据科学的时间轴 https://bjt.name/2018/11/18/timeline.html x &lt;- read.table( textConnection(&quot; The Future of Data Analysis,1962 Relational Database,1970 Data science(Peter Naur),1974 Two-Way Communication,1975 Exploratory Data Analysis,1977 Business Intelligence,1989 The First Database Report,1992 The World Wide Web Explodes,1995 Data Mining and Knowledge Discovery,1997 S(ACM Software System Award),1998 Statistical Modeling: The Two Cultures,2001 Hadoop,2006 Data scientist,2008 NOSQL,2009 Deep Learning,2015 &quot;), sep = &quot;,&quot; ) names(x) &lt;- c(&quot;Event&quot;, &quot;EventDate&quot;) x$EventDate &lt;- as.Date(paste(x$EventDate, &quot;/01/01&quot;, sep = &quot;&quot;)) library(timelineS) timelineS(x, labels = paste(x[[1]], format(x[[2]], &quot;%Y&quot;)), line.color = &quot;blue&quot;, label.angle = 15 ) 图 8.32: 数据科学的时间轴 library(timeline) data(ww2, package = &#39;timeline&#39;) timeline(ww2, ww2.events, event.spots=2, event.label=&#39;&#39;, event.above=FALSE) # 适合放在动态幻灯片 # 美团风格的写轮眼 # 时间线 library(vistime) # presidents and vice presidents pres &lt;- data.frame( Position = rep(c(&quot;President&quot;, &quot;Vice&quot;), each = 3), Name = c(&quot;Washington&quot;, rep(c(&quot;Adams&quot;, &quot;Jefferson&quot;), 2), &quot;Burr&quot;), start = c(&quot;1789-03-29&quot;, &quot;1797-02-03&quot;, &quot;1801-02-03&quot;), end = c(&quot;1797-02-03&quot;, &quot;1801-02-03&quot;, &quot;1809-02-03&quot;), color = c(&quot;#cbb69d&quot;, &quot;#603913&quot;, &quot;#c69c6e&quot;) ) hc_vistime(pres, col.event = &quot;Position&quot;, col.group = &quot;Name&quot;, title = &quot;Presidents of the USA&quot;) "],["sec-ggplot2-ternary.html", "8.24 三元图", " 8.24 三元图 Ternary 使用基础图形库，而 ggtern 使用 ggplot2 绘制 library(ggtern) library(ggalt) data(&quot;Fragments&quot;) ggtern(Fragments, aes( x = Qm, y = Qp, z = Rf + M, fill = GrainSize, shape = GrainSize )) + geom_encircle(alpha = 0.5, size = 1) + geom_point() + labs( title = &quot;Example Plot&quot;, subtitle = &quot;using geom_encircle&quot; ) + theme_bw() + theme_legend_position(&quot;tr&quot;) "],["sec-ggplot2-eisenhower.html", "8.25 四象限图", " 8.25 四象限图 dat &lt;- data.frame( perc = c(54, 18, 5, 15), wall_policy = c(&quot;oppose&quot;, &quot;favor&quot;, &quot;oppose&quot;, &quot;favor&quot;), dreamer_policy = c(&quot;favor&quot;, &quot;favor&quot;, &quot;oppose&quot;, &quot;oppose&quot;), stringsAsFactors = FALSE ) %&gt;% transform( xmin = ifelse(wall_policy == &quot;oppose&quot;, -sqrt(perc), 0), xmax = ifelse(wall_policy == &quot;favor&quot;, sqrt(perc), 0), ymin = ifelse(dreamer_policy == &quot;oppose&quot;, -sqrt(perc), 0), ymax = ifelse(dreamer_policy == &quot;favor&quot;, sqrt(perc), 0) ) ggplot(data = dat) + geom_rect(aes( xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax ), fill = &quot;grey&quot;) + geom_text(aes( x = xmin + 0.5 * sqrt(perc), y = ymin + 0.5 * sqrt(perc), label = perc ), color = &quot;white&quot;, size = 10 ) + coord_equal() + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + theme_minimal() + labs(x = &quot;&quot;, y = &quot;&quot;, title = &quot;&quot;) 图 8.33: 四象限图 "],["sec-ggplot2-venn.html", "8.26 韦恩图", " 8.26 韦恩图 ggVennDiagram "],["sec-ggplot2-tornado.html", "8.27 龙卷风图", " 8.27 龙卷风图 dat &lt;- data.frame( variable = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;), Level = c(&quot;Top-2&quot;, &quot;Top-2&quot;, &quot;Bottom-2&quot;, &quot;Bottom-2&quot;), value = c(.8, .7, -.2, -.3) ) ggplot(dat, aes(x = variable, y = value, fill = Level)) + geom_bar(position = &quot;identity&quot;, stat = &quot;identity&quot;) + scale_y_continuous(labels = abs) + coord_flip() + theme_minimal() 图 8.34: 龙卷风图展示变量重要性 Tornado diagram 主要用于敏感性分析，比较不同变量的重要性程度。条形图 geom_bar() 图层的变体，模型权重可视化的手段，仅限于广义线性模型。 "],["sec-ggplot2-hclust.html", "8.28 聚类图", " 8.28 聚类图 ggdendro 的 dendro_data() 函数支持 tree 、hclust 、dendrogram 和 rpart 结果的整理，进而绘图 library(ggdendro) hc &lt;- hclust(dist(USArrests), &quot;ave&quot;) hcdata &lt;- dendro_data(hc, type = &quot;rectangle&quot;) ggplot() + geom_segment(data = segment(hcdata), aes(x = x, y = y, xend = xend, yend = yend) ) + geom_text(data = label(hcdata), aes(x = x, y = y, label = label, hjust = 0), size = 3 ) + coord_flip() + scale_y_reverse(expand = c(0.2, 0)) + theme_minimal() "],["sec-ggplot2-prcomp.html", "8.29 主成分图", " 8.29 主成分图 借助 autoplotly 包 (Tang 2018) 可将函数 stats::prcomp 生成的结果转化为交互图形 pca &lt;- prcomp(iris[c(1, 2, 3, 4)]) plot(pca) library(autoplotly) p &lt;- autoplotly(pca, data = iris, colour = &quot;Species&quot;, label = TRUE, label.size = 3, frame = TRUE ) p + labs( y = &quot;Second Principal Components&quot;, x = &quot;First Principal Components&quot;, title = &quot;Principal Components Analysis&quot; ) p %&gt;% plotly::layout(annotations = list( text = &quot;Example Text&quot;, font = list( family = &quot;Courier New, monospace&quot;, size = 18, color = &quot;black&quot; ), x = 0, y = 0, showarrow = TRUE )) ggfortify (Tang, Horikoshi, and Li 2016) 包将主成分分析图转化为静态图形 library(ggfortify) autoplot(pca, data = iris, colour = &#39;Species&#39;) 图 8.35: 主成分分析 参考文献 "],["sec-ggplot2-composite.html", "8.30 组合图", " 8.30 组合图 组合的意思是将不同种类的图形绘制在一个区域中，比如密度曲线和地毯图18组合。 GGally、 ggupset、 ggcharts 和 ggpubr 高度定制了一些组合统计图形，以 ggpubr 为例，见图 8.36。 library(ggpubr) ggdensity(sleep, x = &quot;extra&quot;, add = &quot;mean&quot;, rug = TRUE, color = &quot;group&quot;, fill = &quot;group&quot;, palette = c(&quot;#00AFBB&quot;, &quot;#E7B800&quot;) ) 图 8.36: 组合图形 上面介绍的都是已经固化的组合方式，一般地，将多个图形组合到一个图中，可以有很多办法，比如 Claus Wilke 开发的 cowplot ，在他的书里 Fundamentals of Data Visualization 大量使用，后起之秀 patchwork 则提供更加简洁的组合语法，非常受欢迎，更加底层的拼接方法可以去看 一页多图 和 R 内置的 grid 系统。 其实是轴须图 rug plot，只因样子看起来像铺在地上的毛毯，故而称之为地毯图，对应于 R 内置的 rug() 函数或 ggplot2 提供的图层 geom_rug()，更多解释详见 https://en.wikipedia.org/wiki/Rug_plot。↩︎ "],["sec-ggplot2-animation.html", "8.31 动态图", " 8.31 动态图 av 包基于 FFmpeg 将静态图片合成视频，而 gifski 包基于 gifski 将静态图片合成 GIF 动画，animation 包 (Xie 2013) 将 Base R 绘制的图形转化为动画或视频，mapmate 制作地图相关的三维可视化图形，gganimate 包支持将 ggplot2 生成的图形，magick 可以将一系列静态图形合成动态图形，借助 gifski 包转化为动态图片或视频。推荐读者从 gganimate 案例合集 开始制作动态图形。 rgl 可以制作真三维动态图形，支持缩放、拖拽、旋转等操作， rayshader 还支持转化 ggplot2 对象为 3D 图形。 数据集 Indometh 记录了药物在人体中的代谢情况，给 6 个人分别静脉注射了吲哚美辛，每隔一段时间抽血检查药物在血浆中的浓度，收集的数据见表 8.2 reshape(Indometh, v.names = &quot;conc&quot;, idvar = &quot;Subject&quot;, timevar = &quot;time&quot;, direction = &quot;wide&quot;, sep = &quot;&quot;) %&gt;% knitr::kable(., caption = &quot;吲哚美辛在人体中的代谢情况&quot;, row.names = FALSE, col.names = gsub(&quot;(conc)&quot;, &quot;&quot;, names(.)), align = &quot;c&quot; ) 表 8.2: 吲哚美辛在人体中的代谢情况 Subject 0.25 0.5 0.75 1 1.25 2 3 4 5 6 8 1 1.50 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 0.05 2 2.03 1.63 0.71 0.70 0.64 0.36 0.32 0.20 0.25 0.12 0.08 3 2.72 1.49 1.16 0.80 0.80 0.39 0.22 0.12 0.11 0.08 0.08 4 1.85 1.39 1.02 0.89 0.59 0.40 0.16 0.11 0.10 0.07 0.07 5 2.05 1.04 0.81 0.39 0.30 0.23 0.13 0.11 0.08 0.10 0.06 6 2.31 1.44 1.03 0.84 0.64 0.42 0.24 0.17 0.13 0.10 0.09 如图 8.37 所示，药物在人体中浓度变化情况 p &lt;- ggplot( data = Indometh, aes(x = time, y = conc, color = Subject) ) + geom_point() + geom_line() + theme_minimal() + labs( x = &quot;time (hr)&quot;, y = &quot;plasma concentrations of indometacin (mcg/ml)&quot; ) p 图 8.37: 药物在人体中的代谢情况 library(gganimate) p + transition_reveal(time) 书籍目标输出格式是 PDF，则在代码块选项设置里必须指定参数 fig.show='animate' 否则插入的只是图片而不是动画， 目标格式是 HTML 网页， 就不必指定参数，默认会将图片合成 GIF 动态图，嵌入 PDF 里面的动画需要 Acrobat Reader 阅读器才能正确地显示。 动态图形制作的原理，简单来说，就是将一帧帧静态图形以较快的速度播放，人眼形成视觉残留，以为是连续的画面，相比于 animation， gganimate 借助 tweenr 包添加了过渡效果，动态图形显得非常自然。下面以 cup 函数19为例 \\[f(x;\\theta,\\phi) = \\theta x\\log(x)-\\frac{1}{\\phi}\\mathit{e}^{-\\phi^4(x-\\frac{1}{\\mathit{e}})^4}, \\quad \\theta \\in (2,3), \\phi \\in (30,50), x \\in (0,1)\\] 函数图像随着 \\(\\theta\\) 和 \\(\\phi\\) 的变化情况见图 8.38。 library(tweenr) cup_curve &lt;- function(n = 100, theta = 3, phi = 30, cup = &quot;A&quot;) { data.frame(x = seq(0.00001, 1, length.out = n), cup = cup) %&gt;% transform(y = theta * x * log(x, base = 10) - 1 / phi * exp(-(phi * x - phi / exp(1))^4)) } mapply( FUN = cup_curve, theta = c(E = 3, D = 2.8, C = 2.5, B = 2.2, A = 2), phi = c(30, 33, 36, 40, 50), cup = c(&quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;), MoreArgs = list(n = 50), SIMPLIFY = FALSE, USE.NAMES = TRUE ) %&gt;% tween_states( data = ., tweenlength = 2, statelength = 1, ease = rep(&quot;cubic-in-out&quot;, 4), nframes = 100 ) %&gt;% ggplot(data = ., aes(x, y, color = cup, frame = .frame)) + geom_path() + coord_flip() + theme_void() 图 8.38: 添加过渡效果 参考文献 "],["chap-dynamic-documents.html", "第 9 章 R Markdown 动态文档", " 第 9 章 R Markdown 动态文档 图 9.1: R Markdown 极其周边生态 WrapRmd 将 R Markdown 里很长的文本自动断行，但不产生空行。 regexplain 帮助检查正则表达式，rdoc 支持 R 帮助文档的语法高亮。shinyComponents 实现在 R Markdown 中写 shiny 。wordcountaddin 统计 R Markdown 文档中的单词数量。styler 格式化 R Markdown 文档中的代码块。reprex 添加代码执行的软件环境，提供可重复的例子，方便在论坛/Github上发问。carbonate 将源代码截图。downloadthis 在 R Markdown 文档中添加下载按钮。icon 添加各种各样的图标，thematic 定制 R Markdown 主题。 datadrivencv、vitae 制作基于 R Markdown 文档的简历。addinslist 收集了一系列 RStudio 插件，提高写作和编码的效率。posterdown 写宣传海报，redoc 实现 R Markdown 和 Microsoft Word 两种文档格式之间互相转化，rrtools 写可重复性的研究论文和报告，提供一套自动化的软件环境的配置，节省科研人员的时间。butteRfly 快速获取 Github 等社交网络上活动记录，以日历图的形式展现出来。flow 可以非常方便地制作函数内部调用执行的流程图。 minidown 提供轻量级的 CSS 框架打磨的网页模版，rmdformats 和 prettydoc 提供不同主题样式的网页输出，govdown 提供 GOV.UK 风格的网页模版。 uiucthemes 伊利诺伊大学主题的 R Markdown 模版， rmdshower 提供 shower 引擎打造的幻灯片，而 xaringan 是基于 remark.js。xaringanthemer 和 xaringanExtra 包含丰富的 xaringan 的主题。 slidex 可以将 PowerPoint 幻灯片转化为粗燥的 xaringan 幻灯片。 gluedown 用 R 代码写格式化的 Markdown 文本， Reproducible Research Data and Project Management in R https://annakrystalli.me/rrresearchACCE20/ Higher, further, faster with Marvelous R Markdown https://bit.ly/marvelRMD R Markdown for Scientists https://rmd4sci.njtierney.com/ Getting Used to R, RStudio, and R Markdown https://rbasics.netlify.app/ R Markdown 指南手册 https://www.dataquest.io/blog/r-markdown-guide-cheatsheet/ Statistical Inference via Data Science: A ModernDive into R and the tidyverse https://moderndive.com/ 参数化报告 https://github.com/jenniferthompson/ParamRmdExample 和 https://elastic-lovelace-155848.netlify.app/gallery/themes/flatly.html Sharing analyses with R Markdown https://andrewbtran.github.io/NICAR/2018/workflow/docs/02-rmarkdown.html Introduction to the Normal Distribution https://tinystats.github.io/teacups-giraffes-and-statistics/02_bellCurve.html 混合效应模型的 workshop https://github.com/singmann/mixed_model_workshop 基于 thematic 和 bslib 包美化 Rmd 文档 https://www.tillac-data.com/2020-fast-rmd-theming-with-thematic-and-bootstraplib/ 借助 flipbookr 在 xaringan 制作的幻灯片里逐行展示代码执行的效果，特别适合用于 ggplot2 的教学 https://evamaerey.github.io/little_flipbooks_library/flipbookr/skeleton 制作 note/tips 等自定义块 https://desiree.rbind.io/post/2019/making-tip-boxes-with-bookdown-and-rmarkdown/ "],["sec-rmarkdown.html", "9.1 文档元素", " 9.1 文档元素 knitr 将 R Markdown 文件转化为 Markdown 文件， Pandoc 可以将 Markdown 文件转化为 HTML5、Word、PowerPoint 和 PDF 等文档格式。 图 9.2: rmarkdown 支持的输出格式 rmarkdown 自 2014年09月17日在 CRAN 上发布第一个正式版本以来，逐渐形成了一个强大的生态系统，世界各地的开发者贡献各种各样的扩展功能，见图 9.3 图 9.3: rmarkdown 生态系统 图 9.4: R Markdown 概念图 9.1.1 控制选项 Using SQL in RStudio library(DBI) conn &lt;- DBI::dbConnect(RSQLite::SQLite(), dbname = system.file(&quot;db&quot;, &quot;datasets.sqlite&quot;, package = &quot;RSQLite&quot;) ) Base R 内置的数据集都整合进 RSQLite 的样例数据库里了， dbListTables(conn) ## [1] &quot;BOD&quot; &quot;CO2&quot; &quot;ChickWeight&quot; &quot;DNase&quot; ## [5] &quot;Formaldehyde&quot; &quot;Indometh&quot; &quot;InsectSprays&quot; &quot;LifeCycleSavings&quot; ## [9] &quot;Loblolly&quot; &quot;Orange&quot; &quot;OrchardSprays&quot; &quot;PlantGrowth&quot; ## [13] &quot;Puromycin&quot; &quot;Theoph&quot; &quot;ToothGrowth&quot; &quot;USArrests&quot; ## [17] &quot;USJudgeRatings&quot; &quot;airquality&quot; &quot;anscombe&quot; &quot;attenu&quot; ## [21] &quot;attitude&quot; &quot;cars&quot; &quot;chickwts&quot; &quot;esoph&quot; ## [25] &quot;faithful&quot; &quot;freeny&quot; &quot;infert&quot; &quot;iris&quot; ## [29] &quot;longley&quot; &quot;morley&quot; &quot;mtcars&quot; &quot;npk&quot; ## [33] &quot;pressure&quot; &quot;quakes&quot; &quot;randu&quot; &quot;rock&quot; ## [37] &quot;sleep&quot; &quot;stackloss&quot; &quot;swiss&quot; &quot;trees&quot; ## [41] &quot;warpbreaks&quot; &quot;women&quot; 随意选择 5 行数据记录，将结果保存到变量 iris_preview SELECT * FROM iris LIMIT 5; 查看变量 iris_preview 的内容 iris_preview ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa 结束后关闭连接 dbDisconnect(conn = conn) 9.1.2 表格 knitr 的 kable() 函数提供了制作表格的基本功能 https://bookdown.org/yihui/rmarkdown-cookbook/tables.html，flextable 支持更加细粒度的表格定制功能。beautifyR 整理 Markdown 表格非常方便，datapasta 快速复制粘贴 data.frame 和 tibble 类型的数据表格。rpivotTable 不更新了，pivottabler 在更新，内容似乎更好。remedy 提供了更加通用的 Markdown 写作功能，简化创作的技术难度。 9.1.3 流程图 nomnoml 流程图、思维导图 nomnoml::nomnoml(&quot; #stroke: orange #.box: fill=#8f8 dashed visual=note #direction: down [Sweave-test-1.Rnw] -&gt; utils::Sweave() [Sweave-test-1.tex|Sweave-test-1-006.pdf|Sweave-test-1-007.pdf] [Sweave-test-1.Rnw] -&gt; utils::Stangle() [Sweave-test-1.R] [Sweave-test-1.tex] -&gt; tools::texi2pdf() [Sweave-test-1.pdf] [Sweave-test-1.tex] -&gt; tools::texi2dvi() [Sweave-test-1.dvi] &quot;) "],["sec-portable-document.html", "9.2 便携式文档", " 9.2 便携式文档 9.2.1 文档汉化 从 R Markdown 到 beamer 幻灯片，如何迁移 LaTeX 模版 默认的 PDF 文档 PDF 文档案例 详见PDF 文档案例 9.2.2 添加水印 draftwatermark 9.2.3 双栏排版 普通单栏排版改为双栏排版，只需添加文档类选项 \"twocolumn\"，将 YAML 元数据中的 classoption: &quot;UTF8,a4paper,fontset=adobe,zihao=false&quot; 变为 classoption: &quot;UTF8,a4paper,fontset=adobe,zihao=false,twocolumn&quot; 其中，参数 UTF8 设定文档编码类型， a4paper 设置版面为 A4 纸大小，fontset=adobe 指定中文字体为 Adobe 字体，zihao=false 不指定字体大小，使用文档类 ctexart 默认的字号, 9.2.4 参数化报告 参数化文档案例 进一步将文档类型做成参数化，实现在运行时自由选择，只需将如下两行替换掉上述一行 params: classoption: twocolumn classoption: &quot;`r params$classoption`&quot; 如果想要双栏的排版风格，编译时传递 documentclass 参数值，覆盖掉默认的参数值即可 rmarkdown::render( input = &quot;examples/pdf-document.Rmd&quot;, params = list(classoption = c(&quot;twocolumn&quot;)) ) 9.2.5 学术幻灯片 beamer 幻灯片也是一种 PDF 文档 PDF 文档案例 Dirk Eddelbuettel 将几个大学的 beamer 幻灯片转化成 R Markdown 模板，收录在 binb 包里，方便调用。伊利诺伊大学的 James J Balamuta 在 R Markdown 基础上专门为自己学校开发了一套的幻灯片模版，全部打包在 uiucthemes 包里。 komaletter 用 Markdown 写信件 memor memor::pdf_memo() hrbrthemes 提供两个文档模版 hrbrthemes::ipsum_pdf() 和 hrbrthemes::ipsum() 此汉风主题由 林莲枝 开发，LaTeX 宏包已发布在 CTAN 上，使用此幻灯片主题需要将相关的 LaTeX 宏包一块安装。 tlmgr install pgfornament pgfornament-han needspace xpatch 9.2.6 文档模版 字体设置 --- output: pdf_document: extra_dependencies: DejaVuSansMono: - scaled=0.9 DejaVuSerif: - scaled=0.9 DejaVuSans: - scaled=0.9 ---   --- output: pdf_document: extra_dependencies: sourcecodepro: - scale=0.85 sourceserifpro: - rmdefault sourcesanspro: - sfdefault --- 9.2.7 引用文献 Getting started with Zotero, Better BibTeX, and RMarkdown knitcitations 包可以根据文献数字对象标识符（英文 Digital Object Identifier，简称 DOI）生成引用，以文章《A Probabilistic Grammar of Graphics》(Pu and Kay 2020) 为例，其 DOI 为 10.1145/3313831.3376466，总之， DOI 就像是文章的身份证，是一一对应的关系20。 library(knitcitations) citep(x =&#39;10.1145/3313831.3376466&#39;) [1] &quot;(Pu and Kay, 2020)&quot; 在表格的格子中引用参考文献 data.frame( author = c(&quot;Yihui Xie&quot;, &quot;Yihui Xie&quot;, &quot;Hadley Wickham&quot;), citation = c(&quot;[@xie2019]&quot;, &quot;[@xie2015]&quot;, &quot;[@Hadley_2019_tidyverse]&quot;) ) %&gt;% knitr::kable(., format = &quot;pandoc&quot;) author citation Yihui Xie (Xie 2019) Yihui Xie (Xie 2015) Hadley Wickham (Wickham et al. 2019) citr 包提供了快速查找参考文献的 RStudio 插件，不用去原始文献库 *.bib 搜索查找，也会自动生成引用，非常方便，极大地提高了工作效率。 citr 还支持集成 Zotero 文献管理软件，可以直接从 Zotero 中导入参考文献数据库。rbbt 包也提供了类似的功能，只要系统安装 Zotero 软件及其插件 Better Bibtex for Zotero connector。 9.2.8 自定义块 tinytex::tlmgr_install(c(&#39;awesomebox&#39;, &#39;fontawesome5&#39;)) 安装 awesomebox 包，开发仓库在 https://github.com/milouse/latex-awesomebox，这个 LaTeX 宏包的作用是提供几类常用的块，比如提示、注意、警告等 这是注意 这是提示信息 这是警告信息 这是重要信息 参考文献 "],["sec-web-document.html", "9.3 网页文档", " 9.3 网页文档 丘怡轩开发的 prettydoc 包提供了一系列模版，方便快速提高网页逼格。另有 Atsushi Yasumoto 开发的 minidown 包非常轻量，但是常用功能都覆盖了。 谢益辉开发的 xaringan 用于制作网页幻灯片， xaringanthemer 为 xaringan 提供主题定制， xaringanExtra 在 xaringan 之上提供各种功能扩展， xaringanBuilder 为 xaringan 提供多种输出格式。 "],["sec-bookdown.html", "9.4 编写书籍", " 9.4 编写书籍 此外， ElegantTufteBookdown 项目提供了 tufte 风格的书籍模板，本书配套的仓库目录 examples/ 下准备了一系列常用模板。 "],["sec-blogdown.html", "9.5 个人网站", " 9.5 个人网站 "],["sec-office-document.html", "9.6 微软文档", " 9.6 微软文档 docxtools、officer 和 officedown 大大扩展了 rmarkdown 在制作 Word/PPT 方面的功能。 本节探索 Markdown + Pandoc 以 Word 格式作为最终交付的可能性。R Markdown 借助 Pandoc 将 Markdown 转化为 Word 文档，继承自 Pandoc 的扩展性， R Markdown 也支持自定义 Word 模版，那如何自定义呢？首先，我们需要知道 Pandoc 内建的 Word 模版长什么样子，然后我们依样画葫芦，制作适合实际需要的模版。获取 Pandoc 2.10.1 自带的 Word 和 PPT 模版，只需在命令行中执行 # DOCX 模版 pandoc -o custom-reference.docx --print-default-data-file reference.docx # PPTX 模版 pandoc -o custom-reference.pptx --print-default-data-file reference.pptx 这里其实是将 Pandoc 自带的 docx 文档 reference.docx 拷贝一份到 custom-reference.docx，而后将 custom-reference.docx 文档自定义一番，但仅限于借助 MS Word 去自定义样式。 Word 文档的 YAML 元数据定义详情见 https://pandoc.org/MANUAL.html#option--reference-doc，如何深度自定义文档模版见 https://bookdown.org/yihui/rmarkdown/word-document.html ，其它模版见 GitHub 仓库 pandoc-templates。这里提供一个Word 文档案例供读者参考。bookdown 提供的函数 word_document2() 相比于 rmarkdown 提供的 word_document() 支持图表的交叉引用，更多细节详见帮助 ?bookdown::word_document2。 R Markdown 文档支持带编号的 Word 文档格式输出要求 Pandoc 版本 2.10.1 及以上， rmarkdown 版本 2.4 及以上。 "],["sec-send-emails.html", "9.7 发送邮件", " 9.7 发送邮件 emayili 是非常轻量的实现邮件发送的 R 包，其它功能类似的 R 包有 blastula mailR。Rahul Premraj 基于 rJava 开发的 mailR 虽然还未在 CRAN 上正式发布，但是已得到很多人的关注，也被广泛的使用，目前作者已经不维护了，继续使用有一定风险。 RStudio 公司 Richard Iannone 新开发的 blastula 扔掉了 Java 的重依赖，更加轻量化、现代化，支持发送群组邮件21。 curl 包提供的函数 send_mail() 本质上是在利用 curl 软件发送邮件，举个例子，邮件内容如下： From: &quot;黄湘云&quot; &lt;公司邮箱地址&gt; To: &quot;黄湘云&quot; &lt;公司邮箱地址&gt; Subject: 测试邮件 你好： 这是一封测试邮件！ 将邮件内容保存为 mail.txt 文件，然后使用 curl 命令行工具将邮件内容发出去。 curl --url &#39;smtp://公司邮件服务器地址:开放的端口号&#39; \\ --ssl-reqd --mail-from &#39;本人公司邮箱地址&#39; \\ --mail-rcpt &#39;他人公司邮箱地址&#39; \\ --upload-file data/mail.txt \\ --user &#39;本人公司邮箱地址:邮箱登陆密码&#39; 注意 Gmail 出于安全性考虑，不支持这种发送邮件的方式，会将邮件内容阻挡，进而接收不到邮件。 下面以 blastula 包为例怎么支持 Gmail/Outlook/QQ 等邮件发送，过程分两步，第一步配置密钥 # CentOS 8 上安装依赖 sudo dnf install -y libsecret-devel libsodium-devel # 安装 R 包 keyring install.packages(&quot;keyring&quot;) # 配置密钥证书，到底如何在 Linux 服务器上配置还不知道 library(keyring) # creds_envvar( # user = Sys.getenv(&quot;SMTP_USER&quot;), # pass_envvar = Sys.getenv(&quot;SMTP_PASSWORD&quot;), # provider = &quot;outlook&quot;, # use_ssl = TRUE # ) library(blastula) # 运行一次就可以了 create_smtp_creds_key( id = &quot;outlook&quot;, user = &quot;xxx@outlook.com&quot;, # 邮件地址 provider = &quot;outlook&quot; ) 第二步，准备邮件内容，包括邮件主题、发/收件人、抄送人、邮件主体和附件 library(blastula) attachment &lt;- &quot;data/mail.txt&quot; # 如果没有附件，引号内留空即可。 # 这个Rmd文件渲染后就是邮件的正文，交互图形和交互表格不适用 body &lt;- &quot;examples/html-document.Rmd&quot; email &lt;- render_email(body) %&gt;% add_attachment(file = attachment) # 发送邮件 smtp_send( from = c(&quot;张三&quot; = &quot;xxx@outlook.com&quot;), # 发件人 to = c(&quot;李四&quot; = &quot;xxx@foxmail.com&quot;, &quot;王五&quot; = &quot;xxx@gmail.com&quot;), # 收件人 cc = c(&quot;赵六&quot; = &quot;xxx@outlook.com&quot;), # 抄送人 subject = &quot;这是一封测试邮件&quot;, email = email, credentials = creds_key(id = &quot;outlook&quot;) ) https://thecoatlessprofessor.com/programming/r/sending-an-email-from-r-with-blastula-to-groups-of-students/↩︎ "],["sec-drake.html", "9.8 工作流", " 9.8 工作流 drake 一站式可重复性研究工作空间打造者，用户手册 https://books.ropensci.org/drake/ 和学习材料 https://github.com/wlandau/learndrake "],["sec-dynamic-documents-session-info.html", "9.9 运行环境", " 9.9 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] DBI_1.1.1 magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.7 knitr_1.33 bit_4.0.4 R6_2.5.0 ## [5] rlang_0.4.11 fastmap_1.1.0 blob_1.2.1 stringr_1.4.0 ## [9] highr_0.9 tools_4.1.0 nomnoml_0.2.3 xfun_0.24 ## [13] jquerylib_0.1.4 htmltools_0.5.1.1 yaml_2.2.1 bit64_4.0.5 ## [17] digest_0.6.27 lifecycle_1.0.0 bookdown_0.22 vctrs_0.3.8 ## [21] sass_0.4.0 htmlwidgets_1.5.3 cachem_1.0.5 memoise_2.0.0 ## [25] evaluate_0.14 RSQLite_2.2.7 rmarkdown_2.9 stringi_1.7.3 ## [29] compiler_4.1.0 bslib_0.2.5.1 jsonlite_1.7.2 pkgconfig_2.0.3 "],["chap-interactive-web-graphics.html", "第 10 章 交互式网页图形", " 第 10 章 交互式网页图形 plotly 包的函数使用起来还是比较复杂的，特别是需要打磨细节以打造数据产品时，此外，其依赖相当重，仅数据处理就包含两套方法 — dplyr 和 data.table，引起很多函数冲突，可谓「苦其久矣」！因此，准备另起炉灶，开发一个新的 R 包 qplotly，取意 quick plotly，以 qplot_ly() 替代 plot_ly()。类似简化 API 的工作有 simplevis、 autoplotly、 ggfortify 和 plotme。 plotly 团队开发了 plotly.js 库，且维护了 R 接口文档 (https://plotly.com/r/)，Carson Sievert 开发了 plotly 包，配套书 Interactive web-based data visualization with R, plotly, and shiny。 Paul C. Bauer 的书 Applied Data Visualization 介绍 plotly https://bookdown.org/paul/applied-data-visualization/what-is-plotly.html echarts4r 包基于 Apache ECharts (incubating)，ECharts 的 Python 接口 pyecharts 也非常受欢迎，基于 apexcharts.js 的 apexcharter。 ECharts2Shiny 包将 ECharts 嵌入 shiny 框架中。 timevis 创建交互式的时间线的时序可视化，它基于 Vis 的 vis-timeline 模块，支持 shiny 集成。dygraphs 包基于 dygraphs 可视化库，将时序数据可视化，更多情况见 https://dygraphs.com/。leaflet 提供 leaflet 的 R 接口。rAmCharts4 基于 amCharts 4 库， apexcharter 提供 apexcharts.js 的 R 接口。还有 billboarder 等。更完整地，请看 Etienne Bacher 维护的 R 包列表 r-js-adaptation 。 对于想了解 htmlwidgets 框架，JavaScript 响应式编程的读者，推荐 John Coene 新书 JavaScript for R 学习 plotly 和 highcharter 为代表的 基于 JavaScript 的 R 包，共有四重境界：第一重是照着帮助文档的示例，示例有啥我们做啥；第二重是明白帮助文档中 R 函数和 JavaScript 函数的对应关系，能力达到 JS 库的功能边界；第三重是深度自定义一些扩展性的 JS 功能，放飞自我；第四重是重新造轮子，为所欲为。下面的介绍希望能帮助读者到达第二重境界。 plotly 是一个功能非常强大的绘制交互式图形的 R 包，支持图片下载、背景图片22、工具栏23和注释24 等一系列细节的自定义控制。下面结合 JavaScript 库 plotly.js 一起介绍，帮助文档 ?config 没有太详细地介绍，所以我们看看 config() 函数中参数 ... 和 JS 库 plot_config.js 中的功能函数是怎么对应的。图10.1 中图片下载按钮对应 toImageButtonOptions 参数， 看 toImageButtonOptions 源代码，可知 它接受任意数据类型，对应到 R 里面就是列表。 watermark 和 displaylogo 都是传递布尔值（TRUE/FALSE），具体根据 JS 代码中的 valType （参数值类型）决定，其它参数类似。另一个函数 layout 和函数 config() 是类似的，怎么传递参数值是根据 JS 代码来的。 toImageButtonOptions: { valType: &#39;any&#39;, dflt: {}, description: [ &#39;Statically override options for toImage modebar button&#39;, &#39;allowed keys are format, filename, width, height, scale&#39;, &#39;see ../components/modebar/buttons.js&#39; ].join(&#39; &#39;) }, displaylogo: { valType: &#39;boolean&#39;, dflt: true, description: [ &#39;Determines whether or not the plotly logo is displayed&#39;, &#39;on the end of the mode bar.&#39; ].join(&#39; &#39;) }, watermark: { valType: &#39;boolean&#39;, dflt: false, description: &#39;watermark the images with the company\\&#39;s logo&#39; }, library(plotly, warn.conflicts = FALSE) plot_ly(diamonds, x = ~clarity, y = ~price, color = ~clarity, colors = &quot;Set1&quot;, type = &quot;box&quot; ) %&gt;% config( toImageButtonOptions = list( format = &quot;svg&quot;, filename = paste(&quot;plot&quot;, Sys.Date(), sep = &quot;_&quot;), width = 450, height = 300 # 设置下载图片的尺寸 https://github.com/ropensci/plotly/issues/1556#issuecomment-505833092 ), # 还可设置为 PNG 格式，可用 rsvg 的 rsvg_pdf 函数转化为 PDF modeBarButtons = list(list(&quot;toImage&quot;)), # 保留下载按钮 # 完整的列表见 https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js watermark = F, displaylogo = FALSE, # 移除 Plotly 的 logo locale = &quot;zh-CN&quot;, # 汉化 # staticPlot = TRUE, # 静态图形而不是交互图形 # modeBarButtonsToRemove = c( # &quot;zoom2d&quot;, &quot;zoomIn2d&quot;, &quot;zoomOut2d&quot;, &quot;autoScale2d&quot;, &quot;resetScale2d&quot;, &quot;pan2d&quot;, # &quot;hoverClosestCartesian&quot;, &quot;hoverCompareCartesian&quot;, &quot;toggleSpikelines&quot; # ), # 去掉任意一个按钮 # displayModeBar = FALSE, # 去掉整个顶部工具栏 showLink = FALSE ) %&gt;% layout( images = list( source = &quot;https://images.plot.ly/language-icons/api-home/r-logo.png&quot;, xref = &quot;paper&quot;, yref = &quot;paper&quot;, x = 1.0, y = 0.25, sizex = 0.2, sizey = 0.2, opacity = 0.5 ), annotations = list( text = &quot;watermark&quot;, # 文本注释 font = list( size = 40, # 字号 color = &quot;red&quot;, # 颜色 family = &quot;Times New Roman&quot; # 字族 ), opacity = 0.2, # 字体透明度 xref = &quot;paper&quot;, yref = &quot;paper&quot;, x = 0.5, y = 0.5, showarrow = FALSE # 去掉箭头指示 ) ) 图 10.1: 自定义细节 函数 ggplotly() 将 ggplot 对象转化为交互式 plotly 对象 gg &lt;- ggplot(faithful, aes(x = eruptions, y = waiting)) + stat_density_2d(aes(fill = ..level..), geom = &quot;polygon&quot;) + xlim(1, 6) + ylim(40, 100) 静态图形 gg 转化为 plotly 对象 ggplotly(gg) 添加动态点的注释，比如点横纵坐标、坐标文本，整个注释标签的样式（如背景色） ggplotly(gg, dynamicTicks = &quot;y&quot;) %&gt;% style(., hoveron = &quot;points&quot;, hoverinfo = &quot;x+y+text&quot;, hoverlabel = list(bgcolor = &quot;white&quot;)) https://plotly.com/r/logos/↩︎ https://plotly-r.com/control-modebar.html↩︎ https://plotly.com/r/reference/#layout-scene-annotations-items-annotation-font↩︎ "],["sec-plotly-scatter.html", "10.1 散点图", " 10.1 散点图 表 10.1: 散点图类型 类型 名称 scattercarpet 地毯图 scatterternary 三元图 scatter3d 三维散点图 scattergeo 地图散点图 scattermapbox 地图散点图 Mapbox scatter 散点图 scattergl 散点图 GL scatterpolar 极坐标散点图 scatterpolargl 极坐标散点图 GL plotly.js 提供很多图层用于绘制各类图形 https://github.com/plotly/plotly.js/tree/master/src/traces "],["sec-plotly-barplot.html", "10.2 条形图", " 10.2 条形图 日常使用最多的图形无外乎散点图、柱形图（分组、堆积、百分比堆积等） # 简单条形图 library(data.table) diamonds &lt;- as.data.table(diamonds) p11 &lt;- diamonds[, .(cnt = .N), by = .(cut)] %&gt;% plot_ly(x = ~cut, y = ~cnt, type = &quot;bar&quot;) %&gt;% add_text( text = ~ scales::comma(cnt), y = ~cnt, textposition = &quot;top middle&quot;, cliponaxis = FALSE, showlegend = FALSE ) %&gt;% config(displayModeBar = F) # 分组条形图 p12 &lt;- plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;, type = &quot;histogram&quot; ) %&gt;% config(displayModeBar = F) # 堆积条形图 p13 &lt;- plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;, type = &quot;histogram&quot; ) %&gt;% layout(barmode = &quot;stack&quot;) %&gt;% config(displayModeBar = F) # 百分比堆积条形图 p14 &lt;- plot_ly(diamonds, x = ~cut, color = ~clarity, colors = &quot;Accent&quot;, type = &quot;histogram&quot; ) %&gt;% layout(barmode = &quot;stack&quot;, barnorm = &quot;percent&quot;) %&gt;% config(displayModeBar = F) htmltools::tagList(p11, p12, p13, p14) "],["sec-plotly-lineplot.html", "10.3 折线图", " 10.3 折线图 其它常见的图形还要折线图、直方图、箱线图和提琴图 # 折线图 p21 &lt;- plot_ly(Orange, x = ~age, y = ~circumference, color = ~Tree, type = &quot;scatter&quot;, mode = &quot;markers+lines&quot; ) "],["sec-multiple-y-axes.html", "10.4 双轴图", " 10.4 双轴图 双轴图 模拟一组数据 set.seed(2020) dat &lt;- data.frame( dt = seq(from = as.Date(&quot;2020-01-01&quot;), to = as.Date(&quot;2020-01-31&quot;), by = &quot;day&quot;), search_qv = sample(100000:1000000, size = 31, replace = T) ) %&gt;% transform(valid_click_qv = sapply(search_qv, rbinom, n = 1, prob = 0.5)) %&gt;% transform(qv_ctr = valid_click_qv / search_qv) hoverinfo = \"text\" 表示 tooltips 使用指定的 text 映射，而 visible = \"legendonly\" 表示图层默认隐藏不展示，只在图例里显示，有时候很多条线，默认只是展示几条而已。举例如下 plot_ly(data = dat) %&gt;% add_bars( x = ~dt, y = ~search_qv, color = I(&quot;#4285f4&quot;), name = &quot;搜索 QV&quot;, text = ~ paste0( &quot;日期：&quot;, dt, &quot;&lt;br&gt;&quot;, &quot;点击 QV：&quot;, format(valid_click_qv, big.mark = &quot;,&quot;), &quot;&lt;br&gt;&quot;, &quot;搜索 QV：&quot;, format(search_qv, big.mark = &quot;,&quot;), &quot;&lt;br&gt;&quot;, &quot;QV_CTR：&quot;, scales::percent(qv_ctr, accuracy = 0.01), &quot;&lt;br&gt;&quot; ), hoverinfo = &quot;text&quot; ) %&gt;% add_bars( x = ~dt, y = ~valid_click_qv, color = I(&quot;#FBBC05&quot;), name = &quot;点击 QV&quot;, text = ~ paste0( &quot;日期：&quot;, dt, &quot;&lt;br&gt;&quot;, &quot;点击 QV：&quot;, format(valid_click_qv, big.mark = &quot;,&quot;), &quot;&lt;br&gt;&quot;, &quot;搜索 QV：&quot;, format(search_qv, big.mark = &quot;,&quot;), &quot;&lt;br&gt;&quot;, &quot;QV_CTR：&quot;, scales::percent(qv_ctr, accuracy = 0.01), &quot;&lt;br&gt;&quot; ), visible = &quot;legendonly&quot;, hoverinfo = &quot;text&quot; ) %&gt;% add_lines( x = ~dt, y = ~qv_ctr, name = &quot;QV_CTR&quot;, yaxis = &quot;y2&quot;, color = I(&quot;#34A853&quot;), text = ~ paste(&quot;QV_CTR：&quot;, scales::percent(qv_ctr, accuracy = 0.01), &quot;&lt;br&gt;&quot;), hoverinfo = &quot;text&quot;, line = list(shape = &quot;spline&quot;, color = &quot;Set1&quot;, width = 3, dash = &quot;line&quot;) ) %&gt;% layout( title = &quot;&quot;, yaxis2 = list( tickfont = list(color = &quot;black&quot;), overlaying = &quot;y&quot;, side = &quot;right&quot;, title = &quot;QV_CTR（%）&quot;, # ticksuffix = &quot;%&quot;, # 设置坐标轴单位 tickformat = &#39;.1%&#39;, # 设置坐标轴刻度 showgrid = F, automargin = TRUE ), xaxis = list(title = &quot;日期&quot;, showgrid = F, showline = F), yaxis = list(title = &quot; &quot;, showgrid = F, showline = F), margin = list(r = 20, autoexpand = T), legend = list( x = 0, y = 1, orientation = &quot;h&quot;, title = list(text = &quot; &quot;) ) ) %&gt;% config(displayModeBar = F) 图 10.2: 双轴图 "],["sec-plotly-histogram.html", "10.5 直方图", " 10.5 直方图 # 分组直方图 p22 &lt;- plot_ly(iris, x = ~Sepal.Length, color = ~Species, type = &quot;histogram&quot; ) "],["sec-plotly-boxplot.html", "10.6 箱线图", " 10.6 箱线图 # 箱线图 p23 &lt;- plot_ly(diamonds, x = ~clarity, y = ~price, color = ~clarity, type = &quot;box&quot; ) # 箱线图 plot_ly(diamonds, x = ~cut, y = ~price) %&gt;% add_boxplot() 图 10.3: 其它常见图形 # 不同的类别使用不同的颜色上色 plot_ly(diamonds, x = ~clarity, y = ~price, color = ~clarity) %&gt;% add_boxplot() # 使用 colors 参数设置调色板 plot_ly(diamonds, x = ~clarity, y = ~price, color = ~clarity, colors = &quot;Set1&quot; ) %&gt;% add_boxplot() # 或者使用 qplot 式绘图风格 plot_ly(diamonds, x = ~clarity, y = ~price, color = ~clarity, colors = &quot;Set1&quot;, type = &quot;box&quot; ) # 分组箱线图 https://github.com/ropensci/plotly/issues/994 plot_ly(diamonds, x = ~cut, y = ~price, color = ~clarity, type = &quot;box&quot; ) %&gt;% layout(boxmode = &quot;group&quot;) # 修改图例的标题，R 的嵌套 list 对象对应于 JS 的 JSON 数据对象 plot_ly(diamonds, x = ~cut, y = ~price, color = ~clarity, colors = &quot;Set1&quot;, type = &quot;box&quot; ) %&gt;% layout( boxmode = &quot;group&quot;, legend = list( bgcolor = &quot;white&quot;, title = list(text = &quot;clarity&quot;) ) ) # 提琴图 plot_ly(diamonds, x = ~cut, y = ~price) %&gt;% add_trace(type = &quot;violin&quot;) plot_ly(diamonds, x = ~cut, y = ~price, split = ~cut, type = &quot;violin&quot;, box = list(visible = T), meanline = list(visible = T) ) %&gt;% layout( xaxis = list(title = &quot;Cut&quot;), yaxis = list(title = &quot;Price&quot;, zeroline = F) ) "],["sec-plotly-violin.html", "10.7 提琴图", " 10.7 提琴图 # 提琴图 p24 &lt;- plot_ly(sleep, x = ~group, y = ~extra, split = ~group, type = &quot;violin&quot;, box = list(visible = T), meanline = list(visible = T) ) htmltools::tagList(p21, p22, p23, p24) plotly 包含图层 27 种，见表 10.2 表 10.2: 图层 A B C add_annotations add_histogram add_polygons add_area add_histogram2d add_ribbons add_bars add_histogram2dcontour add_scattergeo add_boxplot add_image add_segments add_choropleth add_lines add_sf add_contour add_markers add_surface add_data add_mesh add_table add_fun add_paths add_text add_heatmap add_pie add_trace "],["sec-plotly-bubble.html", "10.8 气泡图", " 10.8 气泡图 简单图形 scatter，分布图几类，其中 scatter、heatmap、scatterpolar 支持 WebGL 绘图引擎 # https://plotly.com/r/bubble-charts/ dat &lt;- diamonds[, .( carat = mean(carat), price = sum(price), cnt = .N ), by = .(cut)] plot_ly( data = dat, x = ~carat, y = ~price, color = ~cut, size = ~cnt, type = &quot;scatter&quot;, mode = &quot;markers&quot;, marker = list( symbol = &quot;circle&quot;, sizemode = &quot;diameter&quot;, line = list(width = 2, color = &quot;#FFFFFF&quot;), opacity = 0.4 ), text = ~ paste( sep = &quot; &quot;, &quot;重量：&quot;, round(carat, 2), &quot;克拉&quot;, &quot;&lt;br&gt;价格:&quot;, round(price / 10^6, 2), &quot;百万&quot; ), hoverinfo = &#39;text&#39; ) %&gt;% add_annotations( x = ~carat, y = ~price, text = ~cnt, showarrow = F, font = list(family = &quot;sans&quot;) ) %&gt;% layout( xaxis = list(hoverformat = &quot;.2f&quot;), yaxis = list(hoverformat = &quot;.0f&quot;) ) %&gt;% config(displayModeBar = F) 图 10.4: 气泡图 "],["sec-plotly-spline.html", "10.9 曲线图", " 10.9 曲线图 plot_ly( x = c(1, 2.2, 3), y = c(5.3, 6, 7), type = &quot;scatter&quot;, mode = &quot;markers+lines&quot;, line = list(shape = &quot;spline&quot;), color = I(&quot;#EA4335&quot;) ) %&gt;% add_annotations( x = 2, y = 6, size = I(100), text = TeX(&quot;x_i \\\\sim N(\\\\mu, \\\\sigma)&quot;) ) %&gt;% layout( xaxis = list(showgrid = F, title = TeX(&quot;\\\\mu&quot;)), yaxis = list(showgrid = F, title = TeX(&quot;\\\\alpha&quot;)) ) %&gt;% config(displayModeBar = FALSE, mathjax = &#39;cdn&#39;) 图 10.5: 平滑曲线图 "],["sec-plotly-tozeroy.html", "10.10 堆积图", " 10.10 堆积图 plot_ly( data = PlantGrowth, y = ~weight, color = ~group, type = &quot;scatter&quot;, line = list(shape = &quot;spline&quot;), mode = &quot;lines&quot;, fill = &quot;tozeroy&quot; ) "],["sec-plotly-heatmap.html", "10.11 热力图", " 10.11 热力图 其他基础图形 # Heatmaps plot_ly(z = volcano, type = &#39;heatmap&#39;) "],["sec-plotly-map.html", "10.12 地图", " 10.12 地图 plot_mapbox() 使用 Mapbox 提供的地图服务，因此，需要注册一个账户，获取 MAPBOX_TOKEN data(&quot;quakes&quot;) plot_mapbox( data = quakes, lon = ~long, lat = ~lat, color = ~mag, size = 2, type = &quot;scattermapbox&quot;, mode = &quot;markers&quot;, marker = list(opacity = 0.5) ) %&gt;% layout( title = &quot;Fiji Earthquake&quot;, mapbox = list( zoom = 3, center = list( lat = ~ median(lat - 5), lon = ~ median(long) ) ) ) %&gt;% config( mapboxAccessToken = Sys.getenv(&quot;MAPBOX_TOKEN&quot;), displayModeBar = FALSE ) 图 10.6: 斐济地震数据 plot_ly( data = quakes, lon = ~long, lat = ~lat, type = &quot;scattergeo&quot;, mode = &quot;markers&quot;, text = ~ paste0( &quot;站点：&quot;, stations, &quot;&lt;br&gt;&quot;, &quot;震级：&quot;, mag ), marker = list( color = ~mag, size = 10, opacity = 0.8, line = list(color = &quot;white&quot;, width = 1) ) ) %&gt;% layout(geo = list( showland = TRUE, landcolor = toRGB(&quot;gray95&quot;), subunitcolor = toRGB(&quot;gray85&quot;), countrycolor = toRGB(&quot;gray85&quot;), countrywidth = 0.5, subunitwidth = 0.5, lonaxis = list( showgrid = TRUE, gridwidth = 0.5, range = c(160, 190), dtick = 5 ), lataxis = list( showgrid = TRUE, gridwidth = 0.5, range = c(-40, -10), dtick = 5 ) )) %&gt;% config( displayModeBar = FALSE ) 图 10.7: 斐济地震带分布 dat = data.frame(state.x77, stats = rownames(state.x77), stats_abbr = state.abb) plot_ly(data = dat, type = &quot;choropleth&quot;, locations = ~stats_abbr, locationmode = &quot;USA-states&quot;, colorscale = &quot;Viridis&quot;, z = ~Income ) %&gt;% layout(geo = list(scope = &quot;usa&quot;)) 图 10.8: 美国各州收入 "],["sec-plotly-fitted.html", "10.13 拟合图", " 10.13 拟合图 plot_ly(economics, type = &quot;scatter&quot;, x = ~date, y = ~uempmed, name = &quot;observed unemployment&quot;, mode = &quot;markers+lines&quot;, marker = list( color = &quot;red&quot; ), line = list( color = &quot;red&quot;, dash = &quot;dashed&quot; ) ) %&gt;% add_trace( x = ~date, y = ~fitted(loess(uempmed ~ as.numeric(date))), name = &quot;fitted unemployment&quot;, mode = &quot;markers+lines&quot;, marker = list( color = &quot;orange&quot; ), line = list( color = &quot;orange&quot; ) ) %&gt;% layout( title = &quot;失业时间&quot;, xaxis = list( title = &quot;日期&quot;, showgrid = F ), yaxis = list( title = &quot;失业时间（周）&quot; ), legend = list( x = 0, y = 1, orientation = &quot;v&quot;, title = list(text = &quot;&quot;) ) ) 图 10.9: 拟合曲线 "],["sec-plotly-rasterly.html", "10.14 轨迹图", " 10.14 轨迹图 rasterly 百万量级的散点图 library(rasterly) plot_ly(quakes, x = ~long, y = ~lat) %&gt;% add_rasterly_heatmap() 图 10.10: 散点图 quakes %&gt;% rasterly(mapping = aes(x = long, y = lat)) %&gt;% rasterly_points() 图 10.10: 散点图 library(plotly) # 读取数据 # uber 轨迹数据来自 https://github.com/plotly/rasterly ridesDf &lt;- readRDS(file = &#39;data/uber.rds&#39;) ridesDf %&gt;% rasterly(mapping = aes(x = Lat, y = Lon)) %&gt;% rasterly_points() 图 10.11: 轨迹数据 "],["sec-plotly-3d.html", "10.15 三维图", " 10.15 三维图 plot_ly(z = ~volcano) %&gt;% add_surface() 图 10.12: 三维图形 plot_ly(x = c(0, 0, 1), y = c(0, 1, 0), z = c(0, 0, 0)) %&gt;% add_mesh() 图 10.12: 三维图形 # https://plot.ly/r/reference/#scatter3d transform(mtcars, am = ifelse(am == 0, &quot;Automatic&quot;, &quot;Manual&quot;)) %&gt;% plot_ly(x = ~wt, y = ~hp, z = ~qsec, color = ~am, colors = c(&quot;#BF382A&quot;, &quot;#0C4B8E&quot;)) %&gt;% add_markers() %&gt;% layout(scene = list( xaxis = list(title = &quot;Weight&quot;), yaxis = list(title = &quot;Gross horsepower&quot;), zaxis = list(title = &quot;1/4 mile time&quot;) )) 图 10.12: 三维图形 "],["sec-plotly-gantt-charts.html", "10.16 甘特图", " 10.16 甘特图 项目管理必备，如图所示，本项目拆分成7个任务，一共使用3种项目资源 # https://plotly.com/r/gantt/ # 项目拆解为一系列任务，每个任务的开始时间，持续时间和资源类型 df &lt;- data.frame( task = paste(&quot;Task&quot;, 1:8), start = as.Date(c( &quot;2016-01-01&quot;, &quot;2016-02-20&quot;, &quot;2016-01-01&quot;, &quot;2016-04-10&quot;, &quot;2016-06-09&quot;, &quot;2016-04-10&quot;, &quot;2016-09-07&quot;, &quot;2016-11-26&quot; )), duration = c(50, 25, 100, 60, 30, 150, 80, 10), resource = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;) ) %&gt;% transform(end = start + duration) %&gt;% transform(y = 1:nrow(.)) plot_ly(data = df) %&gt;% add_segments( x = ~start, xend = ~end, y = ~y, yend = ~y, color = ~resource, mode = &quot;lines&quot;, colors = &quot;Set2&quot;, line = list(width = 20), showlegend = F, hoverinfo = &quot;text&quot;, text = ~ paste( &quot; 任务: &quot;, task, &quot;&lt;br&gt;&quot;, &quot;启动时间: &quot;, start, &quot;&lt;br&gt;&quot;, &quot;周期: &quot;, duration, &quot;天&lt;br&gt;&quot;, &quot;资源: &quot;, resource ) ) %&gt;% layout( xaxis = list( showgrid = F, title = list(text = &quot;&quot;) ), yaxis = list( showgrid = F, title = list(text = &quot;&quot;), tickmode = &quot;array&quot;, tickvals = 1:nrow(df), ticktext = unique(df$task), domain = c(0, 0.9) ), annotations = list( list( xref = &quot;paper&quot;, yref = &quot;paper&quot;, x = 0.80, y = 0.1, text = paste0( &quot;项目周期: &quot;, sum(df$duration), &quot; 天&lt;br&gt;&quot;, &quot;资源类型: &quot;, length(unique(df$resource)), &quot; 个&lt;br&gt;&quot; ), font = list(size = 12), ax = 0, ay = 0, align = &quot;left&quot; ), list( xref = &quot;paper&quot;, yref = &quot;paper&quot;, x = 0.1, y = 1, xanchor = &quot;left&quot;, text = &quot;项目资源管理&quot;, font = list(size = 20), ax = 0, ay = 0, align = &quot;left&quot;, showarrow = FALSE ) ) ) %&gt;% config( displayModeBar = FALSE ) 图 10.13: 甘特图 "],["sec-plotly-pareto-charts.html", "10.17 帕雷托图", " 10.17 帕雷托图 帕雷托图 20/80 法则 # 数据来自 https://github.com/plotly/datasets dat &lt;- data.frame( complaint = c( &quot;Small portions&quot;, &quot;Overpriced&quot;, &quot;Wait time&quot;, &quot;Food is tasteless&quot;, &quot;No atmosphere&quot;, &quot;Not clean&quot;, &quot;Too noisy&quot;, &quot;Food is too salty&quot;, &quot;Unfriendly staff&quot;, &quot;Food not fresh&quot; ), count = c( 621L, 789L, 109L, 65L, 45L, 30L, 27L, 15L, 12L, 9L) ) dat &lt;- dat[order(-dat$count), ] %&gt;% transform(cumulative = round(100 * cumsum(count) / sum(count), digits = 2)) # complaint 按 count 降序排列 dat$complaint &lt;- reorder(x = dat$complaint, X = dat$count, FUN = function(x) 1/(1 + x)) plot_ly(data = dat) %&gt;% add_bars(x = ~complaint, y = ~count, showlegend = F, color = I(&quot;#4285f4&quot;)) %&gt;% add_lines(x = ~complaint, y = ~cumulative, yaxis = &quot;y2&quot;, showlegend = F) %&gt;% layout( yaxis2 = list( tickfont = list(color = &quot;black&quot;), overlaying = &quot;y&quot;, side = &quot;right&quot;, title = &quot;累积百分比（%）&quot;, showgrid = F ), xaxis = list(title = &quot;投诉类型&quot;, showgrid = F, showline = F), yaxis = list(title = &quot;数量&quot;, showgrid = F, showline = F) ) %&gt;% config( displayModeBar = FALSE ) 图 10.14: 帕雷托图 reorder() 对 complaint 按照降序还是升序由 FUN 函数的单调性决定，单调增对应升序，单调减对应降序 "],["sec-plotly-vistime.html", "10.18 时间线", " 10.18 时间线 library(vistime) pres &lt;- data.frame( Position = rep(c(&quot;President&quot;, &quot;Vice&quot;), each = 3), Name = c(&quot;Washington&quot;, rep(c(&quot;Adams&quot;, &quot;Jefferson&quot;), 2), &quot;Burr&quot;), start = c(&quot;1789-03-29&quot;, &quot;1797-02-03&quot;, &quot;1801-02-03&quot;), end = c(&quot;1797-02-03&quot;, &quot;1801-02-03&quot;, &quot;1809-02-03&quot;), color = c(&quot;#cbb69d&quot;, &quot;#603913&quot;, &quot;#c69c6e&quot;), fontcolor = c(&quot;black&quot;, &quot;white&quot;, &quot;black&quot;) ) vistime(pres, col.event = &quot;Position&quot;, col.group = &quot;Name&quot;) %&gt;% config( displayModeBar = FALSE ) 图 10.15: 时间线图 "],["sec-plotly-funnel.html", "10.19 漏斗图", " 10.19 漏斗图 dat &lt;- data.frame( category = c(&quot;访问&quot;, &quot;下载&quot;, &quot;潜客&quot;, &quot;报价&quot;, &quot;下单&quot;), value = c(39, 27.4, 20.6, 11, 2) ) %&gt;% transform(percent = value / cumsum(value)) plot_ly(data = dat) %&gt;% add_trace( type = &quot;funnel&quot;, y = ~category, x = ~value, color = ~category, text = ~ paste0(value, &quot;&lt;br&gt;&quot;, sprintf(&quot;%.2f%%&quot;, 100*percent)) , hoverinfo = &quot;text&quot;, showlegend = FALSE ) %&gt;% layout(yaxis = list( categoryarray = ~category, title = &quot;&quot; )) %&gt;% config( displayModeBar = FALSE ) 图 10.16: 漏斗图 plotly::plot_ly(data = dat) %&gt;% plotly::add_trace( type = &quot;funnel&quot;, y = ~category, x = ~value, marker = list(color = RColorBrewer::brewer.pal(n = 5, name = &quot;Set2&quot;)), textposition = &quot;auto&quot;, textinfo = &quot;value+percent previous&quot;, hoverinfo = &quot;none&quot; ) %&gt;% plotly::layout(yaxis = list(categoryarray = ~category, title = &quot;&quot;)) %&gt;% plotly::config(displayModeBar = FALSE) 图 10.17: 漏斗图 "],["sec-plotly-radar.html", "10.20 雷达图", " 10.20 雷达图 plot_ly( type = &quot;scatterpolar&quot;, mode = &quot;markers&quot;, fill = &quot;toself&quot; ) %&gt;% add_trace( r = c(39, 28, 8, 7, 28, 39), theta = c(&quot;数学&quot;, &quot;物理&quot;, &quot;化学&quot;, &quot;英语&quot;, &quot;生物&quot;, &quot;数学&quot;), name = &quot;学生 A&quot; ) %&gt;% add_trace( r = c(1.5, 10, 39, 31, 15, 1.5), theta = c(&quot;数学&quot;, &quot;物理&quot;, &quot;化学&quot;, &quot;英语&quot;, &quot;生物&quot;, &quot;数学&quot;), name = &quot;学生 B&quot; ) %&gt;% layout( polar = list( radialaxis = list( visible = T, range = c(0, 50) ) ) ) 图 10.18: 雷达图 "],["sec-plotly-waterfall.html", "10.21 瀑布图", " 10.21 瀑布图 盈亏图 library(plotly) library(dplyr) dat &lt;- data.frame( x = c( &quot;销售&quot;, &quot;咨询&quot;, &quot;净收入&quot;, &quot;购买&quot;, &quot;其他费用&quot;, &quot;税前利润&quot; ), y = c(60, 80, 10, -40, -20, 0), measure = c( &quot;relative&quot;, &quot;relative&quot;, &quot;relative&quot;, &quot;relative&quot;, &quot;relative&quot;, &quot;total&quot; ) ) %&gt;% mutate(text = case_when( y &gt; 0 ~ paste0(&quot;+&quot;, y), y == 0 ~ &quot;&quot;, y &lt; 0 ~ as.character(y) )) %&gt;% mutate(x = factor(x, levels = c( &quot;销售&quot;, &quot;咨询&quot;, &quot;净收入&quot;, &quot;购买&quot;, &quot;其他费用&quot;, &quot;税前利润&quot; ))) n_rows &lt;- nrow(dat) dat[nrow(dat), &quot;text&quot;] &lt;- &quot;累计&quot; # measure 取值为 &#39;relative&#39;/&#39;total&#39;/&#39;absolute&#39; plotly::plot_ly(dat, x = ~x, y = ~y, measure = ~measure, type = &quot;waterfall&quot;, text = ~text, textposition = &quot;outside&quot;, name = &quot;收支&quot;, hoverinfo = &quot;final&quot;, connector = list(line = list(color = &quot;gray&quot;)), increasing = list(marker = list(color = &quot;#66C2A5&quot;)), decreasing = list(marker = list(color = &quot;#FC8D62&quot;)), totals = list(marker = list(color = &quot;#8DA0CB&quot;)) ) %&gt;% plotly::layout( title = &quot;2018 年收支状态&quot;, xaxis = list(title = &quot;业务&quot;), yaxis = list(title = &quot;金额&quot;), showlegend = FALSE ) %&gt;% plotly::config(displayModeBar = FALSE) 图 8.27: 瀑布图 "],["sec-plotly-treemap.html", "10.22 treemap 图", " 10.22 treemap 图 plotly 绘制 treemap 和 sunburst 图比较复杂，接口不友好， plotme 正好弥补不足。 "],["sec-plotly-sunburst.html", "10.23 旭日图", " 10.23 旭日图 plotme "],["sec-plotly-color-palette.html", "10.24 调色板", " 10.24 调色板 plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, mode = &quot;markers&quot;, type = &quot;scatter&quot;, color = ~ Sepal.Length &gt; 6, colors = c(&quot;#132B43&quot;, &quot;#56B1F7&quot;) ) plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length&gt;6, mode = &quot;markers&quot;, type = &quot;scatter&quot;) plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length&gt;6, mode = &quot;markers&quot;, type = &quot;scatter&quot;, colors = &quot;Set2&quot;) plot_ly(iris, x = ~Petal.Length, y = ~Petal.Width, color = ~Sepal.Length&gt;6, mode = &quot;markers&quot;, type = &quot;scatter&quot;, colors = &quot;Set1&quot;) 构造 20 个类别 超出 Set1 调色板的范围，会触发警告说 Set1 没有那么多色块，但还是返回足够多的色块，也可以使用 viridis、plasma、magma 或 inferno 调色板 dat &lt;- data.frame( dt = rep(seq( from = as.Date(&quot;2021-01-01&quot;), to = as.Date(&quot;2021-01-31&quot;), by = &quot;day&quot; ), each = 20), bu = rep(LETTERS[1:20], 31), qv = rbinom(n = 20 * 31, size = 10000, prob = runif(20 * 31)) ) # viridis plot_ly(dat, x = ~dt, y = ~qv, color = ~bu, mode = &quot;markers&quot;, type = &quot;scatter&quot;, colors = &quot;viridis&quot; ) 图 10.19: 调色板 "],["sec-highcharter.html", "10.25 面积图", " 10.25 面积图 Joshua Kunst 在他的博客里 https://jkunst.com/ 补充了很多数据可视化案例，另一个关键的参考资料是 highcharts API 文档，文档主要分两部分全局选项 Highcharts.setOptions 和绘图函数 Highcharts.chart。下面以 data_to_boxplot() 为例解析 R 中的数据结构是如何和 highcharts 的 JSON 以及绘图函数对应的。 library(highcharter) highchart() %&gt;% hc_xAxis(type = &quot;category&quot;) %&gt;% hc_add_series_list(x = data_to_boxplot( data = iris, variable = Sepal.Length, group_var = Species, add_outliers = TRUE, name = &quot;iris&quot; )) 图 10.20: 两种从数据到图形的映射方式 除了箱线图 boxplot 还有折线图、条形图、密度图等一系列常用图形，共计 50 余种，详见表10.3，各类图形示例见 https://www.highcharts.com/demo。 表 10.3: 图形种类 A B C D E area columnrange item pyramid3d treemap arearange cylinder line sankey variablepie areaspline dependencywheel lollipop scatter variwide areasplinerange dumbbell networkgraph scatter3d vector bar errorbar organization solidgauge venn bellcurve funnel packedbubble spline waterfall boxplot funnel3d pareto streamgraph windbarb bubble gauge pie sunburst wordcound column heatmap polygon tilemap xrange columnpyramid histogram pyramid timeline NA library(highcharter) library(palmerpenguins) hchart(penguins, &quot;scatter&quot;, hcaes(x = flipper_length_mm, y = bill_length_mm, group = species)) 有的图形种类包含多个变体，如 area 面积图，还有 arearange 、areaspline 和 areasplinerange，而 area 图其实是折线图，只是线与坐标轴围成的区域用颜色填充了。一个基本示例见基础面积图，数据结构如下： Highcharts.chart(&#39;container&#39;, { chart: { type: &#39;area&#39; }, accessibility: { description: &#39;Image description: An area chart compares the nuclear stockpiles of the USA and the USSR/Russia between 1945 and 2017. The number of nuclear weapons is plotted on the Y-axis and the years on the X-axis. The chart is interactive, and the year-on-year stockpile levels can be traced for each country. The US has a stockpile of 6 nuclear weapons at the dawn of the nuclear age in 1945. This number has gradually increased to 369 by 1950 when the USSR enters the arms race with 6 weapons. At this point, the US starts to rapidly build its stockpile culminating in 32,040 warheads by 1966 compared to the USSR’s 7,089. From this peak in 1966, the US stockpile gradually decreases as the USSR’s stockpile expands. By 1978 the USSR has closed the nuclear gap at 25,393. The USSR stockpile continues to grow until it reaches a peak of 45,000 in 1986 compared to the US arsenal of 24,401. From 1986, the nuclear stockpiles of both countries start to fall. By 2000, the numbers have fallen to 10,577 and 21,000 for the US and Russia, respectively. The decreases continue until 2017 at which point the US holds 4,018 weapons compared to Russia’s 4,500.&#39; }, title: { text: &#39;US and USSR nuclear stockpiles&#39; }, subtitle: { text: &#39;Sources: &lt;a href=&quot;https://thebulletin.org/2006/july/global-nuclear-stockpiles-1945-2006&quot;&gt;&#39; + &#39;thebulletin.org&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://www.armscontrol.org/factsheets/Nuclearweaponswhohaswhat&quot;&gt;&#39; + &#39;armscontrol.org&lt;/a&gt;&#39; }, xAxis: { allowDecimals: false, labels: { formatter: function () { return this.value; // clean, unformatted number for year } }, accessibility: { rangeDescription: &#39;Range: 1940 to 2017.&#39; } }, yAxis: { title: { text: &#39;Nuclear weapon states&#39; }, labels: { formatter: function () { return this.value / 1000 + &#39;k&#39;; } } }, tooltip: { pointFormat: &#39;{series.name} had stockpiled &lt;b&gt;{point.y:,.0f}&lt;/b&gt;&lt;br/&gt;warheads in {point.x}&#39; }, plotOptions: { area: { pointStart: 1940, marker: { enabled: false, symbol: &#39;circle&#39;, radius: 2, states: { hover: { enabled: true } } } } }, series: [{ name: &#39;USA&#39;, data: [ null, null, null, null, null, 6, 11, 32, 110, 235, 369, 640, 1005, 1436, 2063, 3057, 4618, 6444, 9822, 15468, 20434, 24126, 27387, 29459, 31056, 31982, 32040, 31233, 29224, 27342, 26662, 26956, 27912, 28999, 28965, 27826, 25579, 25722, 24826, 24605, 24304, 23464, 23708, 24099, 24357, 24237, 24401, 24344, 23586, 22380, 21004, 17287, 14747, 13076, 12555, 12144, 11009, 10950, 10871, 10824, 10577, 10527, 10475, 10421, 10358, 10295, 10104, 9914, 9620, 9326, 5113, 5113, 4954, 4804, 4761, 4717, 4368, 4018 ] }, { name: &#39;USSR/Russia&#39;, data: [null, null, null, null, null, null, null, null, null, null, 5, 25, 50, 120, 150, 200, 426, 660, 869, 1060, 1605, 2471, 3322, 4238, 5221, 6129, 7089, 8339, 9399, 10538, 11643, 13092, 14478, 15915, 17385, 19055, 21205, 23044, 25393, 27935, 30062, 32049, 33952, 35804, 37431, 39197, 45000, 43000, 41000, 39000, 37000, 35000, 33000, 31000, 29000, 27000, 25000, 24000, 23000, 22000, 21000, 20000, 19000, 18000, 18000, 17000, 16000, 15537, 14162, 12787, 12600, 11400, 5500, 4512, 4502, 4502, 4500, 4500 ] }] }); 对应到 R 包 highcharter 中，绘图代码如下： library(highcharter) options(highcharter.theme = hc_theme_hcrt(tooltip = list(valueDecimals = 2))) usa &lt;- ts( data = c( NA, NA, NA, NA, NA, 6, 11, 32, 110, 235, 369, 640, 1005, 1436, 2063, 3057, 4618, 6444, 9822, 15468, 20434, 24126, 27387, 29459, 31056, 31982, 32040, 31233, 29224, 27342, 26662, 26956, 27912, 28999, 28965, 27826, 25579, 25722, 24826, 24605, 24304, 23464, 23708, 24099, 24357, 24237, 24401, 24344, 23586, 22380, 21004, 17287, 14747, 13076, 12555, 12144, 11009, 10950, 10871, 10824, 10577, 10527, 10475, 10421, 10358, 10295, 10104, 9914, 9620, 9326, 5113, 5113, 4954, 4804, 4761, 4717, 4368, 4018 ), start = 1940, end = 2017 ) russia &lt;- ts( data = c( NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, 5, 25, 50, 120, 150, 200, 426, 660, 869, 1060, 1605, 2471, 3322, 4238, 5221, 6129, 7089, 8339, 9399, 10538, 11643, 13092, 14478, 15915, 17385, 19055, 21205, 23044, 25393, 27935, 30062, 32049, 33952, 35804, 37431, 39197, 45000, 43000, 41000, 39000, 37000, 35000, 33000, 31000, 29000, 27000, 25000, 24000, 23000, 22000, 21000, 20000, 19000, 18000, 18000, 17000, 16000, 15537, 14162, 12787, 12600, 11400, 5500, 4512, 4502, 4502, 4500, 4500 ), start = 1940, end = 2017 ) unit_format &lt;- JS(&quot;function(){ return this.value / 10000 + &#39;M&#39;; }&quot;) highchart() %&gt;% hc_xAxis(type = &quot;datetime&quot;) %&gt;% hc_yAxis( title = list(text = &quot;Nuclear weapon states&quot;), labels = list(formatter = unit_format) ) %&gt;% hc_title(text = &quot;US and USSR nuclear stockpiles&quot;) %&gt;% hc_subtitle(text = paste( &#39;Sources: &lt;a href=&quot;https://thebulletin.org/2006/july/global-nuclear-stockpiles-1945-2006&quot;&gt;&#39;, &#39;thebulletin.org&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://www.armscontrol.org/factsheets/Nuclearweaponswhohaswhat&quot;&gt;&#39;, &quot;armscontrol.org&lt;/a&gt;&quot; )) %&gt;% hc_add_series(data = russia, type = &quot;area&quot;, name = &quot;USSR/Russia&quot;) %&gt;% hc_add_series(data = usa, type = &quot;area&quot;, name = &quot;USA&quot;) %&gt;% hc_exporting( enabled = TRUE, filename = paste(Sys.Date(), &quot;nuclear&quot;, sep = &quot;-&quot;) ) 图 10.21: 1940年至2017年美国和俄罗斯核武器数量变化 可以看出来，JS API 文档里 chart -&gt; plotOptions 对应于 R 包 API 的 hc_plotOptions() 函数，hchart() 函数对应于 https://api.highcharts.com/highcharts/series ，为了绘图方便起见，作者还直接支持 R 中一些数据对象，比如数据框 data.frame 和时间序列 ts 等，完整的支持列表见： library(highcharter) methods(hchart) ## [1] hchart.acf* hchart.character* hchart.data.frame* hchart.default* ## [5] hchart.density* hchart.dist* hchart.ets* hchart.factor* ## [9] hchart.forecast* hchart.histogram* hchart.igraph* hchart.list* ## [13] hchart.matrix* hchart.mforecast* hchart.mts* hchart.numeric* ## [17] hchart.prcomp* hchart.princomp* hchart.stl* hchart.survfit* ## [21] hchart.tibble* hchart.ts* hchart.xts* ## see &#39;?methods&#39; for accessing help and source code 更多 API 细节描述见 https://jkunst.com/highcharter/articles/modules.html。 桑基图描述能量的流动25 library(jsonlite) # 转化为 JSON 格式的字符串 dat &lt;- toJSON(data.frame( from = c(&quot;AT&quot;, &quot;DE&quot;, &quot;CH&quot;, &quot;DE&quot;), to = c(&quot;DE&quot;, &quot;CH&quot;, &quot;DE&quot;, &quot;FI&quot;), weight = c(10, 5, 15, 5) )) highchart() %&gt;% hc_chart(type = &quot;sankey&quot;) %&gt;% hc_add_series(data = dat) 图 10.22: 桑基图 此外，highcharter 提供 highchartOutput() 和 renderHighchart() 函数支持在 shiny 中使用 highcharts 图形。 library(shiny) library(highcharter) shinyApp( ui = fluidPage( highchartOutput(&quot;plot_hc&quot;) ), server = function(input, output) { output$plot_hc &lt;- renderHighchart({ hchart(PlantGrowth, &quot;area&quot;, hcaes(y = weight, group = group)) }) } ) 借助 htmlwidgets 和 reactR 创建新的基于 JS 库的 R 包，这样就快速将可视化图形库赋能 R 环境，关于网页可视化，JS 一定是优于 R 的，毕竟人家是专业前端工具，我们做的就是快速套模板，让 R 数据操作和分析的结果以非常精美的方式展现出来。这里有一篇基于 reactR 框架引入 React.js 衍生 JS 库到 R 环境中的资料 https://github.com/react-R/nivocal，一读就懂，非常适合上手。 点击图例隐藏某一类别，可以看到图形纵轴会自适应展示区域的大小，这个特性对于所有图形都是支持的。 library(highcharter) # 折线图 hchart(sleep, &quot;line&quot;, hcaes(ID, extra, group = group)) 图 10.23: 折线图 # 堆积区域图 # 堆积折线图 https://antv-2018.alipay.com/zh-cn/vis/chart/sankey.html↩︎ "],["sec-highcharter-animation.html", "10.26 动画", " 10.26 动画 动态条形图 library(highcharter) # highcharter 的依赖也很重 library(idbr) library(purrr) library(dplyr) # 未来替代一下 # the US Census Bureau International Data Base API # 美国人口普查局国际数据库 API idb_api_key(&quot;35f116582d5a89d11a47c7ffbfc2ba309133f09d&quot;) yrs &lt;- seq(1980, 2030, by = 5) df &lt;- map_dfr(c(&quot;male&quot;, &quot;female&quot;), function(sex) { transform(get_idb(&quot;US&quot;, yrs, sex = sex), sex_label = sex) }) df &lt;- df %&gt;% transform(population = pop * ifelse(sex_label == &quot;male&quot;, -1, 1)) # 数据变换 series &lt;- df %&gt;% group_by(sex_label, age) %&gt;% do(data = list(sequence = .$population)) %&gt;% ungroup() %&gt;% group_by(sex_label) %&gt;% do(data = .$data) %&gt;% mutate(name = sex_label) %&gt;% list_parse() maxpop &lt;- max(abs(df$population)) xaxis &lt;- list( categories = sort(unique(df$age)), reversed = FALSE, tickInterval = 5, labels = list(step = 5) ) highchart() %&gt;% hc_chart(type = &quot;bar&quot;) %&gt;% hc_motion( enabled = TRUE, labels = yrs, series = c(0, 1), autoplay = TRUE, updateInterval = 10, playIcon = &quot;fa fa-play&quot;, pauseIcon = &quot;fa fa-pause&quot; ) %&gt;% hc_add_series_list(series) %&gt;% hc_plotOptions( series = list(stacking = &quot;normal&quot;), bar = list(groupPadding = 0, pointPadding = 0, borderWidth = 0) ) %&gt;% hc_tooltip( shared = FALSE, formatter = JS(&quot; function() { return &#39;&lt;b&gt;&#39; + this.series.name + &#39;, age &#39; + this.point.category + &#39;&lt;/b&gt;&lt;br/&gt;&#39; + &#39;Population: &#39; + Highcharts.numberFormat(Math.abs(this.point.y), 0); } &quot;) ) %&gt;% hc_yAxis( labels = list( formatter = JS(&quot; function() { return Math.abs(this.value) / 1000000 + &#39;M&#39;; } &quot;) ), tickInterval = 0.5e6, min = -maxpop, max = maxpop ) %&gt;% hc_xAxis( xaxis, rlist::list.merge(xaxis, list(opposite = TRUE, linkedTo = 0)) ) 动态气泡图 highchart() %&gt;% hc_xAxis(min = 0, max = 10) %&gt;% hc_yAxis(min = 0, max = 10) %&gt;% hc_motion(enabled = TRUE) %&gt;% hc_add_series( type = &quot;bubble&quot;, data = list( list( sequence = list( list(x = 1, y = 1, z = 10), list(x = 2, y = 3, z = 5), list(x = 3, y = 5, z = 8) ) ) ) ) highchart() %&gt;% hc_xAxis(min = 0, max = 10) %&gt;% hc_yAxis(min = 0, max = 10) %&gt;% hc_add_series( type = &quot;bubble&quot;, name = &quot;气泡图&quot;, data = list( list(x = 1, y = 1, z = 10) ) ) 动态散点图 library(highcharter) highchart() %&gt;% hc_chart(type = &quot;scatter&quot;) %&gt;% hc_yAxis(max = 6, min = 0) %&gt;% hc_xAxis(max = 6, min = 0) %&gt;% hc_add_series( name = &quot;Australia&quot;, data = list( list(sequence = list(c(1, 1), c(2, 2), c(3, 3), c(4, 4))) ) ) %&gt;% hc_add_series( name = &quot;United States&quot;, data = list( list(sequence = list(c(0, 0), c(3, 2), c(4, 3), c(4, 1))) ) ) %&gt;% hc_add_series( name = &quot;China&quot;, data = list( list(sequence = list(c(3, 2), c(2, 2), c(1, 1), c(2, 5))) ) ) %&gt;% hc_motion( enabled = TRUE, labels = 2000:2003, series = c(0, 1, 2) ) 动态柱状图 highchart() %&gt;% hc_chart(type = &quot;column&quot;) %&gt;% hc_yAxis(max = 6, min = 0) %&gt;% hc_add_series(name = &quot;A&quot;, data = c(2, 3, 4), zIndex = -10) %&gt;% hc_add_series( name = &quot;B&quot;, data = list( list(sequence = c(1, 2, 3, 4)), list(sequence = c(3, 2, 1, 3)), list(sequence = c(2, 5, 4, 3)) ) ) %&gt;% hc_add_series( name = &quot;C&quot;, data = list( list(sequence = c(3, 2, 1, 3)), list(sequence = c(2, 5, 4, 3)), list(sequence = c(1, 2, 3, 4)) ) ) %&gt;% hc_motion( enabled = TRUE, labels = 2000:2003, series = c(1, 2), playIcon = &quot;fa fa-play&quot;, pauseIcon = &quot;fa fa-pause&quot; ) "],["sec-dygraphs.html", "10.27 时序图", " 10.27 时序图 dygraphs 专门用来绘制交互式时间序列图形，下面以美团股价为例，展示时间窗口筛选、坐标轴名称、刻度标签、注释、事件标注、缩放等功能 meituan &lt;- quantmod::getSymbols(&quot;3690.HK&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;) library(magrittr) library(dygraphs) # 缩放 dyUnzoom &lt;- function(dygraph) { dyPlugin( dygraph = dygraph, name = &quot;Unzoom&quot;, path = system.file(&quot;plugins/unzoom.js&quot;, package = &quot;dygraphs&quot;) ) } # 年月 getYearMonth &lt;- &#39; function(d) { var monthNames = [&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;,&quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;]; date = new Date(d); return date.getFullYear() + &quot;-&quot; + monthNames[date.getMonth()]; }&#39; dygraph(meituan[, &quot;3690.HK.Adjusted&quot;], main = &quot;美团股价走势&quot;) %&gt;% dyRangeSelector(dateWindow = c(format(Sys.Date(), &quot;%Y-01-01&quot;), as.character(Sys.Date()))) %&gt;% dyAxis(name = &quot;x&quot;, axisLabelFormatter = getYearMonth) %&gt;% dyAxis(&quot;y&quot;, valueRange = c(0, 500), label = &quot;美团股价&quot;) %&gt;% dyEvent(&quot;2020-01-23&quot;, &quot;武汉封城&quot;, labelLoc = &quot;bottom&quot;) %&gt;% dyShading(from = &quot;2020-01-23&quot;, to = &quot;2020-04-08&quot;, color = &quot;#FFE6E6&quot;) %&gt;% dyAnnotation(&quot;2020-01-23&quot;, text = &quot;武汉封城&quot;, tooltip = &quot;武汉封城&quot;, width = 60) %&gt;% dyAnnotation(&quot;2020-04-08&quot;, text = &quot;武汉解封&quot;, tooltip = &quot;武汉解封&quot;, width = 60) %&gt;% dyHighlight(highlightSeriesOpts = list(strokeWidth = 2)) %&gt;% dySeries(label = &quot;调整股价&quot;) %&gt;% dyLegend(show = &quot;follow&quot;, hideOnMouseOut = FALSE) %&gt;% dyOptions(fillGraph = TRUE, drawGrid = FALSE, gridLineColor = &quot;lightblue&quot;) %&gt;% dyUnzoom() "],["sec-export.html", "10.28 图形导出", " 10.28 图形导出 orca (Open-source Report Creator App) 软件针对 plotly.js 库渲染的图形具有很强的导出功能，安装 orca 后，plotly::orca() 函数可以将基于 htmlwidgets 的 plotly 图形对象导出为 PNG、PDF 和 SVG 等格式的高质量静态图片。 p &lt;- plot_ly(x = 1:10, y = 1:10, color = 1:10) orca(p, &quot;plot.svg&quot;) "],["sec-r2d3.html", "10.29 其他 JS 库", " 10.29 其他 JS 库 更加具体的使用介绍，一个复杂的案例，如何从简单配置过来，以条形图为例， D3 是一个相当强大且成熟的库，提供的案例功能要覆盖 plotly r2d3 提供了两个样例 JS 库 baranims.js 和 barchart.js list.files(system.file(&quot;examples/&quot;, package = &quot;r2d3&quot;)) ## [1] &quot;baranims.js&quot; &quot;barchart.js&quot; library(r2d3) r2d3( data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20), script = system.file(&quot;examples/barchart.js&quot;, package = &quot;r2d3&quot;) ) 图 10.24: D3 图形 r2d3( data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20), script = system.file(&quot;examples/baranims.js&quot;, package = &quot;r2d3&quot;) ) 图 10.25: D3 图形 提供一个 R 包和 HTML Widgets 小练习：给 roughViz.js 写个 R 包装 https://d.cosx.org/d/421030-r-html-widgets-roughviz-js-r https://github.com/XiangyunHuang/roughviz "],["sec-session-web.html", "10.30 运行环境", " 10.30 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] r2d3_0.2.5 dygraphs_1.1.1.6 magrittr_2.0.1 ## [4] jsonlite_1.7.2 palmerpenguins_0.1.0 highcharter_0.8.2 ## [7] dplyr_1.0.7 vistime_1.2.1 rasterly_0.2.0 ## [10] Rcpp_1.0.7 data.table_1.14.0 plotly_4.9.4.1 ## [13] ggplot2_3.3.5 ## ## loaded via a namespace (and not attached): ## [1] httr_1.4.2 sass_0.4.0 ## [3] tidyr_1.1.3 viridisLite_0.4.0 ## [5] bslib_0.2.5.1 assertthat_0.2.1 ## [7] TTR_0.24.2 highr_0.9 ## [9] yaml_2.2.1 ggrepel_0.9.1 ## [11] pillar_1.6.1 backports_1.2.1 ## [13] lattice_0.20-44 glue_1.4.2 ## [15] rlist_0.4.6.1 digest_0.6.27 ## [17] assertive.types_0.0-3 RColorBrewer_1.1-2 ## [19] colorspace_2.0-2 htmltools_0.5.1.1 ## [21] pkgconfig_2.0.3 broom_0.7.8 ## [23] assertive.properties_0.0-4 bookdown_0.22 ## [25] purrr_0.3.4 scales_1.1.1 ## [27] tibble_3.1.2 generics_0.1.0 ## [29] farver_2.1.0 ellipsis_0.3.2 ## [31] withr_2.4.2 lazyeval_0.2.2 ## [33] quantmod_0.4.18 crayon_1.4.1 ## [35] evaluate_0.14 fansi_0.5.0 ## [37] MASS_7.3-54 xts_0.12.1 ## [39] tools_4.1.0 lifecycle_1.0.0 ## [41] stringr_1.4.0 munsell_0.5.0 ## [43] isoband_0.2.5 compiler_4.1.0 ## [45] jquerylib_0.1.4 rlang_0.4.11 ## [47] grid_4.1.0 rstudioapi_0.13 ## [49] htmlwidgets_1.5.3 crosstalk_1.1.1 ## [51] assertive.base_0.0-9 igraph_1.2.6 ## [53] labeling_0.4.2 rmarkdown_2.9 ## [55] gtable_0.3.0 codetools_0.2-18 ## [57] DBI_1.1.1 curl_4.3.2 ## [59] R6_2.5.0 zoo_1.8-9 ## [61] lubridate_1.7.10 knitr_1.33 ## [63] utf8_1.2.1 stringi_1.7.3 ## [65] vctrs_0.3.8 png_0.1-7 ## [67] tidyselect_1.1.1 xfun_0.24 "],["chap-dynamic-network-visualization.html", "第 11 章 交互网络图形 ", " 第 11 章 交互网络图形 "],["sec-network-analysis.html", "11.1 网络分析", " 11.1 网络分析 library(igraph) "],["sec-javascript-network.html", "11.2 交互图形", " 11.2 交互图形 11.2.1 networkD3 networkD3 D3 非常适合绘制网络图，如网络、树状、桑基图 library(networkD3) data(MisLinks, MisNodes) # 加载数据 head(MisLinks) # 边 ## source target value ## 1 1 0 1 ## 2 2 0 8 ## 3 3 0 10 ## 4 3 2 6 ## 5 4 0 1 ## 6 5 0 1 head(MisNodes) # 节点 ## name group size ## 1 Myriel 1 15 ## 2 Napoleon 1 20 ## 3 Mlle.Baptistine 1 23 ## 4 Mme.Magloire 1 30 ## 5 CountessdeLo 1 11 ## 6 Geborand 1 9 构造网络图 forceNetwork( Links = MisLinks, Nodes = MisNodes, Source = &quot;source&quot;, Target = &quot;target&quot;, Value = &quot;value&quot;, NodeID = &quot;name&quot;, Group = &quot;group&quot;, opacity = 0.4 ) 11.2.2 visNetwork visNetwork 使用 vis-network.js 库绘制网络关系图 https://datastorm-open.github.io/visNetwork library(visNetwork) 调用函数 visTree() 可视化分类模型结果 library(rpart) library(sparkline) # 函数 visTree 需要导入 sparkline 包 res &lt;- rpart(Species~., data=iris) visTree(res, main = &quot;鸢尾花分类树&quot;, width = &quot;100%&quot;) 节点、边的属性都可以映射数据指标 11.2.3 r2d3 D3 是非常流行的 JavaScript 库，r2d3 提供了 R 接口 library(r2d3) "],["chap-echarts4r.html", "第 12 章 交互式图形 echarts4r", " 第 12 章 交互式图形 echarts4r 相比于 plotly，echarts4r 更加轻量，这得益于 JavaScript 库 Apache ECharts。 前者 MIT 协议，后者采用 Apache-2.0 协议，都可以商用。Apache ECharts 是 Apache 旗下顶级开源项目，由百度前端技术团队贡献，中文文档也比较全，学习起来门槛会低一些。 "],["sec-echarts4r-map.html", "12.1 地图", " 12.1 地图 library(echarts4r) library(magrittr) quakes %&gt;% e_charts(long) %&gt;% e_geo( roam = TRUE, boundingCoords = list( c(185, - 10), c(165, -40) ) ) %&gt;% e_scatter( lat, mag, coord_system = &quot;geo&quot; ) %&gt;% e_visual_map(mag, scale = e_scale) leaflet 包制作地图，斐济是太平洋上的一个岛国，处于板块交界处，经常发生地震，如图 12.1 所示，展示 1964 年来 1000 次震级大于 4 级的地震活动。 library(leaflet) data(quakes) # Pop 提示 quakes$popup_text &lt;- lapply(paste( &quot;编号:&quot;, &quot;&lt;strong&gt;&quot;, quakes$stations, &quot;&lt;/strong&gt;&quot;, &quot;&lt;br&gt;&quot;, &quot;震深:&quot;, quakes$depth, &quot;&lt;br&gt;&quot;, &quot;震级:&quot;, quakes$mag ), htmltools::HTML) # 构造调色板 pal &lt;- colorBin(&quot;Spectral&quot;, bins = pretty(quakes$mag), reverse = TRUE) p &lt;- leaflet(quakes) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addCircles(lng = ~long, lat = ~lat, color = ~ pal(mag), label = ~popup_text) %&gt;% addLegend(&quot;bottomright&quot;, pal = pal, values = ~mag, title = &quot;地震震级&quot; ) %&gt;% addScaleBar(position = c(&quot;bottomleft&quot;)) p 图 12.1: 斐济地震带 将上面的绘图部分保存为独立的 HTML 网页文件 library(htmlwidgets) # p 就是绘图部分的数据对象 saveWidget(p, &quot;fiji-map.html&quot;, selfcontained = T) library(leaflet) library(leaflet.extras) library(magrittr) quakes %&gt;% leaflet() %&gt;% addTiles() %&gt;% addProviderTiles(providers$OpenStreetMap.DE) %&gt;% addHeatmap(lng = ~long, lat = ~lat, intensity = ~mag, max = 100, radius = 20, blur = 10) 图 12.2: 斐济地震带热力图 # 地图默认放大倍数 zoom &lt;- 4 # 地图可以放大的倍数区间 minZoom &lt;- 1 maxZoom &lt;- 18 library(leaflet) library(leafletCN) library(maptools) library(leaflet.extras) # 热力图 heatmap leaflet(res, options = leafletOptions(minZoom = minZoom, maxZoom = maxZoom)) %&gt;% amap() %&gt;% #setView(lng = mean(data$long), lat = mean(data$lat), zoom = zoom) %&gt;% setView(lng = 109, lat = 38, zoom = 4) %&gt;% addHeatmap(lng = ~long2, lat = ~lat2, intensity = ~uv, max = max(res$uv), blur = blur, minOpacity = minOpacity, radius = radius) quakes$popup_text &lt;- lapply(paste( &quot;编号:&quot;, &quot;&lt;strong&gt;&quot;, quakes$stations, &quot;&lt;/strong&gt;&quot;, &quot;&lt;br&gt;&quot;, &quot;震深:&quot;, quakes$depth, &quot;&lt;br&gt;&quot;, &quot;震级:&quot;, quakes$mag ), htmltools::HTML) # 构造调色板 pal &lt;- colorBin(&quot;Spectral&quot;, bins = pretty(quakes$mag), reverse = TRUE) leaflet(quakes) %&gt;% addProviderTiles(providers$CartoDB.Positron) %&gt;% addCircles(lng = ~long, lat = ~lat, color = ~ pal(mag), label = ~popup_text) %&gt;% setView(178, -20, 5) %&gt;% addHeatmap( lng = ~long, lat = ~lat, intensity = ~mag, blur = 20, max = 0.05, radius = 15 ) %&gt;% addLegend(&quot;bottomright&quot;, pal = pal, values = ~mag, title = &quot;地震震级&quot; ) %&gt;% addScaleBar(position = c(&quot;bottomleft&quot;)) "],["sec-echarts4r-calendar.html", "12.2 日历图", " 12.2 日历图 airquality %&gt;% transform(date = seq.Date( from = as.Date(&quot;1973-05-01&quot;), to = as.Date(&quot;1973-09-30&quot;), by = &quot;day&quot; )) %&gt;% e_charts(date) %&gt;% e_calendar(range = &quot;1973&quot;) %&gt;% e_heatmap(Temp, coord_system = &quot;calendar&quot;) %&gt;% e_visual_map(max = max(airquality$Temp)) %&gt;% e_title(&quot;Calendar&quot;, &quot;Heatmap&quot;) "],["sec-echarts4r-animation.html", "12.3 动画", " 12.3 动画 # https://d.cosx.org/d/422311 library(purrr) library(echarts4r) data(&quot;gapminder&quot;, package = &quot;gapminder&quot;) titles &lt;- map(unique(gapminder$year), function(x) { list( text = &quot;Gapminder&quot;, left = &quot;center&quot; ) }) years &lt;- map(unique(gapminder$year), function(x) { list( subtext = x, left = &quot;center&quot;, top = &quot;center&quot;, z = 0, subtextStyle = list( fontSize = 100, color = &quot;rgb(170, 170, 170, 0.5)&quot;, fontWeight = &quot;bolder&quot; ) ) }) # 添加一列颜色，各大洲和颜色的对应关系可自定义，调整 levels 或 labels 里面的顺序即可，也可不指定 levels ，调用其它调色板 gapminder &lt;- gapminder %&gt;% transform( color = factor( continent, levels = c(&quot;Asia&quot;, &quot;Africa&quot;, &quot;Americas&quot;, &quot;Europe&quot;, &quot;Oceania&quot;), labels = RColorBrewer::brewer.pal(n = 5, name = &quot;Spectral&quot;) ) ) gapminder %&gt;% group_by(year) %&gt;% e_charts(x = gdpPercap, timeline = TRUE) %&gt;% e_scatter( serie = lifeExp, size = pop, bind = country, symbol_size = 5, name = &quot;&quot; ) %&gt;% e_add(&quot;itemStyle&quot;, color) %&gt;% e_y_axis( min = 20, max = 85, nameGap = 30, name = &quot;Life Exp&quot;, nameLocation = &quot;center&quot; ) %&gt;% e_x_axis( type = &quot;log&quot;, min = 100, max = 100000, nameGap = 30, name = &quot;GDP / Cap&quot;, nameLocation = &quot;center&quot; ) %&gt;% e_timeline_serie(title = titles) %&gt;% e_timeline_serie(title = years, index = 2) %&gt;% e_timeline_opts(playInterval = 1000) %&gt;% e_grid(bottom = 100) %&gt;% e_tooltip() # params.name 对应 bind # params.value[0] 对应 x # params.value[1] 对应 serie # params.value[2] 对应 size # tooltips 自定义 # https://stackoverflow.com/questions/50554304/displaying-extra-variables-in-tooltips-echarts4r # 百分数处理 # https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary mtcars %&gt;% tibble::rownames_to_column(&quot;model&quot;) %&gt;% e_charts(x = wt) %&gt;% e_scatter(serie = mpg, size = qsec, bind = model) %&gt;% e_tooltip(formatter = htmlwidgets::JS(&quot; function(params) { return ( &#39;&lt;strong&gt;&#39; + params.name + &#39;&lt;/strong&gt;&#39; + &#39;&lt;br /&gt;wt: &#39; + params.value[0] + &#39;&lt;br /&gt;mpg: &#39; + params.value[1] + &#39;&lt;br /&gt;qsec: &#39; + params.value[2] ) } &quot;)) "],["sec-shiny.html", "12.4 Shiny 集成", " 12.4 Shiny 集成 library(shiny) "],["chap-interactive-data-tables.html", "第 13 章 交互式数据表格", " 第 13 章 交互式数据表格 Greg Lin 开发的 reactable 包覆盖测试达到惊人的 99%，它基于 JavaScript 库 react-table， 是 react 框架的衍生品，Nick Raienko 整理了一份超棒的 react 模块合集 也许机智如你，可以引入更多优秀的 react 模块到 R 语言社区。reactablefmtr 提供一些函数简化 reactable 定制表格的复杂性 谢益辉开发的 DT 包覆盖测试 31%， 它基于 DataTables 库，是 jQuery 框架的衍生品。益辉评价 reactable 在多个方面优于 DT，比如行分组和聚合，嵌入 HTML widgets，甚至说要是 reactable 存在于 DT 之前，他就不会新开发 DT 这个 R 包了，不过这是后话了26。 Richard Iannone 开发的 gt 包覆盖测试 78%，类似 ggplot2 的设计哲学，试图打造制作表格的语法，相比于 reactable 和 DT， 它不依赖于 JavaScript 库，更加轻量，一般来讲，持续维护更新重 JS 库依赖的 R 包比较累人，JS 库可能会不断重构，进而变动 API。 朱昊开发的 kableExtra 大大扩展了 knitr 包的 kable() 函数的功能，虽没有覆盖测试，但中英文文档特别详细，见官网 https://haozhu233.github.io/kableExtra/。 目前，Greg Lin、 谢益辉和 Richard Iannone 都是 RStudio 公司雇员，他们背靠开源组织和大公司，开发的这些 R 包的生命力都比较强。 gt 和 kableExtra 摆脱了 JavaScript 库的依赖，网页形式的表格可以嵌入到邮件内容中，这是一个不太引人注意的优势。kableExtra 还支持高度自定义的 LaTeX 输出，详见案例 https://github.com/XiangyunHuang/bookdown-kableExtra，gt 包据说未来也会支持，拭目以待吧，也许在成书之日能看到！ 此外，还有任坤开发的 formattable 和 David Gohel 开发的 flextable 包等，一份综合介绍见博文 How to Make Beautiful Tables in R。 rtables 处于原型开发的阶段，针对复杂表格，有比较好的设计。tablesgg 使用 ggplot2 将表格渲染成图片。 https://bookdown.org/yihui/rmarkdown-cookbook/table-other.html↩︎ "],["sec-dt-reactable.html", "13.1 DT 和 reactable", " 13.1 DT 和 reactable DT 基于 jQuery 的 JS 库 DataTables 提供了一个 R 的封装，封装工具和许多其他基于 JS 库的 R 包一样，比如即将介绍的 reactable 包，都依赖于 htmlwidgets。 library(magrittr) if (!is.na(Sys.getenv(&#39;CI&#39;, NA))) { Sys.setenv(R_CRAN_WEB = &quot;https://cloud.r-project.org/&quot;) } else { Sys.setenv(R_CRAN_WEB = &quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN&quot;) } pdb &lt;- tools::CRAN_package_db() sub_pdb &lt;- subset(pdb, subset = !duplicated(pdb[, &quot;Package&quot;]) &amp; pdb[, &quot;Package&quot;] %in% .packages(T)) pkg_pdb &lt;- subset(sub_pdb, subset = grepl(&quot;Yihui Xie&quot;, sub_pdb[, &quot;Maintainer&quot;]) | grepl(&quot;Hadley Wickham&quot;, sub_pdb[, &quot;Maintainer&quot;]), select = c(&quot;Maintainer&quot;, &quot;Package&quot;, &quot;Version&quot;, &quot;Published&quot;, &quot;Title&quot;) ) pkg_pdb &lt;- transform(pkg_pdb, Title = gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, Title)) library(DT) datatable(pkg_pdb[order(pkg_pdb$Maintainer, decreasing = T), ], rownames = F, # 不显示行名 extensions = c(&quot;Buttons&quot;, &quot;RowGroup&quot;), options = list( pageLength = 10, # 每页显示的行数 language = list(url = &quot;//cdn.datatables.net/plug-ins/1.10.11/i18n/Chinese.json&quot;), # 汉化 dom = &quot;Brtp&quot;, # 去掉显示行数 i、过滤 f 的能力，翻页用 p 表示 ordering = F, # 去掉列排序 buttons = c(&quot;copy&quot;, &quot;csv&quot;, &quot;excel&quot;, &quot;pdf&quot;, &quot;print&quot;), # 提供打印按钮 rowGroup = list(dataSrc = 0), # 按 Maintainer 列分组 columnDefs = list( list(className = &quot;dt-center&quot;, targets = 0), # 不显示行名，则 targets 从 0 开始，否则从 1 开始 list(visible = FALSE, targets = 0) # 不显示 Maintainer 列 ) ), caption = &quot;谢大和哈神维护的 R 包&quot; ) colorize_num &lt;- function(x) { ifelse(x &gt; 0, sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;green&quot;, x), sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;red&quot;, x) ) } colorize_pct &lt;- function(x) { ifelse(x &gt; 0, sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;green&quot;, scales::percent(x, accuracy = 0.01)), sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;red&quot;, scales::percent(x, accuracy = 0.01)) ) } colorize_pp &lt;- function(x) { ifelse(x &gt; 0, sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;green&quot;, paste0(round(100*x, digits = 2), &quot;PP&quot;)), sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, &quot;red&quot;, paste0(round(100*x, digits = 2), &quot;PP&quot;)) ) } colorize_text &lt;- function(x, color = &quot;red&quot;) { sprintf(&quot;&lt;span style=&#39;color:%s&#39;&gt;%s&lt;/span&gt;&quot;, color, x ) } library(tibble) dat = tribble( ~name1, ~name2, as.character(htmltools::tags$b(&quot;加粗&quot;)), as.character(htmltools::a(href = &quot;https://rstudio.com&quot;, &quot;超链&quot;)), # 支持超链接 as.character(htmltools::em(&quot;强调&quot;)), &#39;&lt;a href=&quot;#&quot; onclick=&quot;alert(\\&#39;Hello World\\&#39;);&quot;&gt;Hello&lt;/a&gt;&#39;, as.character(htmltools::span(style = &#39;color:red&#39;, &quot;正常&quot;)), &#39;正常&#39; ) datatable( data = dat, escape = F, # 设置 escape = F colnames = c(colorize_text(&quot;第1列&quot;, &quot;red&quot;), as.character(htmltools::em(&quot;第2列&quot;))), caption = htmltools::tags$caption( style = &quot;caption-side: top; text-align: center;&quot;, &quot;表格 2: &quot;, htmltools::em(&quot;表格标题&quot;) ), # 在表格底部显示标题，默认在表格上方显示标题 # filter = &quot;top&quot;, # 过滤框 options = list( pageLength = 5, # 每页显示5行 dom = &quot;t&quot; ) ) 下面重点介绍 reactable 包，看看 React.js 和 Shiny 是如何集成的，这是比较高级的主题，主要参考 Alan Dipert 的演讲材料 Integrating React.js and Shiny。 library(reactable) 下面这个例子来自 React.js 官网 https://reactjs.org/ ```js class HelloMessage extends React.Component { render() { return ( &lt;div&gt; Hello {this.props.name} &lt;/div&gt; ); } } ReactDOM.render( &lt;HelloMessage name=&quot;Taylor&quot; /&gt;, document.getElementById(&#39;hello-example&#39;) ); ``` 更多细节定制见 Thomas Mock 的博文 reactable - An Interactive Tables Guide "],["sec-gt-kableExtra.html", "13.2 gt 和 kableExtra", " 13.2 gt 和 kableExtra 如表 13.1 所示，我们可以自定义表格样式，比如配色，例子修改自 kableExtra 帮助文档 https://haozhu233.github.io/kableExtra/bookdown/cross-format-tables-in-bookdown.html，同时支持 HTML 和 LaTeX 输出， 但是 LaTeX 输出需要在文档类选项中增加 table 选项，即 classoption: \"table\"，这样就可以加载 colortbl 宏包，进而提供 \\rowcolor 等 LaTeX 命令，在表格中给每个格子定制颜色。我们推荐在 classoption 中添加 table 选项，而不是再次加载 xcolor 包，比如像这样 \\usepackage[table]{xcolor}，这会在 R Markdown 中引起冲突。27 library(kableExtra) iris[1:10, ] %&gt;% transform( Sepal.Length = cell_spec(Sepal.Length, bold = T, color = spec_color(Sepal.Length, end = 0.9), font_size = spec_font_size(Sepal.Length) ) ) %&gt;% transform(Species = cell_spec( Species, color = &quot;white&quot;, bold = T, background = spec_color(1:10, end = 0.9, option = &quot;A&quot;, direction = -1 ) )) %&gt;% kable( escape = F, align = &quot;c&quot;, booktabs = T, caption = &quot;自定义表格样式&quot; ) %&gt;% kable_styling(c(&quot;striped&quot;, &quot;condensed&quot;), latex_options = &quot;striped&quot;, full_width = F ) 表 13.1: 自定义表格样式 Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 一个非常基本的 gt 制作的表格 library(gt) iris %&gt;% head() %&gt;% gt() 然后添加表格的标题和副标题，套上 md() 函数后，标题和副标题支持 Markdown 语法，告别 HTML 的制表方式吧！其它表格元素，如脚注支持和表格的列指标关联 library(data.table) iris %&gt;% as.data.table %&gt;% .[, head(.SD, 2), by = .(Species)] %&gt;% gt() %&gt;% tab_header( title = md(&quot;**鸢尾花**数据集&quot;), subtitle = &quot;R 内置数据集&quot; ) %&gt;% data_color( columns = vars(Sepal.Length), colors = scales::col_numeric(palette = terrain.colors(5, rev = T), domain = NULL) ) %&gt;% data_color( columns = vars(Species), colors = scales::col_factor(palette = hcl.colors(3), domain = NULL) ) %&gt;% tab_footnote( footnote = md(&quot;据说数据集最早收集自 Fisher&#39;s or Anderson&#39;s&quot;), locations = cells_column_labels(columns = vars(Sepal.Length)) ) %&gt;% tab_footnote( footnote = &quot;鸢尾花的类别&quot;, locations = cells_column_labels( columns = vars(Species) ) ) 更多细节的设置见 Thomas Mock 的博文gt - a (G)rammar of (T)ables 当前 gt 包对 LaTeX 的支持比较弱，上述表格在 HTML 网页环境中可以看到的效果并不能一一对应到 LaTeX 输出中。且 gt 包生成 LaTeX 表格会自动加载宏包 amsmath、booktabs、caption 和 longtable， gt_latex_dependencies() 且不能控制 https://stackoverflow.com/questions/50094698/rmarkdown-beamer-presentation-option-clash-clash-for-xcolor↩︎ "],["sec-table-session.html", "13.3 运行环境", " 13.3 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] kableExtra_1.3.4 reactable_0.2.3 tibble_3.1.2 DT_0.18 ## [5] magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] pillar_1.6.1 bslib_0.2.5.1 compiler_4.1.0 jquerylib_0.1.4 ## [5] tools_4.1.0 digest_0.6.27 viridisLite_0.4.0 jsonlite_1.7.2 ## [9] evaluate_0.14 lifecycle_1.0.0 pkgconfig_2.0.3 rlang_0.4.11 ## [13] rstudioapi_0.13 crosstalk_1.1.1 yaml_2.2.1 xfun_0.24 ## [17] stringr_1.4.0 httr_1.4.2 knitr_1.33 xml2_1.3.2 ## [21] systemfonts_1.0.2 htmlwidgets_1.5.3 sass_0.4.0 vctrs_0.3.8 ## [25] webshot_0.5.2 svglite_2.0.0 glue_1.4.2 R6_2.5.0 ## [29] fansi_0.5.0 rmarkdown_2.9 bookdown_0.22 scales_1.1.1 ## [33] ellipsis_0.3.2 htmltools_0.5.1.1 rvest_1.0.0 colorspace_2.0-2 ## [37] utf8_1.2.1 stringi_1.7.3 munsell_0.5.0 crayon_1.4.1 "],["chap-interactive-shiny-app.html", "第 14 章 交互式数据报表 shiny", " 第 14 章 交互式数据报表 shiny 学习 shiny 应用开发，建议多看看 Learn Shiny。 了解 shiny server ，推荐从 Shiny Server Professional Administrator’s Guide 开始。了解 shiny 相关的生态，建议从 shiny 资源列表 https://github.com/grabear/awesome-rshiny 和 shiny 扩展合集 https://github.com/nanxstats/awesome-shiny-extensions 开始，希望读者能从中打造属于自己的最佳实践。 RStudio 首席技术官 CTO Joe Cheng 在 2019年 RStudio 大会上介绍 企业级 shiny 应用 原理、实践和工具 可以作为 shiny 从新技术到生产力的蜕变节点。支持高并发的异步编程，比如 Heather Nolis 和 Dr. Jacqueline Nolis 的报告介绍了日百万访问量下的 shiny 应用如何搭建28。 Colin Fay, Sébastien Rochette, Vincent Guyader, Cervan Girard 的书 Engineering Production-Grade Shiny Apps 和 Hadley Wickham 的书 Mastering Shiny 的问世宣告 shiny 的成熟稳定，以及生态的形成，在此之前 shiny 一直不被看好。shiny 生态意味着一个完整的工业级的应用圈，满足安全性、稳定性、高效性、维护性、扩展性的要求。 图 14.1: Shiny 生态系统 iSEE is winner of the Most Technically Impressive award of the 2019 Shiny Contest. 源码地址 https://github.com/iSEE/isee-shiny-contest Six Years of Shiny in Research - Collaborative Development of Web Tools in R (Kasprzak et al. 2021) 图 14.2: 开发 Shiny 应用扩展的组织 以 RStudio 为核心，开发 Shiny 应用扩展的社区组织有 RStudio、Appsilon、RinteRface、ThinkR-open、dreamRs 和datastorm-open 参考文献 "],["sec-dev-workflow.html", "14.1 开发流程", " 14.1 开发流程 报表开发从数据仓库的 DWD 层开始，可能一些业务原因，我们需要从 ODS 层甚至从点击流的日志数据开始，经过数据清洗、提取、聚合成为支撑BI报表最底层的基础表，存储在 Hive 中，然后对这一系列的基础表根据BI展示的需要进行第二层聚合形成中间表，这两层数据根据业务情况做增量更新或者全量更新，并将中间表同步到 MySQL 仓库中，全量更新的情况，往往更新数据比较大，建议用 sqoop 做数据的同步。创建第二层的中间表稍有些灵活性，原则是在中间表之上对应的数据操作和可视化是容易实现且效率较高的，否则应该构造第三层的中间表，绝不能将大规模的数据集直接导入 R 中进行分析和可视化，拖慢前端展示的速度，占用过多的服务器资源。 "],["sec-dev-tools.html", "14.2 开发工具", " 14.2 开发工具 除了在第 14.1 节介绍的和数据库紧密相关的工具外，我们还需要 Git 做代码管理， Azkaban 做任务调度 （或者其它工具做任务调度器），RStudio IDE 做开发工具（或者 VS Code 等）， Shiny Server 做报表支撑，做报表管理。具体到 shiny 页面开发，我们需要： RMySQL 做数据库连接，推荐 odbc 这个包，它支持连接相当广泛的数据库。 data.table 或者 dplyr 做数据操作，推荐和管道操作 magrittr 一起使用，增加代码可读性。 plotly 或者 highcharter 做数据可视化，reactable 和 DT 做数据呈现，也可以 ggplot2 和 plotly 的 ggplotly() 函数共同实现静态图到动态图的交互可视化。 shiny 及其扩展工具做页面设计，比如 shinythemes 可以统一配色，dashboardthemes 提供更加深度的主题，shinytableau 提供仿 Tableau 的 dashboard 框架。sass 在 CSS 样式层面重定义网站风格，比如借助 sass 修改 Bootstrap 4， shiny 的布局其实就是魔改了 Bootstrap 库。 针对特定应用场景的其它交互可视化工具包，比如 leaflet 可以将地图嵌入 Shiny 应用， dygraphs 可以将时间序列塞进去。 其它加强 shiny 页面的小功能，比如 shinyFeedback 提供用户输入的反馈，miniUI 专为小屏幕设计，shinyMobile 在 IOS 和安卓手机上访问 shiny 应用，大大加强 miniUI 的功能，shinyWidgets 提供自定义 widget 的功能，shinymanager 支持单个 shiny 应用的权限管理，firebase 提供访问权限设置 https://firebase.john-coene.com/。 shiny-server 以网络服务的方式支持 shiny 应用，是企业级 shiny 应用的核心， shinyproxy 提供企业级部署 shiny 应用的开源解决方案，ShinyStudio 打造基于容器架构的协作开发环境的开源解决方案，golem 构建企业级 shiny 应用的框架，RinteRface 开发的系列 R 包也试图打造一套完整的解决方案，并配有速查小抄 cheatsheets radiant 探索性分析解决方案 library(shiny) "],["sec-foundations.html", "14.3 基础知识", " 14.3 基础知识 1920s 汽车数据分析和建模 "],["sec-shiny-elements.html", "14.4 基础组件", " 14.4 基础组件 14.4.1 书签 链接可以指向页面状态 library(shiny) ui &lt;- function(request) { fluidPage( plotOutput(&quot;plot&quot;), sliderInput(&quot;n&quot;, &quot;Number of observations&quot;, 1, nrow(faithful), 100), bookmarkButton() ) } server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ hist(faithful$eruptions[seq_len(input$n)], breaks = 40) }) } enableBookmarking(store = &quot;url&quot;) shinyApp(ui, server) 14.4.2 表格 reactable 基于 JS 库 React Table 提供交互式表格渲染，和 shiny 无缝集成，是替代 DT 的不二选择，在 app.R 用 reactable 包的 reactableOutput() 和 renderReactable() 函数替代 shiny 里面的 dataTableOutput() 和 renderDataTable()。 再也不用忍受 DT 和 shiny 的函数冲突了，且其覆盖测试达到 99%。 library(shiny) library(data.table) gt 高度自定义 gt 表格样式，支持 shiny 集成， data.table 提供高效的数据操作，formattable 支持自定义格子。 kableExtra 包 library(shiny) library(data.table) library(magrittr) library(kableExtra) ui &lt;- fluidPage( title = &quot;mtcars datasets&quot;, titlePanel(&quot;mtcars 数据集&quot;), sidebarLayout( sidebarPanel( sliderInput(&quot;mpg&quot;, &quot;mpg 范围&quot;, min = 11, max = 33, value = 15 ) ), mainPanel( tableOutput(&quot;mtcars_kable&quot;) ) ) ) ## 设置列序 https://stackoverflow.com/questions/19619666/change-column-position-of-data-table server &lt;- function(input, output) { output$mtcars_kable &lt;- function() { # 转化数据类型 mtcars_dt &lt;- as.data.table(mtcars) # 添加新的列 mtcars_dt[, car := rownames(mtcars)][mpg &lt;= input$mpg] %&gt;% setcolorder(., c(&quot;car&quot;, setdiff(names(.), &quot;car&quot;))) %&gt;% knitr::kable(&quot;html&quot;) %&gt;% kable_styling(&quot;striped&quot;, full_width = F) %&gt;% add_header_above(c(&quot; &quot;, &quot;Group 1&quot; = 5, &quot;Group 2&quot; = 6)) } } # 执行程序 shinyApp(ui = ui, server = server) reactable 包 library(shiny) library(reactable) ui &lt;- fluidPage( reactableOutput(&quot;table&quot;) ) server &lt;- function(input, output) { output$table &lt;- renderReactable({ reactable(iris, filterable = TRUE, # 过滤 searchable = TRUE, # 搜索 showPageSizeOptions = TRUE, # 页面大小 pageSizeOptions = c(5, 10, 15), # 页面大小可选项 defaultPageSize = 10, # 默认显示10行 highlight = TRUE, # 高亮选择 striped = TRUE, # 隔行高亮 fullWidth = FALSE, # 默认不要全宽填充，适应数据框的宽度 defaultSorted = list( Sepal.Length = &quot;asc&quot;, # 由小到大排序 Petal.Length = &quot;desc&quot; # 由大到小 ), columns = list( Sepal.Width = colDef(style = function(value) { # Sepal.Width 添加颜色标记 if (value &gt; 3.5) { color &lt;- &quot;#008000&quot; } else if (value &gt; 2) { color &lt;- &quot;#e00000&quot; } else { color &lt;- &quot;#777&quot; } list(color = color, fontWeight = &quot;bold&quot;) # 字体加粗 }) ) ) }) } shinyApp(ui, server) 下面介绍 DT library(magrittr) # ui.R 前端 library(shiny) shinyUI(fluidPage( # 应用的标题名称 titlePanel(&quot;鸢尾花数据集&quot;), # 边栏 fluidRow( column( 12, DT::dataTableOutput(&quot;table&quot;) ) ) )) # server.R 服务端 library(shiny) shinyServer(function(input, output, session) { output$table &lt;- iris %&gt;% `colnames&lt;-`(., gsub(&quot;\\\\.&quot;, &quot;_&quot;, tolower(colnames(.)))) %&gt;% DT::renderDataTable(., options = list( pageLength = 5, # 每页显示5行 initComplete = I(&quot;function(settings, json) {alert(&#39;Done.&#39;);}&quot;) ), server = F ) }) 加载 shiny 包后再加载 DT 包，函数 dataTableOutput() 和renderDataTable() 显示冲突，因为两个 R 包都有这两个函数。在创建 shiny 应用的过程中，如果我们需要呈现动态表格，就需要使用 DT 包的 DT::dataTableOutput() 和 DT::renderDataTable() 否则会报错，详见 https://github.com/rstudio/shiny/issues/2653，DT 包官方文档 https://rstudio.github.io/DT/。 在 server.R 里我们对数据集 iris 做了重命列名的操作，如果不使用管道操作，通常是下面这样操作。 colnames(iris) &lt;- gsub(&quot;\\\\.&quot;, &quot;_&quot;, tolower(colnames(iris))) 换成管道操作，函数 colnames() 要换成 colnames&lt;-，这其实类似于 1 + 2 换成 +(1, 2)，保持函数在左边，参数值在右边的一致性。 设置页面默认显示的行数和列的宽度 # https://stackoverflow.com/questions/45509501/set-names-of-values-in-lengthmenu-page-length-menu-in-r-dt-datatable # 相关例子见 https://github.com/rstudio/shiny-examples/tree/master/018-datatable-options # DT 选项 https://rstudio.github.io/DT/options.html library(shiny) library(DT) ui &lt;- fluidPage( DT::dataTableOutput(&quot;table&quot;) ) server &lt;- function(input, output) { output$table &lt;- DT::renderDataTable({ DT::datatable(iris, options = list( language = list(url = &quot;//cdn.datatables.net/plug-ins/1.10.11/i18n/Chinese.json&quot;), pageLength = 24, # 设置页面默认显示的行数 lengthMenu = list( c(24, 48, 72, 96, -1), c(&quot;24&quot;, &quot;48&quot;, &quot;72&quot;, &quot;96&quot;, &quot;All&quot;) ), paging = T, # 设置第一列和第三列的宽度 https://rstudio.github.io/DT/options.html autoWidth = TRUE, columnDefs = list(list(width = &#39;400px&#39;, targets = c(1, 3))) )) }) } shinyApp(ui, server) 按指定格式显示数据 # data &lt;- data.frame(x = c(100.0011, 80.0011, -90.0011, -110.0011, -70)) # # library(shiny) # runApp(list( # ui = fluidPage(dataTableOutput(&quot;num&quot;)), # server = function(input, output) { # output$num = renderDataTable(format(round(data, 3), nsmall = 3)) # } # )) library(DT) dat &lt;- data.frame(x = c(100.0011, 80.0011, -90.0011, -110.0067, -70)) rowCallback &lt;- c( &quot;function(row, data, index){&quot;, &quot; var N = data.length;&quot;, &quot; for(var j=1; j&lt;data.length; j++){&quot;, &quot; $(&#39;td:eq(&#39;+j+&#39;)&#39;,row)&quot;, &quot; .html(parseFloat(data[j]).toFixed(3));&quot;, # 四舍五入保留 3 位小数 &quot; }&quot;, &quot;}&quot; ) # https://github.com/rstudio/shiny/issues/2277 datatable(dat, options = list( rowCallback = JS(rowCallback) ) ) "],["sec-advanced-topics.html", "14.5 高级主题", " 14.5 高级主题 异步编程，并发访问 ## shiny 异步编程 ## 解决问题，多人同时访问 Shiny 应用的情况下，必须等另一个人完成访问的情况下才能继续访问 library(shiny) library(future) library(promises) plan(multiprocess) ui &lt;- fluidPage( h2(&quot;测试异步下载&quot;), tags$ol( tags$li(&quot;Verify that plot appears below&quot;), tags$li(&quot;Verify that pressing Download results in 5 second delay, then rock.csv being downloaded&quot;), tags$li(&quot;Check &#39;Throw on download?&#39; checkbox and verify that pressing Download results in 5 second delay, then error, as well as stack traces in console&quot;) ), hr(), checkboxInput(&quot;throw&quot;, &quot;Throw on download?&quot;), downloadButton(&quot;download&quot;, &quot;下载 (等待5秒)&quot;), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output, session) { output$download &lt;- downloadHandler(&quot;rock.csv&quot;, function(file) { future({Sys.sleep(5)}) %...&gt;% { if (input$throw) { stop(&quot;boom&quot;) } else { write.csv(rock, file) } } }) output$plot &lt;- renderPlot({ plot(cars) }) } shinyApp(ui, server) "],["sec-shiny-deployment.html", "14.6 部署应用", " 14.6 部署应用 "],["sec-shiny-principles.html", "14.7 最佳实践", " 14.7 最佳实践 提升 shiny 仪表盘访问性能的4个建议 "],["sec-shiny-dashboard.html", "14.8 仪表盘", " 14.8 仪表盘 dashboard 翻译过来叫仪表盘，就是驾驶仓的那个玩意，形象地表达作为掌舵者应该关注的对象。R 包 shiny 出现后，仪表盘的制作显得非常容易，也很快形成了一个生态，比如 shinydashboard、 flexdashboard 等，此外 bs4Dash 基于 Bootstrap 4 的仪表盘，目前 shiny 和 rmarkdown 都在向 Bootstrap 4 升级，这是未来的方向。 shinydashboardPlus 主要目的在于扩展 shinydashboard 包 shinydashboard 包 ## app.R ## library(shiny) library(shinydashboard) ui &lt;- dashboardPage( dashboardHeader(title = &quot;Basic dashboard&quot;), ## Sidebar content dashboardSidebar( sidebarMenu( menuItem(&quot;Dashboard&quot;, tabName = &quot;dashboard&quot;, icon = icon(&quot;dashboard&quot;)), menuItem(&quot;Widgets&quot;, tabName = &quot;widgets&quot;, icon = icon(&quot;th&quot;)) ) ), ## Body content dashboardBody( tabItems( # First tab content tabItem(tabName = &quot;dashboard&quot;, fluidRow( box(plotOutput(&quot;plot1&quot;, height = 250)), box( title = &quot;Controls&quot;, sliderInput(&quot;slider&quot;, &quot;Number of observations:&quot;, 1, 100, 50) ) ) ), # Second tab content tabItem(tabName = &quot;widgets&quot;, h2(&quot;Widgets tab content&quot;) ) ) ) ) server &lt;- function(input, output) { set.seed(122) histdata &lt;- rnorm(500) output$plot1 &lt;- renderPlot({ data &lt;- histdata[seq_len(input$slider)] hist(data) }) } shinyApp(ui, server) shinydashboardPlus 包 library(shiny) library(shinydashboard) library(shinydashboardPlus) shinyApp( ui = dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody( box( solidHeader = FALSE, title = &quot;Status summary&quot;, background = NULL, width = 4, status = &quot;danger&quot;, footer = fluidRow( column( width = 6, descriptionBlock( number = &quot;17%&quot;, numberColor = &quot;green&quot;, numberIcon = &quot;fa fa-caret-up&quot;, header = &quot;$35,210.43&quot;, text = &quot;TOTAL REVENUE&quot;, rightBorder = TRUE, marginBottom = FALSE ) ), column( width = 6, descriptionBlock( number = &quot;18%&quot;, numberColor = &quot;red&quot;, numberIcon = &quot;fa fa-caret-down&quot;, header = &quot;1200&quot;, text = &quot;GOAL COMPLETION&quot;, rightBorder = FALSE, marginBottom = FALSE ) ) ) ) ), title = &quot;Description Blocks&quot; ), server = function(input, output) { } ) shinymaterial 包 library(shiny) library(shinymaterial) # https://ericrayanderson.github.io/shinymaterial/ # https://github.com/ericrayanderson/shinymaterial # Wrap shinymaterial apps in material_page ui &lt;- material_page( title = &quot;用户画像&quot;, nav_bar_fixed = TRUE, # 每个 sidebar 内容 material_side_nav( fixed = TRUE, # Place side-nav tabs within side-nav material_side_nav_tabs( side_nav_tabs = c( &quot;数据汇总&quot; = &quot;tab_1&quot;, &quot;趋势信息&quot; = &quot;tab_2&quot; ), icons = c(&quot;cast&quot;, &quot;insert_chart&quot;) ) ), # 每个 tab 页面的内容 material_side_nav_tab_content( side_nav_tab_id = &quot;tab_1&quot;, tags$h2(&quot;第一个tab页&quot;) ), material_side_nav_tab_content( side_nav_tab_id = &quot;tab_2&quot;, tags$h2(&quot;第二个tab页&quot;) ) ) server &lt;- function(input, output) { } shinyApp(ui = ui, server = server) miniUI 包 library(shiny) library(miniUI) library(leaflet) library(ggplot2) ui &lt;- miniPage( gadgetTitleBar(&quot;Shiny gadget example&quot;), miniTabstripPanel( miniTabPanel(&quot;Parameters&quot;, icon = icon(&quot;sliders&quot;), miniContentPanel( sliderInput(&quot;year&quot;, &quot;Year&quot;, 1978, 2010, c(2000, 2010), sep = &quot;&quot;) ) ), miniTabPanel(&quot;Visualize&quot;, icon = icon(&quot;area-chart&quot;), miniContentPanel( plotOutput(&quot;cars&quot;, height = &quot;100%&quot;) ) ), miniTabPanel(&quot;Map&quot;, icon = icon(&quot;map-o&quot;), miniContentPanel(padding = 0, leafletOutput(&quot;map&quot;, height = &quot;100%&quot;) ), miniButtonBlock( actionButton(&quot;resetMap&quot;, &quot;Reset&quot;) ) ), miniTabPanel(&quot;Data&quot;, icon = icon(&quot;table&quot;), miniContentPanel( DT::dataTableOutput(&quot;table&quot;) ) ), selected = &quot;Map&quot; ) ) server &lt;- function(input, output, session) { output$cars &lt;- renderPlot({ require(ggplot2) ggplot(cars, aes(speed, dist)) + geom_point() }) output$map &lt;- renderLeaflet({ force(input$resetMap) leaflet(quakes, height = &quot;100%&quot;) %&gt;% addTiles() %&gt;% addMarkers(lng = ~long, lat = ~lat) }) output$table &lt;- DT::renderDataTable({ diamonds }) observeEvent(input$done, { stopApp(TRUE) }) } shinyApp(ui, server) "],["sec-interactive-dash-app.html", "14.9 交互式数据报表 dash", " 14.9 交互式数据报表 dash library(dash) library(dashHtmlComponents) library(dashCoreComponents) library(dashTable) "],["sec-session-shiny.html", "14.10 运行环境", " 14.10 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] data.table_1.14.0 shiny_1.6.0 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.7 knitr_1.33 magrittr_2.0.1 xtable_1.8-4 ## [5] R6_2.5.0 rlang_0.4.11 fastmap_1.1.0 stringr_1.4.0 ## [9] highr_0.9 tools_4.1.0 nomnoml_0.2.3 xfun_0.24 ## [13] jquerylib_0.1.4 ellipsis_0.3.2 htmltools_0.5.1.1 yaml_2.2.1 ## [17] digest_0.6.27 lifecycle_1.0.0 bookdown_0.22 later_1.2.0 ## [21] promises_1.2.0.1 sass_0.4.0 htmlwidgets_1.5.3 mime_0.11 ## [25] evaluate_0.14 rmarkdown_2.9 stringi_1.7.3 compiler_4.1.0 ## [29] bslib_0.2.5.1 jsonlite_1.7.2 httpuv_1.6.1 "],["chap-string-operations.html", "第 15 章 字符串操作", " 第 15 章 字符串操作 shopping_list &lt;- c(&quot;apples x4&quot;, &quot;bag of flour&quot;, &quot;bag of sugar&quot;, &quot;milk x2&quot;) stringr::str_replace(string = shopping_list, pattern = &quot;\\\\d&quot;, replacement = &quot;aa&quot;) ## [1] &quot;apples xaa&quot; &quot;bag of flour&quot; &quot;bag of sugar&quot; &quot;milk xaa&quot; # https://github.com/hadley/stringb/issues/5 # x is vector str_replace &lt;- function(x, pattern, fun, ...) { loc &lt;- gregexpr(pattern, text = x, perl = TRUE) matches &lt;- regmatches(x, loc) out &lt;- lapply(matches, fun, ...) regmatches(x, loc) &lt;- out x } loc &lt;- gregexpr(pattern = &quot;\\\\d&quot;, text = shopping_list, perl = TRUE) matches = regmatches(x = shopping_list, loc) matches out &lt;- lapply(matches, transform, &quot;aa&quot;) regmatches(x = shopping_list, loc) &lt;- out shopping_list str_replace(shopping_list, pattern = &quot;\\\\\\\\d&quot;, replace = &quot;aa&quot;) "],["sec-encode-string.html", "15.1 字符串加密", " 15.1 字符串加密 字符串编码加密， openssl 包提供了 sha1 函数29 library(openssl) encode_mobile &lt;- function(phone_number) paste(&quot;*&quot;, paste(toupper(sha1(sha1(charToRaw(paste(phone_number, &quot;$1$mobile$&quot;, sep = &quot;&quot;))))), collapse = &quot;&quot;), sep = &quot;&quot;) # 随意模拟两个手机号 mobile_vec &lt;- c(&quot;18601013453&quot;, &quot;13811674545&quot;) sapply(mobile_vec, encode_mobile) ## 18601013453 ## &quot;*B1D46D1D62C7280137F0E14249EE500865247B7B&quot; ## 13811674545 ## &quot;*0554DA6E403491F58F1567DF2EDEB19186B77173&quot; 参考刘思喆的两篇博文： 利用 R 函数生成差异化密码 和 在 R 中各种码的转换↩︎ "],["chap-regular-expressions.html", "第 16 章 正则表达式", " 第 16 章 正则表达式 批量转换驼峰式命名 old_name &lt;- list.files(&quot;.&quot;, pattern = &quot;^[A-Z].*.Rmd$&quot;) new_name &lt;- gsub(&quot;rmd&quot;, &quot;Rmd&quot;, tolower(old_name)) file.rename(from = old_name, to = new_name) html_lines &lt;- readLines(&quot;https://movie.douban.com/top250&quot;) doc &lt;- paste0(html_lines, collapse = &quot;&quot;) title_lines &lt;- grep(&#39;class=&quot;title&quot;&#39;, html_lines, value = T) titles &lt;- gsub(&quot;.*&gt;(.*?)&lt;.*&quot;, &quot;\\\\1&quot;, title_lines, perl = T) gsub(&quot;.*&gt;(.*?)&lt;.*&quot;, &quot;\\\\1&quot;, &#39;&lt;span class=&quot;title&quot;&gt;肖生克的救赎&lt;/span&gt;&#39;, perl = T) 解析术之 XPath library(xml2) dom = read_html(doc) title_nodes = xml_find_all(dom, &#39;.//span[@class=&quot;title&quot;]&#39;) xml_text(title_nodes) 解析术之 CSS Selector library(rvest) read_html(doc) %&gt;% html_nodes(&#39;.title&#39;) %&gt;% # class=&quot;title&quot;的标签 html_text() "],["chap-text-analysis.html", "第 17 章 文本分析", " 第 17 章 文本分析 PDFR 和 pdftools 从 PDF 文档抽取文本， tesseract 从扫描件中抽取文本 fastTextR https://github.com/facebookresearch/fastText "],["chap-sampling-distributions.html", "第 18 章 抽样分布", " 第 18 章 抽样分布 分布我们已经听说过很多了，可是它们都是凭空臆测的吗？肯定不是，那它们是怎么产生的呢？谁提出了正态分布，他/她是怎么提出的？一定有故事背景，一定有数据记录，即观察值，我们的样本数据 抽样分布其中抽样二字更加贴近生活，说明它源于实际生产场景，而不是光靠大脑思维理论推导出来的东西，它是最本质的 "],["sec-normal-distribution.html", "18.1 正态分布", " 18.1 正态分布 分三块介绍 历史背景 分布性质 应用场景 来源，为啥叫逻辑斯谛？历史故事 逻辑斯谛分布 正态分布 t 分布 F 分布 \\(\\chi^2\\) 分布 霍特林 \\(T^2\\) 分布 Hoteling’s T^2 Distribution 威沙特分布 Wishart Distribution 分一元和多元情况阐述正态分布、t 分布、F 分布、卡方分布及分布拟合 常见分布之间的关系图需要用 TikZ 来绘制 完整的关系图 http://www.math.wm.edu/~leemis/2008amstat.pdf 参考自 https://www.math.wustl.edu/~jmding/math494/dist.pdf 图来自 (Leemis 1986) 参考文献 "],["sec-exponential-family.html", "18.2 指数族", " 18.2 指数族 谁提出的指数族，有哪些性质，指数族 quasi-poisson 是什么含义，拟族 如何判别一个分布是否属于指数族 常见的高斯、二项、正态分布、伽马分布、泊松分布 指数族 推广到一般情况 三大抽样分布t分布，\\(\\chi\\) 分布和F分布，一元和多元情形，一元分布知识范围是本科，多元分布范围是研究生和博士，参考数理统计引论。一元分布多用于本科假设检验，多元分布常用于均值向量和协方差阵以及统计量的极限分布。介绍各个分布的形式、历史来源、各个特征量、密度、分布函数推导，数值计算 三大抽样的发现、历史、多元、非中心形式的推广 多元 t 分布函数 (MVT) \\[ T(\\mathbf{a},\\mathbf{b},\\Sigma,\\nu)=\\frac{2^{1-\\frac{\\nu}{2}}}{\\Gamma(\\frac{\\nu}{2}) } \\int_{0}^{\\infty} s^{\\nu-1}e^{-\\frac{s^2}{2}} \\Phi(\\frac{s\\mathbf{a}}{\\sqrt{\\nu}},\\frac{s\\mathbf{b}}{\\sqrt{\\nu}},\\Sigma)ds \\] 多元正态分布函数 (MVN) \\[ \\Phi(\\mathbf{a},\\mathbf{b},\\Sigma)=\\frac{1}{\\sqrt{|\\Sigma|(2\\pi)^m}} \\int_{a_1}^{b_1}\\!\\int_{a_2}^{b_2}\\!\\cdots\\!\\int_{a_m}^{b_m} e^{-\\frac{1}{2}x^\\top\\Sigma^{-1}x}dx \\] 其中 \\(x = (x_1,x_2,\\dots,x_m)^\\top, \\forall i, -\\infty \\le a_i \\le b_i \\le \\infty\\)， \\(\\Sigma\\) 是 \\(m \\times m\\) 对称非负定的矩阵 多元 \\(t\\) 分布分位数计算 library(mvtnorm) n &lt;- c(26, 24, 20, 33, 32) V &lt;- diag(1 / n) df &lt;- 130 C &lt;- matrix(c( 1, 1, 1, 0, 0, -1, 0, 0, 1, 0, 0, -1, 0, 0, 1, 0, 0, 0, -1, -1, 0, 0, -1, 0, 0 ), ncol = 5) cv &lt;- C %*% V %*% t(C) ## covariance matrix dv &lt;- t(1 / sqrt(diag(cv))) cr &lt;- cv * (t(dv) %*% dv) ## correlation matrix delta &lt;- rep(0, 5) Tn &lt;- qmvt(0.95, df = df, delta = delta, corr = cr, abseps = 0.0001, maxpts = 100000, tail = &quot;both&quot; ) Tn ## $quantile ## [1] 2.560817 ## ## $f.quantile ## [1] 2.245686e-07 ## ## attr(,&quot;message&quot;) ## [1] &quot;Normal Completion&quot; 计算多元正态分布的概率，这个例子来自 https://stackoverflow.com/questions/36704081 # 模拟一个协方差矩阵 sigma &lt;- as.matrix(read.csv(file = &quot;data/sigma.csv&quot;, header = F, sep = &quot;,&quot;)) rownames(sigma) &lt;- colnames(sigma) # matrixcalc::is.symmetric.matrix(sigma) # 判断 sigma 是否为对称的矩阵 # matrixcalc::is.positive.definite(sigma) # 判断 sigma 是否为正定的矩阵 # isTRUE(all.equal(sigma, t(sigma))) m &lt;- nrow(sigma) Fn &lt;- pmvnorm( lower = rep(-Inf, m), upper = rep(0, m), mean = rep(0, m), sigma = sigma ) Fn mvrnorm() 函数来自 MASS 包，模拟多元正态分布的样本 library(MASS) set.seed(2018) n &lt;- 1000 # 样本量 X &lt;- mvrnorm(n, mu = rep(0, 2), Sigma = matrix(c(1, 0.8, 0.8, 1), 2)) plot(X, pch = 20, panel.first = grid(), cex = 1, col = densCols(X, colramp = hcl.colors), xlab = expression(X[1]), ylab = expression(X[2]) ) 图 18.1: 二维正态分布 f1 &lt;- kde2d(X[, 1], X[, 2], n = 25) image(f1, col = hcl.colors(100), xlab = expression(X[1]), ylab = expression(X[2])) contour(f1, add = T) 图 18.2: 二维正态分布 nrz &lt;- nrow(f1$z) ncz &lt;- ncol(f1$z) nbcol &lt;- 100 color &lt;- hcl.colors(100) # Compute the z-value at the facet centres zfacet &lt;- f1$z[-1, -1] + f1$z[-1, -ncz] + f1$z[-nrz, -1] + f1$z[-nrz, -ncz] # Recode facet z-values into color indices facetcol &lt;- cut(zfacet, nbcol) persp(f1, xlab = &quot;X[1]&quot;, ylab = &quot;X[2]&quot;, zlab = &quot;\\n Z&quot;, theta = 30, phi = 20, col = color[facetcol], r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180, shade = 0.1, ticktype = &quot;detailed&quot;, nticks = 5, box = TRUE ) 图 18.3: 二维正态分布 Wishart 分布 文献 (Eaton 2007) 第八章 参考文献 "],["chap-parameter-estimators.html", "第 19 章 参数估计", " 第 19 章 参数估计 Jeremy Koster: My students were looking at the estimated varying intercepts for each higher-level group (or the “BLUP’s,” as some people seem to call them). Douglas Bates: As Alan James once said, “these values are just like the BLUPs - Best Linear Unbiased Predictors - except that they aren’t linear and they aren’t unbiased and there is no clear sense in which they are”best”, but other than that …” — Jeremy Koster and Douglas Bates30 https://stat.ethz.ch/pipermail/r-sig-mixed-models/2012q3/018817.html↩︎ "],["sec-point-estimator.html", "19.1 点估计", " 19.1 点估计 矩估计 极大似然估计 最小二乘估计 同变估计 稳健估计 单参数和多参数模型的参数估计，比如指数分布、泊松分布、二项分布、正态分布，线性模型各个估计的推导过程 应当考虑 \\((X^{\\top}X)^{-1}\\) 不存在的情况，在均方误差最小的意义下，不必要求 \\(\\beta\\) 的估计 \\(\\hat{\\beta}\\) 满足无偏性的要求，所以介绍岭回归估计 \\(\\hat{\\beta}_{ridge}\\)、压缩估计 \\(\\hat{\\beta}_{jse}\\)、主成分估计 \\(\\hat{\\beta}_{pca}\\) 和偏最小二乘估计 \\(\\hat{\\beta}_{pls}\\)。相比于 \\(\\hat{\\beta}_{pca}\\)， \\(\\hat{\\beta}_{pls}\\) 考虑了响应变量的作用。《数理统计引论》第5章第5节线性估计类从改进 LS 估计出发，牺牲一部分估计的偏差，即采用有偏的估计，达到总体均方误差更小的效果 (陈希孺 1981) James-Stein 估计可不可以看作一种压缩估计？从它牺牲一部分偏差，获取整体方差的降低来看和上面应该有某种联系 昔日因，今日意 讲线性混合效应模型和很多模型之间的联系 那些年，我们一起追的 EB James-Stein 估计和岭回归估计的联系 统计学习那些事 lasso 和 boosting 之间的联系 19.1.1 矩估计 19.1.2 最小二乘估计 谈非线性最小二乘，这段话的意思是非线性模型不要谈 ANOVA 和 R^2 之类的东西 As one of the developers of the nls function I would like to state that the lack of automatic ANOVA, \\(R^2\\) and \\(adj. R^2\\) from nls is a feature, not a bug :-) — Douglas Bates31 最小二乘估计是一种非参数估计方法（对数据分布没有假设，只要预测误差达到最小即可），而极大似然估计是一种参数估计方法（观测数据服从带参数的多元分布） 非线性最小二乘估计 # Nonlinear least-squares using nlm() # demo(nlm) # Helical Valley Function # 非线性最小二乘 theta &lt;- function(x1, x2) (atan(x2 / x1) + (if (x1 &lt;= 0) pi else 0)) / (2 * pi) ## 更加简洁的表达 theta &lt;- function(x1, x2) atan2(x2, x1) / (2 * pi) # 目标函数 f &lt;- function(x) { f1 &lt;- 10 * (x[3] - 10 * theta(x[1], x[2])) f2 &lt;- 10 * (sqrt(x[1]^2 + x[2]^2) - 1) f3 &lt;- x[3] return(f1^2 + f2^2 + f3^2) } ## explore surface {at x3 = 0} x &lt;- seq(-1, 2, length.out = 50) y &lt;- seq(-1, 1, length.out = 50) z &lt;- apply(as.matrix(expand.grid(x, y)), 1, function(x) f(c(x, 0))) contour(x, y, matrix(log10(z), 50, 50)) nlm.f &lt;- nlm(f, c(-1, 0, 0), hessian = TRUE) points(rbind(nlm.f$estim[1:2]), col = &quot;red&quot;, pch = 20) ### the Rosenbrock banana valley function 香蕉谷函数 fR &lt;- function(x) { x1 &lt;- x[1] x2 &lt;- x[2] 100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } ## explore surface fx &lt;- function(x) { ## `vectorized&#39; version of fR() x1 &lt;- x[, 1] x2 &lt;- x[, 2] 100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } x &lt;- seq(-2, 2, length.out = 100) y &lt;- seq(-0.5, 1.5, length.out = 100) z &lt;- fx(expand.grid(x, y)) op &lt;- par(mfrow = c(2, 1), mar = 0.1 + c(3, 3, 0, 0)) contour(x, y, matrix(log10(z), length(x))) nlm.f2 &lt;- nlm(fR, c(-1.2, 1), hessian = TRUE) points(rbind(nlm.f2$estim[1:2]), col = &quot;red&quot;, pch = 20) ## Zoom in : rect(0.9, 0.9, 1.1, 1.1, border = &quot;orange&quot;, lwd = 2) x &lt;- y &lt;- seq(0.9, 1.1, length.out = 100) z &lt;- fx(expand.grid(x, y)) contour(x, y, matrix(log10(z), length(x))) mtext(&quot;zoomed in&quot;) box(col = &quot;orange&quot;) points(rbind(nlm.f2$estim[1:2]), col = &quot;red&quot;, pch = 20) par(op) with( nlm.f2, stopifnot( all.equal(estimate, c(1, 1), tol = 1e-5), minimum &lt; 1e-11, abs(gradient) &lt; 1e-6, code %in% 1:2 ) ) fg &lt;- function(x) { gr &lt;- function(x1, x2) { c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1), 200 * (x2 - x1 * x1)) } x1 &lt;- x[1] x2 &lt;- x[2] structure(100 * (x2 - x1 * x1)^2 + (1 - x1)^2, gradient = gr(x1, x2) ) } nfg &lt;- nlm(fg, c(-1.2, 1), hessian = TRUE) str(nfg) with( nfg, stopifnot( minimum &lt; 1e-17, all.equal(estimate, c(1, 1)), abs(gradient) &lt; 1e-7, code %in% 1:2 ) ) ## or use deriv to find the derivatives fd &lt;- deriv(~ 100 * (x2 - x1 * x1)^2 + (1 - x1)^2, c(&quot;x1&quot;, &quot;x2&quot;)) fdd &lt;- function(x1, x2) {} body(fdd) &lt;- fd nlfd &lt;- nlm(function(x) fdd(x[1], x[2]), c(-1.2, 1), hessian = TRUE) str(nlfd) with( nlfd, stopifnot( minimum &lt; 1e-17, all.equal(estimate, c(1, 1)), abs(gradient) &lt; 1e-7, code %in% 1:2 ) ) fgh &lt;- function(x) { gr &lt;- function(x1, x2) { c(-400 * x1 * (x2 - x1 * x1) - 2 * (1 - x1), 200 * (x2 - x1 * x1)) } h &lt;- function(x1, x2) { a11 &lt;- 2 - 400 * x2 + 1200 * x1 * x1 a21 &lt;- -400 * x1 matrix(c(a11, a21, a21, 200), 2, 2) } x1 &lt;- x[1] x2 &lt;- x[2] structure(100 * (x2 - x1 * x1)^2 + (1 - x1)^2, gradient = gr(x1, x2), hessian = h(x1, x2) ) } nlfgh &lt;- nlm(fgh, c(-1.2, 1), hessian = TRUE) str(nlfgh) ## NB: This did _NOT_ converge for R version &lt;= 3.4.0 with( nlfgh, stopifnot( minimum &lt; 1e-15, # see 1.13e-17 .. slightly worse than above all.equal(estimate, c(1, 1), tol = 9e-9), # see 1.236e-9 abs(gradient) &lt; 7e-7, code %in% 1:2 ) ) # g[1] = 1.3e-7 19.1.3 极大似然估计 教材简短一句话，这里面有很多信息值得发散，一个数学家提出了统计学领域极其重要的一个核心思想，他是在研究什么的时候提出了这个想法，为什么后来没有得到重视，虽然这可能有点离题，但是对于读者可能有很多别的启迪。整整100 年以后，Fisher 又是怎么提出这一思想的呢？他做了什么使得这个思想被广泛接受和应用？ 统计决策理论，任何统计推断都应该依赖损失函数，而极大似然估计未曾考虑到，这是它的局限性。 Lasso 和贝叶斯先验的关系，和损失函数的关系 是最大似然估计还是极大似然估计？当然是极大似然估计，如果有人告诉你是最大似然估计那一定是假的，这两个概念归根结底是极值和最值得区别 书本定义和性质，在后续章节介绍 介绍线性模型为何引入 REML 减少偏差 极大似然估计是费舍尔提出来的 边际似然 Marginal Likelihood 条件似然 conditional lkelihood 完全似然 complete Likelihood 层次似然 Hierarchical likelihood 部分似然 partial likelihood 剖面似然 Profile Likelihood 限制似然 Restricted Likelihood 惩罚/边际拟似然 (PQL/MQL) Penalized Quasi-Likelihood/Marginal Quasi-Likelihood 分布 边际分布 条件分布 似然 边际似然 条件似然 极大似然估计 Maximum likelihood 简称 ML 限制极大似然 Restricted Maximum likelihood, 简称 REML 惩罚拟似然 Penalized Quasi-Likelihood, 简称 PQL 和边际拟似然 Marginal Quasi-Likelihood, 简称 MQL，Profile Maximal Likelihood, 简称 PML 拟似然估计 极大似然估计 似然函数 Penalized maximum likelihood estimates are calculated using optimization methods such as the limited memory Broyden-Fletcher-Goldfarb-Shanno algorithm (L-BFGS). BFGS 拟牛顿法和采样器 https://bookdown.org/rdpeng/advstatcomp 参考文献 "],["chap-interval-estimation.html", "19.2 区间估计", " 19.2 区间估计 19.2.1 正态分布 正态分布 \\(\\mathcal{N}(\\mu,\\sigma^2)\\)，\\(\\sigma^2\\) 未知，关于参数 \\(\\mu\\) 的置信水平为 \\(1 - \\alpha\\) 的区间估计 构造统计量 \\(t = \\frac{\\bar{x} - \\mu}{s/\\sqrt{n}} \\sim t(n-1)\\) 参数 \\(\\mu\\) 的 \\(1-\\alpha\\) 置信区间为 \\[\\bar{x} \\pm t_{1-\\alpha/2}(n-1)s/\\sqrt{n}\\] 其中，\\(s^2 = \\frac{1}{n-1}\\sum_{i=1}^{n}(x_i - \\bar{x})^2\\) 是 \\(\\sigma^2\\) 的无偏估计。若取 \\(\\alpha = 0.05\\)，则置信水平 \\(1 - \\alpha = 0.95\\)。 set.seed(2020) # 为了可重复，设置随机数种子 mu_ci &lt;- function(alpha = 0.05, n = 100, mu = 4) { x &lt;- rnorm(n = n, mean = mu, sd = 1) x_bar &lt;- mean(x) d &lt;- qt(p = 1 - alpha / 2, df = n - 1, lower.tail = TRUE) * var(x) / sqrt(n) c(mu = mu, lower = x_bar - d, upper = x_bar + d) } # 重抽样 100 次，获得 100 个置信区间 dat &lt;- t(replicate(n = 100, mu_ci(alpha = 0.05, n = 100, mu = 4))) dat &lt;- transform(dat, idx = 1:100, cover = ifelse(mu &gt;= lower &amp; mu &lt;= upper, TRUE, FALSE)) 真实的参数值 \\(\\mu = 4\\)，重抽样 100 次，覆盖真值的次数为 97 次，覆盖概率为 0.97 # 覆盖概率 mean(dat$cover) ## [1] 0.97 library(ggplot2) ggplot() + geom_segment(data = dat, aes( x = idx, xend = idx, y = lower, yend = upper, color = cover )) + geom_hline(yintercept = 4) + theme_minimal() + labs(x = &quot;&quot;, y = &quot;&quot;) 图 19.1: \\(\\mu\\) 的置信水平为 0.95 的置信区间 方差 \\(\\sigma^2\\) 已知的情况下，标准正态分布 \\(N(\\mu, \\sigma^2), \\mu = 0, \\sigma^2 = 1\\) 的参数 \\(\\mu\\) 的区间估计和覆盖概率 https://yihui.org/animation/example/conf-int/ 19.2.2 0-1 分布 设 0-1 分布 \\(B(1, p)\\) 的成功概率 \\(p = 0.95\\)，假定是抛硬币的场景，成功概率对应正面朝上的概率为 0.95。一次实验，重复抛 10 次，有两次正面朝上。现在要根据这次实验结果估计成功概率 \\(p\\) 的值，及其置信区间 # 卡方近似 prop.test(x = 2, n = 10, p = 0.95, conf.level = 0.95, correct = TRUE) ## Warning in prop.test(x = 2, n = 10, p = 0.95, conf.level = 0.95, correct = ## TRUE): Chi-squared approximation may be incorrect ## ## 1-sample proportions test with continuity correction ## ## data: 2 out of 10, null probability 0.95 ## X-squared = 103.16, df = 1, p-value &lt; 2.2e-16 ## alternative hypothesis: true p is not equal to 0.95 ## 95 percent confidence interval: ## 0.03542694 0.55781858 ## sample estimates: ## p ## 0.2 # 二项精确估计 binom.test(x = 2, n = 10, p = 0.95, conf.level = 0.95) ## ## Exact binomial test ## ## data: 2 and 10 ## number of successes = 2, number of trials = 10, p-value = 1.605e-09 ## alternative hypothesis: true probability of success is not equal to 0.95 ## 95 percent confidence interval: ## 0.02521073 0.55609546 ## sample estimates: ## probability of success ## 0.2 可知，在置信水平都是 0.95 的情况下，带连续矫正的单样本比例检验方法获得的区间估计是 (0.0354, 0.5578)， 区间长度 0.5224。精确二项检验方法获得的区间估计是 (0.0252, 0.5560)，区间长度 0.5308。 从二项分布 \\(B(30, 0.2)\\) 中随机抽取一个样本，为可重复记，设置随机数种子为 2020 set.seed(2020) rbinom(1, size = 30, prob = 0.2) ## [1] 7 得到样本观测值为 7， 7 - qnorm(1 - 0.95 / 2) * sqrt(0.2 * 0.8 / 30) # 6.995 ## [1] 6.995421 7 + qnorm(1 - 0.95 / 2) * sqrt(0.2 * 0.8 / 30) # 7.0045 ## [1] 7.004579 样本观测值 7 对应的参数 \\(p\\) 的区间估计，如下 prop.test(x = 7, n = 30, p = 0.2, conf.level = 0.95, correct = TRUE) ## ## 1-sample proportions test with continuity correction ## ## data: 7 out of 30, null probability 0.2 ## X-squared = 0.052083, df = 1, p-value = 0.8195 ## alternative hypothesis: true p is not equal to 0.2 ## 95 percent confidence interval: ## 0.1063502 0.4270023 ## sample estimates: ## p ## 0.2333333 随机变量 \\(X\\) 服从二项分布 \\(B(30, 0.2)\\)，则概率值 \\(P(x \\leq 7) = 0.7607\\) pbinom(7, size = 30, prob = 0.2, lower.tail = TRUE) ## [1] 0.7607906 已知概率值为 0.95， 即 \\(P(x \\leq m) = 0.95\\) 且 \\(X \\sim B(30, 0.2)\\)，现在计算 m 的值，即求下分位点，为 10 qbinom(p = 0.95, size = 30, prob = 0.2, lower.tail = TRUE) ## [1] 10 二项分布的特点，主要用于计算期望，概率 \\(P\\big\\{ C_1 +1\\leq x \\leq C_2 -1 \\big\\}\\) \\[ \\sum_{x = C_1 + 1}^{C_2 -1} x \\binom{n}{x} p^{x}(1-p)^{n-x} = np \\sum_{x = C_1 + 1}^{C_2 -1} \\binom{n -1}{x -1} p^{x -1}(1-p)^{(n -1)-(x-1)} \\] n = 30 c2 = 20 c1 = 10 p = 0.2 n * p * (pbinom(q = c2 - 2, size = n - 1, prob = p) - pbinom(q = c1 - 1, size = n - 1, prob = p)) ## [1] 0.2955803 19.2.3 置信区间和信仰区间 计算置信区间的覆盖概率 binom 二项分布的参数估计，包括点估计和区间估计 (Clopper and Pearson 1934) 给定样本量 n = 10 0-1 分布 成功概率 p 分别取 0.1,0.2,…,1 置信度为 95% 观测到 x 取 1,2,3,..,10 时 估计 p 的上下限 set.seed(2019) x &lt;- rbinom(n = 1, size = 10, prob = 0.1) # 结果解读 抛掷硬币 10 次，观测到2次正面朝上，估计正面朝上的概率 观测到正面朝上 2 次 此时请以 95% 的信心给出 p 的区间 (p_low, p_up) 绘制曲线 p 关于 x 的曲线 set.seed(2019) p &lt;- seq(from = 0, to = 1, length.out = 11) # 成功概率 总体参数 p 值 sapply(rep(p, each = 10), rbinom, n = 1, size = 10) ## [1] 0 0 0 0 0 0 0 0 0 0 2 1 0 1 0 0 2 0 0 1 3 2 1 1 3 ## [26] 2 0 3 1 2 3 3 5 2 1 0 3 5 3 3 5 1 5 3 1 2 3 4 1 5 ## [51] 5 4 7 6 6 5 7 7 4 4 7 8 9 7 6 7 2 4 8 8 8 8 6 8 6 ## [76] 4 8 9 6 7 9 9 9 9 8 4 9 8 9 7 10 8 7 10 9 10 9 9 8 10 ## [101] 10 10 10 10 10 10 10 10 10 10 计算每一次抽样获得的上下限 Clopper-Pearson 方法，即求和搜索，在保持累积概率 \\[B(x,n;n,p) = \\sum_{r = x}^{n} \\binom{n}{r}p^r(1-p)^{n-r} = \\alpha/2\\] 其中 n 表示试验次数，这里是 10， p 是未知待求，已知 \\(\\alpha = 0.05\\)，而 \\(1-\\alpha\\) 表示置信水平，意思是说对于我给出的区间估计，长期来看，我有 95% 的信心认为，真实值 \\(p\\) 会落在此区间内。 对上尾部从 x 到 n 求和，计算 p，对每一个 x 都能计算出一个 p，根据二项分布的对称性，区间 \\([0, x]\\) 和 \\([x,n]\\) 的累积概率是相同的，各占 \\(\\alpha/2\\) # 精确计算二项分布检验的 p # 调用符号计算 # x = 7 fun &lt;- function(p, r = 8, n = 10) { choose(n, n-2)*p^r*(1-p)^(n-r) + choose(n, n-1)*p^(n-1)*(1-p) + choose(n, n)*p^n - 0.025 } uniroot(fun, lower = 0, upper = 1) ## $root ## [1] 0.4439038 ## ## $f.root ## [1] -2.707352e-07 ## ## $iter ## [1] 9 ## ## $init.it ## [1] NA ## ## $estim.prec ## [1] 6.103516e-05 # x = 8 fun &lt;- function(p) { 45*p^8*(1-p)^2 + 10*p^9*(1-p) + p^10 - 0.025 } uniroot(fun, lower = 0, upper = 1) ## $root ## [1] 0.4439038 ## ## $f.root ## [1] -2.707352e-07 ## ## $iter ## [1] 9 ## ## $init.it ## [1] NA ## ## $estim.prec ## [1] 6.103516e-05 # x = 9 fun &lt;- function(x) { 9 * x^10 - 10 * x^9 + 0.025 } # 0.555 计算下限 uniroot(fun, lower = 0, upper = 1) ## $root ## [1] 0.5549828 ## ## $f.root ## [1] 3.773379e-07 ## ## $iter ## [1] 10 ## ## $init.it ## [1] NA ## ## $estim.prec ## [1] 6.462529e-05 # x = 10 fun &lt;- function(x) { x^10 - 0.025 } # 0.691 uniroot(fun, lower = 0, upper = 1) ## $root ## [1] 0.6914996 ## ## $f.root ## [1] -1.194136e-06 ## ## $iter ## [1] 9 ## ## $init.it ## [1] NA ## ## $estim.prec ## [1] 6.103516e-05 累积二项概率 找到最小的 p 使得其等于 9 # 已知概率求上分位点 # 等于 qbinom(0.025, size = 10, prob = 0.565, lower.tail = F) ## [1] 9 找到使得函数为 0 的 p 中最小的那个，找到所有的根，然后取最小的那个 fun &lt;- function(p, r = 9) qbinom(0.025, size = 10, prob = p, lower.tail = F) - r # 计算每个 x 对应的 p (p &lt;- sapply(1:10, function(x) uniroot(fun, lower = 0, upper = 1, r = x)$root)) ## [1] 0.01666667 0.05333333 0.09375000 0.16000000 0.25000000 0.30000000 ## [7] 0.35000000 0.53333333 0.67500000 1.00000000 plot(x = 1:10, y = p) # 二项检验 菱形置信带 set.seed(2019) dat &lt;- replicate(10^3, expr = { x = sample(0:1, size = 10, replace = TRUE, prob = c(0.8, 0.2)) sum(x)/10 }) # 成功概率 p = 0.2 每个样本量 10 dat &lt;- rbinom(n = 10^3, size = 10, prob = 0.2)/10 table(dat) ## dat ## 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 ## 119 274 304 180 82 30 10 1 # 分布图 y 轴是密度 # right = TRUE 区间形式 (a,b] 左开右闭 hist(dat, probability = T, breaks = seq(from = -0.1, to = 1, by = 0.1)) # 0.2^10 左闭右开区间 hist(dat, probability = T, breaks = seq(from = 0, to = 1.1, by = 0.1), right = FALSE, xlim = c(0, 1.1)) # 分布 library(ggplot2) library(magrittr) # 这个图里面会不会隐含什么信息，分布是怎样的？ # 二项展开有关系吗 dat1 &lt;- as.data.frame(table(dat)) ggplot(data = dat1, aes(x = dat, y = Freq)) + geom_col() ggplot(as.data.frame(dat), aes(x = dat)) + geom_histogram(bins = 12) 参考文献 "],["sec-least-angle-regression.html", "19.3 最小角回归", " 19.3 最小角回归 Efron, Bradley and Hastie, Trevor and Johnstone, Iain and Tibshirani, Robert. 2004. Least angle regression. The Annals of Statistics. 32(2): 407–499. https://doi.org/10.1214/009053604000000067. 方差缩减技术，修偏技术 "],["sec-jackknife.html", "19.4 刀切法", " 19.4 刀切法 Efron, B. 1979. Bootstrap Methods: Another Look at the Jackknife. The Annals of Statistics. 7(1):1–26. https://doi.org/10.1214/aos/1176344552 "],["sec-resampling.html", "19.5 重抽样", " 19.5 重抽样 "],["sec-delta-methods.html", "19.6 Delta 方法", " 19.6 Delta 方法 "],["chap-hypothesis-test.html", "第 20 章 假设检验", " 第 20 章 假设检验 The Earth is Round (\\(p &lt; 0.05\\)) — Jacob Cohen (Cohen 1994) x = seq(from = -4, to = 8, length.out = 193) y1 = dnorm(x, mean = 3, sd = 1) y2 = dnorm(x, mean = 2, sd = 1.5) library(magrittr) hline &lt;- function(y = 0, color = &quot;red&quot;) { list( type = &quot;line&quot;, x0 = 0, x1 = 1, xref = &quot;paper&quot;, y0 = y, y1 = y, line = list(color = color, dash = &#39;dash&#39;, width = .5) ) } vline &lt;- function(x = 0, color = &quot;red&quot;) { list( type = &quot;line&quot;, x0 = x, x1 = x, yref = &quot;paper&quot;, y0 = 0, y1 = 1, line = list(color = color, dash = &#39;dash&#39;, width = .5) ) } plotly::plot_ly( x = x, y = y1, type = &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, fillcolor = &quot;rgba(92, 184, 92, 0.2)&quot;, text = ~ paste0( &quot;x：&quot;, x, &quot;&lt;br&gt;&quot;, &quot;y：&quot;, round(y1, 3), &quot;&lt;br&gt;&quot; ), hoverinfo = &quot;text&quot;, name = plotly::TeX(&quot;\\\\mathcal{N}(3,1^2)&quot;), line = list(shape = &quot;spline&quot;, color = &quot;#5CB85C&quot;) ) %&gt;% plotly::add_trace( x = x, y = y2, type = &quot;scatter&quot;, mode = &quot;lines&quot;, fill = &quot;tozeroy&quot;, fillcolor = &quot;rgba(91, 192, 222, 0.2)&quot;, text = ~ paste0( &quot;x：&quot;, x, &quot;&lt;br&gt;&quot;, &quot;y：&quot;, round(y2, 3), &quot;&lt;br&gt;&quot; ), hoverinfo = &quot;text&quot;, name = plotly::TeX(&quot;\\\\mathcal{N}(2, 1.5^2)&quot;), line = list(shape = &quot;spline&quot;, color = &quot;#5BC0DE&quot;) ) %&gt;% plotly::add_segments( x = 2, y = 0.28, xend = 3, yend = 0.28, line = list(color = &quot;black&quot;), showlegend = F ) %&gt;% plotly::add_annotations( x = 2.5, y = 0.3, showarrow = F, font = list(size = 24), text = plotly::TeX(&quot;d&quot;) ) %&gt;% plotly::add_annotations( x = 0, y = 1 / sqrt(2 * pi), font = list(size = 100), showarrow = F, text = plotly::TeX(&quot;\\\\frac{1}{\\\\sqrt{2\\\\pi}}&quot;) ) %&gt;% plotly::add_annotations( x = 0, y = 1 / (1.5 * sqrt(2 * pi)), font = list(size = 100), showarrow = F, text = plotly::TeX(&quot;\\\\frac{1}{1.5\\\\sqrt{2\\\\pi}}&quot;) ) %&gt;% plotly::layout( shapes = list( hline(y = 1 / sqrt(2 * pi), color = &quot;#F27B0C&quot;), hline(y = 1 / (1.5 * sqrt(2 * pi)), color = &quot;#F27B0C&quot;), vline(x = 3, color = &quot;#F27B0C&quot;), vline(x = 2, color = &quot;#F27B0C&quot;) ), xaxis = list(showgrid = F, title = plotly::TeX(&quot;x&quot;)), yaxis = list(showgrid = F, title = plotly::TeX(&quot;f(x)&quot;)), legend = list(x = 0.8, y = 1, orientation = &quot;v&quot;) ) %&gt;% plotly::config(displayModeBar = FALSE, mathjax = &quot;cdn&quot;) 图 20.1: 假设检验 R. A. Fisher 将抽样分布、参数估计和假设检验列为统计推断的三个中心内容，可见假设检验的重要地位 呈现常见检验的公式，将手写代码和 R 内置函数计算结果进行比较，每一组原假设和备择假设要说明对应的 R 函数和及其参数设置，尽量理论和代码并重，最后结合实际的数据予以解释说明。 Jacob Cohen 实际谈的是更加深刻的问题。开篇介绍为什么需要假设检验，做检验和不做检验有什么区别？ 杨灿老师在讨论帖提出检验的作用和实际应用问题 有了均值和方差，为什么还要位置参数和尺度参数？为了更一般地描述问题，扩展范围。 Summary and Analysis of Extension Program Evaluation in R 介绍了各类假设检验方法 The IQUIT R video series 假设检验， 实验 A 和 B 的区分度 适用于在线服务的 A/B 测试方法论 http://www.fengjunchen.com/ 统计分布的检验 从心理学和可视化的角度谈 Cohen’s d Bootstrap 方法和置换/秩检验（Permutation Test）的入门读物 非平衡的 A/B 试验设计 Optimal unbalanced design for A/B test Wilcoxon (WMWU) test sensitivity 检验的灵敏性 从抛硬币到 P 值和统计显著性 一分钟学会 A/B 测试 rstatix 包提供了一个简明的管道友好的框架，和 tidyverse 的设计哲学保持一致，支持常见的统计检验，如 T 检验，Wilcoxon 检验，方差分析，Kruskal-Wallis 检验，相关性分析，并将结果整理成干净的数据框形式，以方便可视化。 参考文献 "],["sec-ansari-test.html", "20.1 Ansari-Bradley 检验 ansari.test", " 20.1 Ansari-Bradley 检验 ansari.test Ansari-Bradley 检验目的是检验两样本的尺度参数是否有显著性差异 尺度参数可以理解为方差 \\(\\sigma^2\\) 位置参数可以理解为均值 \\(\\mu\\) usage(ansari.test) ansari.test(x, ...) usage(&quot;ansari.test.default&quot;) ## Default S3 method: ansari.test(x, y, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), exact = NULL, conf.int = FALSE, conf.level = 0.95, ...) usage(&quot;ansari.test.formula&quot;) ## S3 method for class &#39;formula&#39; ansari.test(formula, data, subset, na.action, ...) "],["sec-bartlett-test.html", "20.2 Bartlett 检验 bartlett.test", " 20.2 Bartlett 检验 bartlett.test ansari.test 和 mood.test 是基于秩的两样本尺度参数显著性差异检验，是非参数检验 Bartlett 检验：检验各个组的方差是否有显著性差异，即方差齐性检验。 var.test 和 bartlett.test 都属于参数检验，用于检验方差齐性问题，前者考虑正态总体下方差齐性检验，后者没有对总体的分布形式做限定。 usage(bartlett.test) bartlett.test(x, ...) usage(&quot;bartlett.test.default&quot;) ## Default S3 method: bartlett.test(x, g, ...) usage(&quot;bartlett.test.formula&quot;) ## S3 method for class &#39;formula&#39; bartlett.test(formula, data, subset, na.action, ...) "],["sec-binom-test.html", "20.3 二项检验 binom.test", " 20.3 二项检验 binom.test 比例 \\(p\\) 的检验， 做 \\(n\\) 次独立试验，样本 \\(X_1,\\ldots,X_n \\sim b(1, p)\\)，事件发生的总次数 \\(\\sum_{i=1}^{n}X_i\\) 函数 binom.test 用来检验伯努利试验中成功概率 \\(p\\) 和给定概率 \\(p_0\\) 的关系，属于精确检验。 编程手动实现一个，再调用函数计算，比较结果 # 模拟一组样本 x &lt;- sample(x = c(0, 1), size = 100, replace = TRUE, prob = c(0.8, 0.2)) 二项分布中成功概率的检验 binom.test(sum(x), n = 100, p = 0.5) ## ## Exact binomial test ## ## data: sum(x) and 100 ## number of successes = 15, number of trials = 100, p-value = 4.825e-13 ## alternative hypothesis: true probability of success is not equal to 0.5 ## 95 percent confidence interval: ## 0.08645439 0.23530750 ## sample estimates: ## probability of success ## 0.15 检验成功概率 p 是否等于 0.5， P 值 \\(6.148 \\times 10^{-11}\\) 结论是拒绝原假设 binom.test(sum(x), n = 100, p = 0.2) ## ## Exact binomial test ## ## data: sum(x) and 100 ## number of successes = 15, number of trials = 100, p-value = 0.2599 ## alternative hypothesis: true probability of success is not equal to 0.2 ## 95 percent confidence interval: ## 0.08645439 0.23530750 ## sample estimates: ## probability of success ## 0.15 检验成功概率 p 是否等于 0.2， P 值 0.7081 结论是不能拒绝原假设 二项检验 (Clopper and Pearson 1934) usage(binom.test) binom.test(x, n, p = 0.5, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), conf.level = 0.95) 参考文献 "],["sec-Box-test.html", "20.4 时间序列独立性检验 Box.test", " 20.4 时间序列独立性检验 Box.test 计算 Box-Pierce 或 Ljung-Box 检验统计量来检查给定时间序列的独立性假设。 usage(Box.test) Box.test(x, lag = 1, type = c(&quot;Box-Pierce&quot;, &quot;Ljung-Box&quot;), fitdf = 0) "],["sec-chisq-test.html", "20.5 皮尔逊卡方检验 chisq.test", " 20.5 皮尔逊卡方检验 chisq.test 用于计数数据的皮尔逊卡方检验：列联表独立性检验和拟合优度检验 chisq.test \\(\\chi^2\\) 检验：列联表检验和拟合优度检验 usage(chisq.test) chisq.test(x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), rescale.p = FALSE, simulate.p.value = FALSE, B = 2000) "],["sec-fisher-test.html", "20.6 费舍尔精确检验 fisher.test", " 20.6 费舍尔精确检验 fisher.test 固定边际的情况下，检验列联表行和列之间的独立性 usage(fisher.test) fisher.test(x, y = NULL, workspace = 2e+05, hybrid = FALSE, hybridPars = c(expect = 5, percent = 80, Emin = 1), control = list(), or = 1, alternative = &quot;two.sided&quot;, conf.int = TRUE, conf.level = 0.95, simulate.p.value = FALSE, B = 2000) "],["sec-fligner-test.html", "20.7 方差齐性检验 fligner.test", " 20.7 方差齐性检验 fligner.test Fligner-Killeen (中位数) 检验各个组的样本方差是不是一致的，也是方差齐性检验 usage(fligner.test) fligner.test(x, ...) usage(&quot;fligner.test.default&quot;) ## Default S3 method: fligner.test(x, g, ...) usage(&quot;fligner.test.formula&quot;) ## S3 method for class &#39;formula&#39; fligner.test(formula, data, subset, na.action, ...) "],["sec-friedman-test.html", "20.8 Friedman 秩和检验 friedman.test", " 20.8 Friedman 秩和检验 friedman.test Friedman 秩和检验 Performs a Friedman rank sum test with unreplicated blocked data. usage(friedman.test) friedman.test(y, ...) usage(&quot;friedman.test.default&quot;) ## Default S3 method: friedman.test(y, groups, blocks, ...) usage(&quot;friedman.test.formula&quot;) ## S3 method for class &#39;formula&#39; friedman.test(formula, data, subset, na.action, ...) "],["sec-kruskal-test.html", "20.9 Kruskal-Wallis 秩和检验 kruskal.test", " 20.9 Kruskal-Wallis 秩和检验 kruskal.test Kruskal-Wallis 秩和检验 usage(kruskal.test) kruskal.test(x, ...) usage(&quot;kruskal.test.default&quot;) ## Default S3 method: kruskal.test(x, g, ...) usage(&quot;kruskal.test.formula&quot;) ## S3 method for class &#39;formula&#39; kruskal.test(formula, data, subset, na.action, ...) "],["sec-ks-test.html", "20.10 同分布检验 ks.test", " 20.10 同分布检验 ks.test Lilliefors 检验32 和单样本的 ks 检验的关系 As to whether you can do a Lilliefors test for several groups, that depends entirely on your ability to understand what the underlying question would be (see Adams D 1979). — Knut M. Wittkowski33 Kolmogorov-Smirnov 检验：单样本或两样本的同分布检验 usage(ks.test) ks.test(x, y, ..., alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), exact = NULL) https://personal.utdallas.edu/~herve/Abdi-Lillie2007-pretty.pdf↩︎ https://stat.ethz.ch/pipermail/r-help/2004-February/045597.html↩︎ "],["sec-mantelhaen-test.html", "20.11 Cochran-Mantel-Haenszel 卡方检验 mantelhaen.test", " 20.11 Cochran-Mantel-Haenszel 卡方检验 mantelhaen.test 用于计数数据的 Cochran-Mantel-Haenszel 卡方检验 Performs a Cochran-Mantel-Haenszel chi-squared test of the null that two nominal variables are conditionally independent in each stratum, assuming that there is no three-way interaction. usage(mantelhaen.test) mantelhaen.test(x, y = NULL, z = NULL, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), correct = TRUE, exact = FALSE, conf.level = 0.95) "],["sec-mauchly-test.html", "20.12 Mauchly 球形检验 mauchly.test", " 20.12 Mauchly 球形检验 mauchly.test 检验：Wishart 分布的协方差矩阵是否正比于给定的矩阵 Mauchly’s Test of Sphericity Tests whether a Wishart-distributed covariance matrix (or transformation thereof) is proportional to a given matrix. usage(mauchly.test) mauchly.test(object, ...) usage(&quot;mauchly.test.mlm&quot;) ## S3 method for class &#39;mlm&#39; mauchly.test(object, ...) usage(&quot;mauchly.test.SSD&quot;) ## S3 method for class &#39;SSD&#39; mauchly.test(object, Sigma = diag(nrow = p), T = Thin.row(proj(M) - proj(X)), M = diag(nrow = p), X = ~0, idata = data.frame(index = seq_len(p)), ...) "],["sec-mcnemar-test.html", "20.13 McNemar 卡方检验 mcnemar.test", " 20.13 McNemar 卡方检验 mcnemar.test 两种统计量的比较 参看谢益辉的博文 渐近理想国：McNemar 检验的两种统计量 用于计数数据的 McNemar’s 卡方检验 McNemar’s \\(\\chi^2\\) 检验：检验二维列联表行和列的对称性 usage(mcnemar.test) mcnemar.test(x, y = NULL, correct = TRUE) "],["sec-mood-test.html", "20.14 Mood 方差检验 mood.test", " 20.14 Mood 方差检验 mood.test 检验方差 Mood’s 两样本检验：检验两样本尺度参数之间的差异性 usage(mood.test) mood.test(x, ...) usage(&quot;mood.test.default&quot;) ## Default S3 method: mood.test(x, y, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), ...) usage(&quot;mood.test.formula&quot;) ## S3 method for class &#39;formula&#39; mood.test(formula, data, subset, na.action, ...) "],["sec-oneway-test.html", "20.15 单因素多重比较 oneway.test", " 20.15 单因素多重比较 oneway.test 单因素方差分析，各个组的方差不一定相同，检验两个及以上来自正态分布的样本是否有相同的均值？ usage(oneway.test) oneway.test(formula, data, subset, na.action, var.equal = FALSE) ## 假定方差不等 oneway.test(extra ~ group, data = sleep) ## ## One-way analysis of means (not assuming equal variances) ## ## data: extra and group ## F = 3.4626, num df = 1.000, denom df = 17.776, p-value = 0.07939 ## 假定方差相等 oneway.test(extra ~ group, data = sleep, var.equal = TRUE) ## ## One-way analysis of means ## ## data: extra and group ## F = 3.4626, num df = 1, denom df = 18, p-value = 0.07919 ## 和线性回归结果一样 anova(lm(extra ~ group, data = sleep)) ## Analysis of Variance Table ## ## Response: extra ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 1 12.482 12.4820 3.4626 0.07919 . ## Residuals 18 64.886 3.6048 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 CO2 数据 # coplot(uptake ~ conc | Plant, data = CO2, show.given = FALSE, type = &quot;b&quot;) # levels(CO2$Plant) # Plant 是有序的 library(ggplot2) library(patchwork) p1 &lt;- ggplot(data = CO2, aes(x = conc, y = uptake)) + geom_point(aes(color = Treatment)) + geom_line(aes(color = Treatment)) + facet_wrap(~Plant, ncol = 4, dir = &quot;v&quot;) p2 &lt;- ggplot(data = CO2, aes(x = conc, y = uptake)) + geom_point(aes(color = Type)) + geom_line(aes(color = Type)) + facet_wrap(~Plant, ncol = 4, dir = &quot;v&quot;) p1 / p2 图 20.2: 草类植物吸收 CO2 "],["sec-pairwise-test.html", "20.16 配对样本的检验", " 20.16 配对样本的检验 配对样本和单样本的等价转化 20.16.1 配对比例检验 pairwise.prop.test 配对数据的比例检验 Pairwise comparisons for proportions Calculate pairwise comparisons between pairs of proportions with correction for multiple testing usage(pairwise.prop.test) pairwise.prop.test(x, n, p.adjust.method = p.adjust.methods, ...) 20.16.2 配对 t 检验 pairwise.t.test Calculate pairwise comparisons between group levels with corrections for multiple testing usage(pairwise.t.test) pairwise.t.test(x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, paired = FALSE, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), ...) 谢益辉以配对组 t 检验谈 Cohen’s d pairwise.t.test(x = sleep$extra, g = sleep$group, paired = T) ## ## Pairwise comparisons using paired t tests ## ## data: sleep$extra and sleep$group ## ## 1 ## 2 0.0028 ## ## P value adjustment method: holm 成对的 t 检验 20.16.3 配对 Wilcoxon 检验 pairwise.wilcox.test Pairwise Wilcoxon Rank Sum Tests 配对的 Wilcoxon 秩和检验 Calculate pairwise comparisons between group levels with corrections for multiple testing. usage(pairwise.wilcox.test) pairwise.wilcox.test(x, g, p.adjust.method = p.adjust.methods, paired = FALSE, ...) 20.16.4 配对样本相关性检验 cor.test 配对样本的相关性检验：Pearson’s 相关系数 Test for association between paired samples, using one of Pearson’s product moment correlation coefficient, Kendall’s \\(\\tau\\) 检验或者 Spearman’s \\(\\rho\\) 检验. usage(cor.test) cor.test(x, ...) Kendall::Kendall (McLeod 2011) SuppDists::pKendall 和 SuppDists::pSpearman (Wheeler 2020) pspearman::spearman.test (Savicky 2014) 参考文献 "],["sec-poisson-test.html", "20.17 精确泊松检验 poisson.test", " 20.17 精确泊松检验 poisson.test 泊松分布是 1837年由法国数学家泊松 (Poisson, 1781-1840) 首次提出 泊松分布的参数 \\(\\lambda (&gt;0)\\) 的精确检验 Performs an exact test of a simple null hypothesis about the rate parameter in Poisson distribution, or for the ratio between two rate parameters. 适用于单样本和两样本 usage(poisson.test) poisson.test(x, T = 1, r = 1, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), conf.level = 0.95) "],["sec-PP-test.html", "20.18 单位根检验 PP.test", " 20.18 单位根检验 PP.test 时间序列平稳性检验 Phillips-Perron 的单位根检验 Computes the Phillips-Perron test for the null hypothesis that x has a unit root against a stationary alternative. usage(PP.test) PP.test(x, lshort = TRUE) "],["sec-prop-test.html", "20.19 比例检验 prop.test", " 20.19 比例检验 prop.test 函数 prop.test 用来检验两组或多组二项分布的成功概率（比例）是否相等，或等于给定的值。近似检验 usage(prop.test) prop.test(x, n, p = NULL, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), conf.level = 0.95, correct = TRUE) 设随机变量 X 服从参数为 \\(p\\) 的二项分布 \\(b(n, p)\\)， \\(Y\\) 服从参数为 \\(\\theta\\) 的二项分布 \\(b(m,\\theta)\\)， \\(m,n\\) 都假定为较大的正整数，检验如下问题 \\[ H_0: P_A \\geq P_B \\quad vs. \\quad H_1: P_A &lt; P_B \\] 根据中心极限定理 \\[ \\frac{\\bar{X} - \\bar{Y}}{\\sqrt{\\frac{p(1-p)}{n} + \\frac{\\theta(1-\\theta)}{m}}} \\] 近似服从标准正态分布 \\(N(0,1)\\)。如果用矩估计 \\(\\bar{X}\\) 和 \\(\\bar{Y}\\) 分别替代总体参数 \\(p\\) 和 \\(\\theta\\)，构造检验统计量 \\[ T = \\frac{\\bar{X} - \\bar{Y}}{\\sqrt{\\frac{\\bar{X}(1-\\bar{X})}{n} + \\frac{\\bar{Y}(1-\\bar{Y})}{m}}} \\] 根据 Slutsky 定理，检验统计量 \\(T\\) 近似服从标准正态分布，当 \\(T\\) 偏大时，拒绝 \\(H_0\\)。该方法的优势在于当 \\(n,m\\) 比较大时，二项分布比较复杂，无法建立统计表，利用标准正态分布表来给出检验所需要的临界值，简便易行！ 当 \\(p\\) 和 \\(\\theta\\) 都比较小，上述方法检验效果不好，原因在于由中心极限定理对 \\(\\bar{X}\\) 和 \\(\\bar{Y}\\) 的正态分布近似效果不好，或者间接地导致 \\(\\bar{X}-\\bar{Y}\\) 的方差偏小，进而 \\(T\\) 的分辨都不好，而且当 \\(p,\\theta\\) 很接近 1 时，上述现象也会产生！ 下面介绍新的解决办法 上面的检验问题等价于 \\[ H_0: \\frac{P_A}{P_B} \\geq 1 \\quad vs. \\quad H_1: \\frac{P_A}{P_B} &lt; 1 \\] 引入检验统计量 \\[ T^{\\star} = \\frac{\\bar{X}}{\\bar{Y}} \\] 同样由 Slutsky 定理和中心极限定理可知， \\(\\bar{X}/\\bar{Y}\\) 近似服从 正态分布\\(N(1,\\frac{1-\\theta}{m\\theta})\\) 当 \\((T^\\star - 1)/\\hat\\sigma\\) 偏大时接受 \\(H_0\\)，临界值可通过 \\(N(0, \\hat\\sigma^2)\\) 分布表计算得到， \\(\\hat\\sigma^2\\) 是对 \\(\\frac{1-\\theta}{m\\theta}\\) 的估计，比如取 \\(\\hat\\sigma^2 = \\frac{1-\\bar{Y}}{m}\\cdot \\frac{1}{\\bar{Y}}\\) 或取 \\(\\hat\\sigma^2 = \\frac{1-\\bar{Y}}{m}\\cdot \\frac{1}{\\bar{X}}\\) 由于渐近方差形如 \\(\\frac{1-\\theta}{m\\theta}\\)，因而在 \\(\\theta\\) 较小，渐近方差较大，克服了之前 \\(\\bar{X} - \\bar{Y}\\)的方差较小的问题 \\(p,\\theta\\) 很接近 1 时，我们取检验统计量 \\[ T^{\\star\\star} = \\frac{1-\\bar{Y}}{1-\\bar{X}} \\] 结论和 \\(T^\\star\\) 类似，当 \\(T^{\\star\\star}\\) 偏大时，拒绝 \\(H_0\\)。 两个二项总体成功概率的比较 (宋泽熙 2011) 20.19.1 两个独立二项总体等价性检验 关于比例的检验问题 \\[\\begin{align} H_0: P_A = P_B \\quad vs. \\quad H_1: P_A &gt; P_B \\\\ H_0: P_A = P_B \\quad vs. \\quad H_1: P_A &lt; P_B \\end{align}\\] \\(H_0\\) 成立的情况下，暗示着两个样本来自同一总体。在这种假设设置下，拒绝原假设是不是意味着接受备择假设？如何判断样本点会落在哪个拒绝域内呢？ 2009 年东南大学韦博成教授将两个独立二项总体的等价性检验应用于《红楼梦》前80回与后40回某些文风差异的统计分析 (韦博成 2009) 20.19.2 不同页面的点击率问题 CTR：点击率 Click Ratio 矩阵 x 第一行表示页面 A 的点击情况，即 1000 次展示有 500 次点击，第二行表示页面 B 的点击情况，即 100 次展示有 80 次点击。通过统计检验的方式比较页面 A 和 B 的点击率哪个更好？ S F A 500 500 B 80 20 (x &lt;- matrix(c(500, 80, 500, 20), nrow = 2, ncol = 2, byrow = FALSE)) ## [,1] [,2] ## [1,] 500 500 ## [2,] 80 20 # 等价于 prop.test(x, alternative = &quot;two.sided&quot;, correct = TRUE) prop.test(x) # 默认参数设置情形是双边检验 ## ## 2-sample test for equality of proportions with continuity correction ## ## data: x ## X-squared = 31.632, df = 1, p-value = 1.863e-08 ## alternative hypothesis: two.sided ## 95 percent confidence interval: ## -0.3898012 -0.2101988 ## sample estimates: ## prop 1 prop 2 ## 0.5 0.8 默认的假设检验问题 \\[ H_0: P_A = P_B \\quad vs. \\quad H_1: P_A \\ne P_B \\] 输出结果中 alternative hypothesis 表示备择假设，参数 alternative 指定备择假设的形式 备择假设 \\(P_A &lt; P_B\\) 对应 prop.test(x, alternative = &quot;less&quot;) ## ## 2-sample test for equality of proportions with continuity correction ## ## data: x ## X-squared = 31.632, df = 1, p-value = 9.315e-09 ## alternative hypothesis: less ## 95 percent confidence interval: ## -1.0000000 -0.2237522 ## sample estimates: ## prop 1 prop 2 ## 0.5 0.8 P 值 \\(9.315\\times 10^{-09}\\) 结论是拒绝原假设，并且接受备择假设，即 \\(P_A &lt; P_B\\)，在原假设成立的情况下，样本落入拒绝域的概率很小，小于 0.05，即在一次实验中，样本不可能落入拒绝域，应当接受原假设，因为将备择假设设为 备择假设 \\(P_A &gt; P_B\\) prop.test(x, alternative = &quot;greater&quot;) ## ## 2-sample test for equality of proportions with continuity correction ## ## data: x ## X-squared = 31.632, df = 1, p-value = 1 ## alternative hypothesis: greater ## 95 percent confidence interval: ## -0.3762478 1.0000000 ## sample estimates: ## prop 1 prop 2 ## 0.5 0.8 P 值为 1 不能拒绝原假设，在原假设成立的情况下，样本落入拒绝域的概率是 1 备择假设和原假设在这里是对立的关系 页面 A 观测到的点击率为 \\(50\\%\\) 页面 B 观测到的点击率为 \\(80\\%\\)，设置检验问题 \\[ H_0: P_A = P_B \\quad vs. \\quad H_1: P_A \\leq P_B \\] 页面点击率 A 等于 B，则备择假设页面点击率 A 不大于 B 默认启用 Yates’ 连续性校正 (continuity correction, 简称 CC) 20.19.3 比例齐性检验 原假设四个组里面病人中吸烟的比例是相同的，备择假设是四个组里面至少有一个组的吸烟比例是不同的 ## Data from Fleiss (1981), p. 139. ## H0: The null hypothesis is that the four populations from which ## the patients were drawn have the same true proportion of smokers. ## A: The alternative is that this proportion is different in at ## least one of the populations. smokers &lt;- c(83, 90, 129, 70) patients &lt;- c(86, 93, 136, 82) prop.test(smokers, patients) ## ## 4-sample test for equality of proportions without continuity ## correction ## ## data: smokers out of patients ## X-squared = 12.6, df = 3, p-value = 0.005585 ## alternative hypothesis: two.sided ## sample estimates: ## prop 1 prop 2 prop 3 prop 4 ## 0.9651163 0.9677419 0.9485294 0.8536585 Wilson 检验统计量 (Wilson 1927) 考虑单样本比例 \\(p\\) 的区间估计问题， Probable Inference (Usual): 可能的推断，或然推断，概率推断 在某个总体中抽取 n 个样本，观测到某个比率/频率 \\(p_0\\)，相应的标准差 \\(\\sigma_0 = (p_0q_0/n)^{1/2}\\)，常见的概率推断表述是说：比率 \\(p\\) 的真值落在区间 \\([p_0 - \\lambda\\sigma_0, p_0 + \\lambda\\sigma_0]\\) 外的概率小于等于 \\(P_\\lambda\\)，并且随着 \\(\\lambda\\) 增大， \\(P_\\lambda\\) 减小。 如果使用 Tchebysheff 切比雪夫准则，我们知道 \\(P_\\lambda\\) 本身小于 \\(1/\\lambda^2\\)，但是如果使用概率表 \\(P_\\lambda\\) 是概率密度曲线与坐标 \\(\\pm\\lambda\\sigma_0\\) 之外的部分围成的面积。尽管切比雪夫准则在估计 \\(P_\\lambda\\) 的时候过于保守，但是概率表给出了一个本质的估计。 严格来说，上面给出的概率推断的表述是简略的。真实概率\\(p\\)落在指定范围之外的机会要么是 0 要么是 1，就是说 \\(p\\) 要么在那个范围要么不在那个范围。观测的比率 \\(p_0\\) 有更大或更小的机会落在真实比率 \\(p\\) 的某个区间。观测者运气不好，观测到一个相对罕见的事件发生了，基于已有的推断理论，他会获得一个相当宽的标记。 Probable Inference (Improved): 一个更好的方式来阐述推理过程： 有某个比率 \\(p\\) 它的标准差是 \\((pq/n)^{1/2} = \\sigma\\)，一个观测糟糕如 \\(p_0\\) 发生的可能性，即 \\(p_0\\) 落在区间 \\([p - \\lambda\\sigma,p + \\lambda\\sigma]\\) 是小于等于 \\(P_\\lambda\\)。 这个表述强调了特殊观测相对于一般典型情况更容易犯的错误。 两样本比例 \\(p\\) 的检验问题。 思路需要推导，考虑如下检验问题 \\[ H_0: P_A \\geq P_B \\quad vs. \\quad H_1: P_A &lt; P_B \\] 比例检验，未知 p 的情况下，且样本量有限，是 t 分布 多种二项检验的办法 (Newcombe 1998) 切比雪夫不等式 Chebyshev, 1821-1894 设随机变量 \\(X\\) 的数学期望和方差都存在，则对任意常数 \\(\\epsilon &gt; 0\\)，有 \\[\\begin{align} P(|X - EX| \\geq \\epsilon) &amp; \\leq \\frac{Var(X)}{\\epsilon^2} \\\\ P(|X - EX| \\leq \\epsilon) &amp; \\geq 1 - \\frac{Var(X)}{\\epsilon^2} \\end{align}\\] 参考文献 "],["sec-prop-trend-test.html", "20.20 比例趋势检验 prop.trend.test", " 20.20 比例趋势检验 prop.trend.test Performs \\(\\chi^2\\) test for trend in proportions, i.e., a test asymptotically optimal for local alternatives where the log odds vary in proportion with score. By default, score is chosen as the group numbers. usage(prop.trend.test) prop.trend.test(x, n, score = seq_along(x)) "],["sec-quade-test.html", "20.21 Quade 检验 quade.test", " 20.21 Quade 检验 quade.test Quade Test Performs a Quade test with unreplicated blocked data. usage(quade.test) quade.test(y, ...) usage(&quot;quade.test.default&quot;) ## Default S3 method: quade.test(y, groups, blocks, ...) usage(&quot;quade.test.formula&quot;) ## S3 method for class &#39;formula&#39; quade.test(formula, data, subset, na.action, ...) "],["sec-shapiro-test.html", "20.22 正态性检验 shapiro.test", " 20.22 正态性检验 shapiro.test Usually (but not always) doing tests of normality reflect a lack of understanding of the power of rank tests, and an assumption of high power for the tests (qq plots don’t always help with that because of their subjectivity). When possible it’s good to choose a robust method. Also, doing pre-testing for normality can affect the type I error of the overall analysis. — Frank Harrell34 检验：拒绝原假设和接受原假设的风险，数据本身和理论的正态分布的距离，抛开 P 值 Shapiro 和 Wilk’s 提出的 W 检验 Performs the Shapiro-Wilk test of normality. usage(shapiro.test) shapiro.test(x) https://stat.ethz.ch/pipermail/r-help/2005-April/070508.html↩︎ "],["sec-ep-test.html", "20.23 正态性检验 Epps-Pully 检验", " 20.23 正态性检验 Epps-Pully 检验 The issue really comes down to the fact that the questions: “exactly normal?” and “normal enough?” are 2 very different questions (with the difference becoming greater with increased sample size) and while the first is the easier to answer, the second is generally the more useful one. — Greg Snow35 EP 检验对多种备择假设有较高的效率，利用样本的特征函数和正态分布的特征函数的差的模的平方产生的一个加权积分得到 EP 检验统计量 (Epps and Pulley 1983) 样本量 \\(n \\geq 200\\) EP 检验统计量 \\(T_{EP}\\) 非常接近 \\(n = \\infty\\) 时 \\(T_{EP}\\) 的分位数。 设 \\(x_1, \\ldots, x_n\\) 是来自正态总体 \\(N(\\mu,\\sigma^2)\\) 的样本， EP 检验统计量定义为 \\[ T_{EP} = 1 + \\frac{n}{\\sqrt{3}} + \\frac{2}{n}\\sum_{i=2}^{n}\\sum_{j=1}^{i-1}\\exp\\big\\{ - \\frac{(x_j - x_i)^2}{2s^2_{\\star}} \\big\\} - \\sqrt{2} \\sum_{i=1}^{n}\\exp\\big\\{- \\frac{(x_i - \\bar{x})^2}{4s^2_{\\star}} \\big\\} \\] 其中 \\(\\bar{x},s^2_{\\star}\\) 就是样本均值和（除以 \\(n\\) 的）样本方差 几个正态性检验的功效比较 https://arxiv.org/ftp/arxiv/papers/1605/1605.06293.pdf 和 PoweR 包 (Lafaye de Micheaux and Tran 2016) 参考文献 "],["sec-t-test.html", "20.24 学生 t 检验 t.test", " 20.24 学生 t 检验 t.test t 分布的推导、 t 分布的形式 两样本的均值检验到 Behrens-Fisher 问题到大规模推荐系统中的 A/B 检验 20.24.1 正态总体两样本的均值之差的检验 常见检验问题 \\[\\begin{align} \\mathrm{I} \\quad H_0: \\mu_1 - \\mu_2 \\leq 0 \\quad vs. \\quad H_1: \\mu_1 - \\mu_2 &gt; 0 \\\\ \\mathrm{II} \\quad H_0: \\mu_1 - \\mu_2 \\geq 0 \\quad vs. \\quad H_1: \\mu_1 - \\mu_2 &lt; 0 \\\\ \\mathrm{III} \\quad H_0: \\mu_1 - \\mu_2 = 0 \\quad vs. \\quad H_1: \\mu_1 - \\mu_2 \\neq 0 \\end{align}\\] 20.24.1.1 方差 \\(\\sigma^2_1,\\sigma^2_2\\) 已知 检验统计量服从标准正态分布 set.seed(2019) x1 &lt;- rnorm(100, mean = 10, sd = 2.5) y1 &lt;- rnorm(80, mean = 6, sd = 4.5) u0 &lt;- (mean(x1) - mean(y1)) / sqrt(2.5^2 / 100 + 4.5^2 / 80) \\[ u = \\frac{(\\bar{X} - \\bar{Y}) - (\\mu_1 - \\mu_2)}{\\sqrt{\\frac{\\sigma^2_1}{m} + \\frac{\\sigma^2_2}{n}} } \\] \\(u \\sim N(0,1)\\)，检验统计量 \\(u\\) 对应的样本值 \\(u_0\\)，检验的拒绝域和 \\(P\\) 值如下 \\[ W_1 = \\{u \\geq u_{1 - \\alpha} \\}, \\quad p_1 = 1 - \\varPhi(u_0) \\] 对检验问题 I，给定显著性水平 \\(\\alpha = 0.05\\)，得出拒绝域 \\(\\{ u \\geq 1.645\\}\\)，计算样本观察值得到的检验统计量的值 \\(u_0 = 7.946\\)，而该值落在拒绝域，所以拒绝原假设，即拒绝 \\(\\mu_1 - \\mu_2 \\leq 0\\)，则接受 \\(\\mu_1 - \\mu_2 &gt; 0\\)。 # 计算拒绝域 qnorm(1 - 0.05) ## [1] 1.644854 # 计算 P 值 1 - pnorm(u0) ## [1] 9.992007e-16 20.24.1.2 方差 \\(\\sigma^2_1 = \\sigma^2_2 = \\sigma^2\\) 未知 检验统计量服从自由度为 \\(m + n - 2\\) 的 t 分布 set.seed(2019) x1 &lt;- rnorm(100, mean = 10, sd = 4.5) y1 &lt;- rnorm(80, mean = 6, sd = 4.5) s_w &lt;- sqrt(1 / (100 + 80 - 2) * ((100 - 1) * var(x1) + (80 - 1) * var(y1))) t0 &lt;- (mean(x1) - mean(y1)) / (s_w * sqrt(1 / 100 + 1 / 80)) 样本观察值 \\(t_0 = 6.6816 &gt; t_{0.95}(100 + 80 -2) = 1.653\\) 落在拒绝域内，对于检验问题 I 我们要拒绝原假设 # 临界值：0.95 分位点对应的分位数 qt(1 - 0.05, df = 100 + 80 - 2) ## [1] 1.653459 # p 值 1 - pt(t0, df = 100 + 80 - 2, lower.tail = TRUE) ## [1] 1.461666e-10 利用 R 内置的 t.test() 函数计算 t.test(x = x1, y = y1, alternative = &quot;greater&quot;, var.equal = TRUE) ## ## Two Sample t-test ## ## data: x1 and y1 ## t = 6.6816, df = 178, p-value = 1.462e-10 ## alternative hypothesis: true difference in means is greater than 0 ## 95 percent confidence interval: ## 3.249227 Inf ## sample estimates: ## mean of x mean of y ## 9.669997 5.352296 与线性回归比较 dat &lt;- data.frame( value = c(x1, y1), group = c(rep(&quot;x1&quot;, length(x1)), rep(&quot;y1&quot;, length(y1))) ) fit &lt;- lm(value ~ 1 + I(group == &quot;y1&quot;), data = dat) # fit &lt;- lm(value ~ 0 + I(group == &quot;y1&quot;), data = dat) # 无截距项 summary(fit) ## ## Call: ## lm(formula = value ~ 1 + I(group == &quot;y1&quot;), data = dat) ## ## Residuals: ## Min 1Q Median 3Q Max ## -11.2282 -3.0198 -0.2959 3.0161 12.1921 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9.6700 0.4308 22.446 &lt; 2e-16 *** ## I(group == &quot;y1&quot;)TRUE -4.3177 0.6462 -6.682 2.92e-10 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 4.308 on 178 degrees of freedom ## Multiple R-squared: 0.2005, Adjusted R-squared: 0.196 ## F-statistic: 44.64 on 1 and 178 DF, p-value: 2.923e-10 lm 回归和 t 检验的差别，回归系数第二行， t 统计量为 -6.682，P 值为 2.92e-10，前者是因为截距项，后者是因为双边检验（模型系数显著性检验是和0比较），所以有2倍的关系。直观解释详见 翻译：常见统计检验的本质都是线性模型（或：如何教统计学） 两样本方差不齐、样本量严重不等，在大样本和小样本情况下的比较， t 检验方差不齐有多重要 20.24.1.3 方差 \\(\\sigma^2_1 / \\sigma^2_2\\) 已知 方差比 \\(c = \\sigma^2_1 / \\sigma^2_2\\) 已知 20.24.1.4 方差 \\(\\sigma^2_1 / \\sigma^2_2\\) 未知 英国统计学家 William Sealy Gosset (1876-1937) 于 1908 年在杂志 《Biometrics》 上以笔名 Student 发表论文《The probable error of a mean》(\"Student\" 1908)，论文中展示了独立同正态分布的样本 \\(x_1, \\ldots, x_n \\stackrel{i.i.d}{\\sim} \\mathcal{N}(\\mu,\\sigma^2)\\) 的样本方差 \\(s^2\\) 和样本标准差 \\(s\\) 的抽样分布，根据均值和标准差不相关的性质导出 t 分布，宣告 t 分布的诞生，因其在小样本领域的突出贡献，W. S. Gosset 进入世纪名人录 (Heyde et al. 2001) \\[\\frac{(n-1)s^2}{\\sigma^2} \\sim \\chi^2(n-1)\\] \\[\\frac{\\bar{x} - \\mu}{s/\\sqrt{n}} \\sim t(n-1)\\] \\[E(s^2) = \\sigma^2, \\quad Var(s^2) = \\frac{2\\sigma^4}{n-1}\\] 两样本的样本量很大，总体方差未知，检验两样本均值的显著性检验，极限分布是正态，\\(u\\) 检验 两个样本的样本量不是很大，总体方差也未知，检验两样本均值的显著性检验，即著名的 Behrens-Fisher 问题，Welsh 在 1938 年提出近似服从自由度为 \\(\\ell\\) 的 t 分布。 Egon Pearson 接过他父亲 Karl Pearson 的职位，担任伦敦大学学院的高尔顿统计教授 许宝騄在 Jerzy Neyman 和 Egon Pearson 主编的杂志《Statistical Research Memoirs》发表第一篇关于 Behrens-Fisher 问题的论文 这里提及许宝騄（Pao-Lu Hsu）的贡献 (HSU 1938)， 陈家鼎和郑忠国一起整理了许宝騄的生平事迹和学术成就，见《许宝騄先生的生平和学术成就》。 1998 年关于 Behrens-Fisher 问题的综述 (Kim and Cohen 1998) 钟开涞（Kai-Lai Chung）将许宝騄的论文集整理出版 (HSU 1983) t.test() 提供单样本和两样本的检验 usage(t.test) ## S3 method for class &#39;test&#39; t(x, ...) usage(&quot;t.test.default&quot;) ## Default S3 method: t.test(x, y = NULL, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), mu = 0, paired = FALSE, var.equal = FALSE, conf.level = 0.95, ...) usage(&quot;t.test.formula&quot;) ## S3 method for class &#39;formula&#39; t.test(formula, data, subset, na.action, ...) 学生睡眠数据 sleep 见图 20.3 图 20.3: 学生睡眠数据 sleep 两个样本的 Welch’s t 检验，总体方差未知，样本量也不大，两样本均值差的显著性检验 ## 等价于 with(sleep, t.test(extra[group == 1], extra[group == 2])) t.test(extra ~ group, data = sleep) ## ## Welch Two Sample t-test ## ## data: extra by group ## t = -1.8608, df = 17.776, p-value = 0.07939 ## alternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0 ## 95 percent confidence interval: ## -3.3654832 0.2054832 ## sample estimates: ## mean in group 1 mean in group 2 ## 0.75 2.33 实际上睡眠数据是配对的，我们可以做配对数据的检验 ## 数据变形操作，长格式变为宽格式 sleep2 &lt;- reshape(sleep, direction = &quot;wide&quot;, idvar = &quot;ID&quot;, timevar = &quot;group&quot; ) # R 4.0.0 t.test(Pair(extra.1, extra.2) ~ 1, data = sleep2) ## ## Paired t-test ## ## data: Pair(extra.1, extra.2) ## t = -4.0621, df = 9, p-value = 0.002833 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -2.4598858 -0.7001142 ## sample estimates: ## mean of the differences ## -1.58 函数 t.test() 和 wilcox.test() 的公式接口要求 R 版本在 4.0.0 及以上 参考文献 "],["sec-var-test.html", "20.25 方差比检验 var.test", " 20.25 方差比检验 var.test TeachingDemos 的 sigma.test() 方差检验，适用于正态总体，它对非正态性很敏感。 F 检验：来自正态总体的两个样本的方差比较 usage(var.test) var.test(x, ...) usage(&quot;var.test.default&quot;) ## Default S3 method: var.test(x, y, ratio = 1, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), conf.level = 0.95, ...) usage(&quot;var.test.formula&quot;) ## S3 method for class &#39;formula&#39; var.test(formula, data, subset, na.action, ...) "],["sec-wilcox-test.html", "20.26 Wilcoxon 秩和检验 wilcox.test", " 20.26 Wilcoxon 秩和检验 wilcox.test 单样本 Wilcoxon 秩和检验，两样本 Wilcoxon 符号秩检验，也叫 Mann-Whitney 检验 Wilcoxon Rank Sum and Signed Rank Tests Performs one- and two-sample Wilcoxon tests on vectors of data; the latter is also known as ‘Mann-Whitney’ test. usage(wilcox.test) wilcox.test(x, ...) usage(&quot;wilcox.test.default&quot;) ## Default S3 method: wilcox.test(x, y = NULL, alternative = c(&quot;two.sided&quot;, &quot;less&quot;, &quot;greater&quot;), mu = 0, paired = FALSE, exact = NULL, correct = TRUE, conf.int = FALSE, conf.level = 0.95, tol.root = 1e-04, digits.rank = Inf, ...) usage(&quot;wilcox.test.formula&quot;) ## S3 method for class &#39;formula&#39; wilcox.test(formula, data, subset, na.action, ...) coin::wilcox_test for exact, asymptotic and Monte Carlo conditional p-values, including in the presence of ties. coin 包 (Hothorn et al. 2008) 提供大量基于秩的检验 20.26.1 ROC 曲线和 wilcox.test 检验的关系 https://github.com/xrobin/pROC/wiki/FAQ---Frequently-asked-questions#can-i-test-if-a-single-roc-curve-is-significantly-different-from-05 ROC 曲线越往左上角拱越好， AUC 是 ROC 曲线下的面积，所以 AUC 指标越接近 1 越好。 对每个标签的预测概率指定服从均匀分布，相当于随机猜测，所以最后 ROC 会接近对角线，而且样本量越大越接近，AUC 会越来越接近 0.5 再往深一点就是研究一下 R 内置的排序算法，因为计算 AUC 最核心的步骤是排序。 order 函数默认的排序方法是 auto 即当数据量较小的时候，自动选择 radix 排序，当数据量比较大的时候，自动选择 shell 排序36 # 模拟一些数据 set.seed(2019) # 设置随机数种子 N &lt;- 10^5 # 样本量 sim_dat &lt;- cbind.data.frame( pred = runif(N), label = rbinom(N, size = 1, prob = 0.95) ) # 计算 auc 的函数 # dat is a data.frame as input return AUC value comp_auc &lt;- function(dat, show_roc = TRUE) { # order label by predicted probability dat &lt;- dat[order(dat$pred, dat$label, decreasing = TRUE), ] # total samples n_total &lt;- length(dat$label) # number of positive label 1 n_pos &lt;- sum(dat$label) # number of negative label 0 n_neg &lt;- n_total - n_pos # calculate TPR and FPR tpr &lt;- cumsum(dat$label) / n_pos fpr &lt;- (1:n_total - cumsum(dat$label)) / n_neg # calculate auc auc &lt;- 0 for (i in 1:(n_total - 1)) { auc &lt;- auc + (fpr[i + 1] - fpr[i]) * tpr[i] } # show ROC curve or not? if (show_roc) { plot(fpr, tpr, type = &quot;l&quot;) } auc } comp_auc(dat = sim_dat, show_roc = FALSE) ## [1] 0.5015558 模拟一个逻辑回归模型测试自编 AUC 计算程序和 R 包 pROC 计算结果 set.seed(2018) N &lt;- 10^4 # 样本量 x &lt;- rnorm(N) beta_0 &lt;- 0.5 beta_1 &lt;- 0.3 eta &lt;- beta_0 + beta_1 * x # 模拟数据集 dat &lt;- data.frame(x = x, y = rbinom(N, 1, prob = exp(eta) / (1 + exp(eta)))) # 数据集分隔 is_train &lt;- sample(1:nrow(dat), N * 0.7) train &lt;- dat[is_train, ] test &lt;- dat[-is_train, ] # 模型拟合 fit &lt;- glm(y ~ x, data = train, family = binomial(link = &quot;logit&quot;)) # 预测 y_pred &lt;- predict(fit, newdata = test, type = &quot;response&quot;) dat2 &lt;- data.frame(pred = y_pred, label = test$y) # 计算 auc comp_auc(dat = dat2, show_roc = FALSE) ## [1] 0.5850287 对比 R 包 pROC 的计算结果是一致的 pROC::auc(test$y, y_pred) 计算一下运行时间 # 100 万样本 system.time(comp_auc(dat = dat2, show_roc = FALSE)) ## user system elapsed ## 0.002 0.000 0.002 更多关于 auc 计算的讨论见统计之都论坛帖 https://d.cosx.org/d/419436，我感觉这个问题最后会归结到排序问题。 # https://stat.ethz.ch/pipermail/r-help/2005-April/069217.html trap.rule &lt;- function(x, y) sum(diff(x) * (y[-1] + y[-length(y)])) / 2 参考文献 "],["sec-three-plus-one-tests.html", "20.27 3 + 1 统计检验", " 20.27 3 + 1 统计检验 Wald 检验，似然比检验/ Wilks 检验，得分检验/Rao 检验，梯度检验 Unfortunately, this is one of those situations where as far as I can tell all of the real statisticians are out there playing with large data sets where the small-sample corrections are not so important and leaving the rest of us to figure it out for ourselves … — Ben Bolker37 https://stat.ethz.ch/pipermail/r-sig-mixed-models/2011q4/017392.html↩︎ "],["sec-classical-case-study.html", "20.28 经典案例", " 20.28 经典案例 20.28.1 1973 年加州大学伯克利分校的学生招生 录取人数按院系和性别分类统计，研究目标是各个院系在录取学生的时候是否有性别歧视？统计数据见表 20.1 as.data.frame(UCBAdmissions) %&gt;% reshape(., v.names = &quot;Freq&quot;, idvar = c(&quot;Admit&quot;, &quot;Gender&quot;), timevar = &quot;Dept&quot;, direction = &quot;wide&quot;, sep = &quot;&quot; ) %&gt;% knitr::kable(., caption = &quot;伯克利大学各个院系的录取人数&quot;, row.names = FALSE, col.names = gsub(&quot;(Freq)&quot;, &quot;Dept&quot;, names(.)), align = &quot;c&quot; ) 表 20.1: 伯克利大学各个院系的录取人数 Admit Gender DeptA DeptB DeptC DeptD DeptE DeptF Admitted Male 512 353 120 138 53 22 Rejected Male 313 207 205 279 138 351 Admitted Female 89 17 202 131 94 24 Rejected Female 19 8 391 244 299 317 # plot(UCBAdmissions, col = &quot;lightblue&quot;, border = &quot;white&quot;) library(ggmosaic) ggplot(data = as.data.frame(UCBAdmissions)) + geom_mosaic(aes(weight = Freq, x = product(Gender, Admit), fill = Dept)) + coord_flip() + theme_minimal() + labs(x = &quot;Admit&quot;, y = &quot;Gender&quot;) 图 8.29: UCBAdmissions 马赛克图 20.28.2 1976~1977年美国佛罗里达州的凶杀案件中被告肤色和死刑判决的关系 被告 被害人 判死 不判死 白人 白人 19 132 黑人 0 9 黑人 白人 11 32 黑人 6 97 20.28.3 统计专业学生的头发和眼睛的颜色 HairEyeColor 是一个 table 类型的数据对象，和数组的关系 array class(HairEyeColor) ## [1] &quot;table&quot; str(HairEyeColor) ## &#39;table&#39; num [1:4, 1:4, 1:2] 32 53 10 3 11 50 10 30 10 25 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ Hair: chr [1:4] &quot;Black&quot; &quot;Brown&quot; &quot;Red&quot; &quot;Blond&quot; ## ..$ Eye : chr [1:4] &quot;Brown&quot; &quot;Blue&quot; &quot;Hazel&quot; &quot;Green&quot; ## ..$ Sex : chr [1:2] &quot;Male&quot; &quot;Female&quot; apply(HairEyeColor, c(1, 2), sum) ## Eye ## Hair Brown Blue Hazel Green ## Black 68 20 15 5 ## Brown 119 84 54 29 ## Red 26 17 14 14 ## Blond 7 94 10 16 # plot(HairEyeColor, col = &quot;lightblue&quot;, border = &quot;white&quot;) library(ggmosaic) ggplot(data = as.data.frame(HairEyeColor)) + geom_mosaic(aes(weight = Freq, x = product(Hair, Eye), fill = Sex)) + theme_minimal() + labs(x = &quot;Hair&quot;, y = &quot;Eye&quot;) 图 20.4: 头发、眼睛颜色和性别的比例 "],["sec-hypothesis-test-session.html", "20.29 运行环境", " 20.29 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggmosaic_0.3.3 patchwork_1.1.1 ggplot2_3.3.5 magrittr_2.0.1 ## [5] formatR_1.11 ## ## loaded via a namespace (and not attached): ## [1] tidyselect_1.1.1 xfun_0.24 bslib_0.2.5.1 purrr_0.3.4 ## [5] colorspace_2.0-2 vctrs_0.3.8 generics_0.1.0 htmltools_0.5.1.1 ## [9] viridisLite_0.4.0 yaml_2.2.1 utf8_1.2.1 plotly_4.9.4.1 ## [13] rlang_0.4.11 jquerylib_0.1.4 pillar_1.6.1 glue_1.4.2 ## [17] withr_2.4.2 DBI_1.1.1 plyr_1.8.6 lifecycle_1.0.0 ## [21] stringr_1.4.0 munsell_0.5.0 gtable_0.3.0 htmlwidgets_1.5.3 ## [25] evaluate_0.14 labeling_0.4.2 knitr_1.33 crosstalk_1.1.1 ## [29] fansi_0.5.0 highr_0.9 Rcpp_1.0.7 scales_1.1.1 ## [33] jsonlite_1.7.2 farver_2.1.0 digest_0.6.27 stringi_1.7.3 ## [37] bookdown_0.22 dplyr_1.0.7 ggrepel_0.9.1 grid_4.1.0 ## [41] tools_4.1.0 sass_0.4.0 productplots_0.1.1 lazyeval_0.2.2 ## [45] tibble_3.1.2 crayon_1.4.1 tidyr_1.1.3 pkgconfig_2.0.3 ## [49] ellipsis_0.3.2 data.table_1.14.0 assertthat_0.2.1 rmarkdown_2.9 ## [53] httr_1.4.2 R6_2.5.0 compiler_4.1.0 "],["chap-power-Analysis.html", "第 21 章 功效分析", " 第 21 章 功效分析 CRAN 上有很多功效计算和分析的 R 包，我们针对不同的混合效应模型和统计检验，提供对应的 R 实现。 MKpower 包提供 Welch 和 Hsu（许宝騄）t 检验、Wilcoxon 秩和检验、符号秩检验的功效分析和样本量计算，经验功效和第一类错误的计算方法是蒙特卡罗模拟。Superpower 基于模拟的方法分析三因素方差分析实验设计的功效，开发者写了本书介绍，详见 https://aaroncaldwell.us/SuperpowerBook/，也开发了两个 Shiny 应用。powerlmm 可用于计算两、三个水平的纵向多水平/线性混合效应模型的功效。pwrAB Welch 两样本 t 检验的功效分析，常用于 A/B 测试。Metin Bulus 开发 PowerUpR 计算响应变量是连续型的多水平随机对照实验统计功效，最小可检测的效应大小，最小样本量要求。simr 通过模拟方法分析广义线性混合效应模型的功效。WebPower 提供相关性、比例、t 检验、单因素方差分析、两因素方差分析、线性回归、逻辑回归、泊松回归、纵向数据分析、结构方程模型和多水平模型等的功效分析，详见网站 https://webpower.psychstat.org/，包含书籍和功效分析的工具。PowerAnalysisIL 功效分析的 shiny 应用 http://daniellakens.blogspot.com/2015/01/always-use-welchs-t-test-instead-of.html。 此外，还有 lmerTest (Kuznetsova, Brockhoff, and Christensen 2017) 和 lmtest (Zeileis and Hothorn 2002)。 试验设计 (茆诗松, 周纪芗, and 陈颖 2004) 可以视为一种组织形式，包括各类检验， R 语言实战 (Kabacoff 2015) 作者 Robert I. Kabacoff 创建了网站 Quick-R，实战这本书第 10 章功效分析主要基于 pwr 包来介绍，Jacob Cohen 的著作《Statistical Power Analysis for the Behavioral Sciences》第二版 (Cohen 1988) https://powerandsamplesize.com/ 功效和样本量计算器 library(pwr) library(Matrix) library(lme4) pbkrtest 提供 parametric bootstrap test、Kenward-Roger-type F-test、Satterthwaite-type F-test 用于线性混合效应模型，parametric bootstrap test 用于广义线性混合效应模型 参考文献 "],["sec-power-anova-test.html", "21.1 方差分析检验的功效", " 21.1 方差分析检验的功效 power.anova.test() 计算平衡的单因素方差分析检验的功效 usage(power.anova.test) power.anova.test(groups = NULL, n = NULL, between.var = NULL, within.var = NULL, sig.level = 0.05, power = NULL) power.anova.test( groups = 4, # 4 个组 between.var = 1, # 组间方差为 1 within.var = 3, # 组内方差为 3 power = 0.95 # 1 - 犯第二类错误的概率 ) ## ## Balanced one-way analysis of variance power calculation ## ## groups = 4 ## n = 18.18245 ## between.var = 1 ## within.var = 3 ## sig.level = 0.05 ## power = 0.95 ## ## NOTE: n is number in each group "],["sec-power-prop-test.html", "21.2 比例检验的功效", " 21.2 比例检验的功效 power.prop.test() 计算两样本比例检验的功效 usage(power.prop.test) power.prop.test(n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, alternative = c(&quot;two.sided&quot;, &quot;one.sided&quot;), strict = FALSE, tol = .Machine$double.eps^0.25) 功效可以用来计算实验所需要的样本量，检验统计量的功效越大/高，检验方法越好，实验所需要的样本量越少 # p1 &gt;= p2 的检验 单边和双边检验 power.prop.test( p1 = .65, p2 = 0.6, sig.level = .05, power = 0.90, alternative = &quot;one.sided&quot; ) ## ## Two-sample comparison of proportions power calculation ## ## n = 1603.846 ## p1 = 0.65 ## p2 = 0.6 ## sig.level = 0.05 ## power = 0.9 ## alternative = one.sided ## ## NOTE: n is number in *each* group power.prop.test( p1 = .65, p2 = 0.6, sig.level = .05, power = 0.90, alternative = &quot;two.sided&quot; ) ## ## Two-sample comparison of proportions power calculation ## ## n = 1968.064 ## p1 = 0.65 ## p2 = 0.6 ## sig.level = 0.05 ## power = 0.9 ## alternative = two.sided ## ## NOTE: n is number in *each* group pwr 包 pwr.2p.test() 函数提供了类似 power.prop.test() 函数的功能 library(pwr) # 明确 p1 &gt; p2 的检验 # 单边检验拆分更加明细，分为大于和小于 pwr.2p.test( h = ES.h(p1 = 0.65, p2 = 0.6), sig.level = 0.05, power = 0.9, alternative = &quot;greater&quot; ) ## ## Difference of proportion power calculation for binomial distribution (arcsine transformation) ## ## h = 0.1033347 ## n = 1604.007 ## sig.level = 0.05 ## power = 0.9 ## alternative = greater ## ## NOTE: same sample sizes 已知两样本的样本量不等，检验 H0: \\(p_1 = p_2\\) H1: \\(p_1 \\neq p_2\\) 的功效 library(pwr) pwr.2p2n.test( h = 0.30, n1 = 80, n2 = 245, sig.level = 0.05, alternative = &quot;greater&quot; ) ## ## difference of proportion power calculation for binomial distribution (arcsine transformation) ## ## h = 0.3 ## n1 = 80 ## n2 = 245 ## sig.level = 0.05 ## power = 0.7532924 ## alternative = greater ## ## NOTE: different sample sizes h 表示两个样本的差异，计算得到的功效是 0.75 "],["sec-power-t-test.html", "21.3 t 检验的功效", " 21.3 t 检验的功效 power.t.test() 计算单样本或两样本的 t 检验的功效，或者根据功效计算参数，如样本量 Cohen’s d 单样本/配对 t 检验的功效分析 n = 30 # 样本量（只是一个例子） x = seq(0, 12, 0.01) library(ggplot2) dat &lt;- data.frame(xx = x/sqrt(n), yy = 2 * (1 - pt(x, n - 1))) ggplot(data = dat, aes(x = xx, y = yy)) + geom_line() + geom_vline(xintercept = c(0.01, 0.2, 0.5, 0.8, 1.2, 2), linetype = 2) + theme_minimal() + labs(x = &quot;d = t / sqrt(n)&quot;, y = &quot;2 * (1 - pt(x, n - 1))&quot;) 图 21.1: t 检验的功效 usage(power.t.test) power.t.test(n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, type = c(&quot;two.sample&quot;, &quot;one.sample&quot;, &quot;paired&quot;), alternative = c(&quot;two.sided&quot;, &quot;one.sided&quot;), strict = FALSE, tol = .Machine$double.eps^0.25) power.t.test( n = 100, delta = 2.2, sd = 1, sig.level = 0.05, type = &quot;two.sample&quot;, alternative = &quot;two.sided&quot; ) ## ## Two-sample t test power calculation ## ## n = 100 ## delta = 2.2 ## sd = 1 ## sig.level = 0.05 ## power = 1 ## alternative = two.sided ## ## NOTE: n is number in *each* group 表 21.1: 函数 power.t.test() 的参数表 参数 含义 n 每个组的样本量 delta 两个组的均值之差 sd 标准差，默认值 1 sig.level 显著性水平，默认是 0.05 （犯第 I 类错误的概率） power 检验的功效（1 - 犯第 II 类错误的概率） type t 检验的类型 \"two.sample\" 两样本、\"one.sample\" 单样本或 \"paired\" 配对样本 alternative 单边或双边检验，取值为 \"two.sided\" 或 \"one.sided\" 参数 n，delta，power，sd 和 sig.level 必须有一个值为 NULL，为 NULL 的参数是由其它参数决定的。 Jacob Cohen 提出的 Cohen’s d 和 Cohen’s f 详见书籍 (Cohen 1988)，他的代表性文章，地球是圆的 (Cohen 1994) # 前面 t 检验和方差分析检验的等价功效计算 library(pwr) pwr.t.test( d = 2.2 / 6.4, n = 100, sig.level = 0.05, type = &quot;two.sample&quot;, alternative = &quot;two.sided&quot; ) ## ## Two-sample t test power calculation ## ## n = 100 ## d = 0.34375 ## sig.level = 0.05 ## power = 0.6768572 ## alternative = two.sided ## ## NOTE: n is number in *each* group # f 是如何和上面的组间/组内方差等价指定的 pwr.anova.test( k = 4, # 组数 f = 0.5, power = 0.95 # 检验的效 ) ## ## Balanced one-way analysis of variance power calculation ## ## k = 4 ## n = 18.18244 ## f = 0.5 ## sig.level = 0.05 ## power = 0.95 ## ## NOTE: n is number in each group with( aggregate( data = PlantGrowth, weight ~ group, FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x)) ), cbind.data.frame(weight, group) ) R 3.5.0 以后，函数 aggregate 的参数 drop 默认设置为 TRUE 表示扔掉未用来分组的变量，聚合返回的是一个矩阵类型的数据对象。 ggsignif 添加显著性注释 library(ggplot2) library(ggsignif) ggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot() + geom_signif(comparisons = list(c(&quot;ctrl&quot;, &quot;trt1&quot;), c(&quot;trt1&quot;, &quot;trt2&quot;)), map_signif_level = function(p) sprintf(&quot;p = %.2g&quot;, p), textsize = 6, test = &quot;t.test&quot;) + theme_minimal() 无条件 \\(2 \\times 2\\) 列联表 fisher.test https://en.wikipedia.org/wiki/Fisher's_exact_test Exact https://en.wikipedia.org/wiki/Barnard's_test exact.test power.exact.test exact2x2 参考文献 "],["sec-power-session.html", "21.4 运行环境", " 21.4 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggplot2_3.3.5 lme4_1.1-27.1 Matrix_1.3-4 pwr_1.3-0 formatR_1.11 ## [6] magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.7 highr_0.9 pillar_1.6.1 bslib_0.2.5.1 ## [5] compiler_4.1.0 nloptr_1.2.2.2 jquerylib_0.1.4 tools_4.1.0 ## [9] boot_1.3-28 digest_0.6.27 tibble_3.1.2 jsonlite_1.7.2 ## [13] evaluate_0.14 lifecycle_1.0.0 nlme_3.1-152 gtable_0.3.0 ## [17] lattice_0.20-44 pkgconfig_2.0.3 rlang_0.4.11 DBI_1.1.1 ## [21] yaml_2.2.1 xfun_0.24 withr_2.4.2 dplyr_1.0.7 ## [25] stringr_1.4.0 knitr_1.33 generics_0.1.0 vctrs_0.3.8 ## [29] sass_0.4.0 tidyselect_1.1.1 grid_4.1.0 glue_1.4.2 ## [33] R6_2.5.0 fansi_0.5.0 rmarkdown_2.9 bookdown_0.22 ## [37] minqa_1.2.4 farver_2.1.0 purrr_0.3.4 ellipsis_0.3.2 ## [41] scales_1.1.1 htmltools_0.5.1.1 MASS_7.3-54 splines_4.1.0 ## [45] assertthat_0.2.1 colorspace_2.0-2 labeling_0.4.2 utf8_1.2.1 ## [49] stringi_1.7.3 munsell_0.5.0 crayon_1.4.1 "],["chap-experimental-design.html", "第 22 章 试验设计", " 第 22 章 试验设计 library(magrittr) library(ggplot2) 我想不少人初次见到本章题目首先疑惑的可能是到底是试验还是实验？这里做一下说明，实验的意思是带有验证性的目的，已经有结果了，做实验验证某个规律，常常用在物理、化学的课堂里，学生做实验验证自由落体运动、做实验测量重力加速度等等。试验的意思是人为设定一系列操作步骤去探索未知，不确定结果如何，试一试。 试验设计（Design of Experiment，简称 DOE）是一个应用性很强的学科领域，R. A. Fisher 曾在农业站做实验验证孟德尔的豌豆实验结果。 Vikneswaran 提供了一份书籍 Berger and Maurer (2002) 的补充材料 — An R companion to “Experimental Design”，目前 Paul Berger 的这本书已经迭代到第二版 (Berger, Maurer, and Celli 2018)，2015 年 Paul Berger 出版了新书 《Improving the User Experience through Practical Data Analytics: Gain Meaningful Insight and Increase Your Bottom Line》 (Fritz and Berger 2015) 颇具应用性，结合产品用户体验来谈试验设计。 Bill Venables 开发的 conf.design 是试验设计领域的核心 R 包，CRAN 官网上试验设计视图 https://cran.r-project.org/view=ExperimentalDesign 可以让我们对试验设计这个领域有一个粗略的了解。 推荐读者使用贴合 R 语言的试验设计入门书 《Design and Analysis of Experiments with R》(Lawson 2014)，作者提供相应的 R 包 daewr 打包了该书的数据和代码。另外，推荐的读物是 《Statistics for Experimenters: Design, Innovation, and Discovery》(Box, Hunter, and Hunter 2005) 和《Trustworthy Online Controlled Experiments: A Practical Guide to A/B Testing》 (Kohavi, Tang, and Xu 2020)。 另一个和试验设计紧密相关的话题是敏感性分析，推荐 Devin Incerti 的敏感性分析系列博客 https://devinincerti.com/blog.html，R 包 sensitivity 提供140+ 页的手册，功能非常强，模型的全局敏感性分析， SWATplusR SWAT 分析法和 R 语言结合。 参考文献 "],["sec-sleep.html", "22.1 学生睡眠质量", " 22.1 学生睡眠质量 ggplot(data = sleep, aes(x = group, y = extra, color = group)) + geom_boxplot() + geom_jitter() + theme_minimal() "],["sec-insect-sprays.html", "22.2 驱虫喷雾的效果", " 22.2 驱虫喷雾的效果 InsectSprays 数据集 (Beall 1942) 来源于农业实验，记录了不同杀虫剂的效果，即杀虫剂过后，单位实验区域内虫子的数量，如图22.1所示，横轴表示杀虫剂种类，纵轴表示虫子数量。 ggplot(data = InsectSprays, aes(x = spray, y = count, color = spray)) + geom_boxplot() + geom_jitter() + theme_minimal() 图 22.1: 不同杀虫剂的效果 先创建一个 aov 对象，把它命名为 mod1，见下方 mod1 &lt;- aov(count ~ spray, data = InsectSprays) 第一个参数告诉 R count 是响应变量，spray 是协变量，第二个参数告诉 R 去对象 InsectSprays 中寻找这些变量。下面把分析结果以一种漂亮的格式打印出来 summary(mod1) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## spray 5 2669 533.8 34.7 &lt;2e-16 *** ## Residuals 66 1015 15.4 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 表格中的条目是很容易理解的，比如最右边的列表示 P 值。如果我们想做固定显著性水平下的检验，比如 \\(\\alpha = 0.075\\) 时的 F 统计量的值， qf(0.075, 5, 66, lower.tail = F) ## [1] 2.110783 上面的命令是说 \\(F(5, 66)\\) 分布的 0.075 分位点，最后一个参数很关键，因为默认情况下 R 计算下分位点，详情见 ?qf。 方差分析做了三个假设 残差 \\(\\epsilon_{ij}\\) 是相互独立的随机变量； 残差 \\(\\epsilon_{ij}\\) 服从正态分布； 残差 \\(\\epsilon_{ij}\\) 均值为 0，方差是固定的常数。 假设 1 和 3 通过图来检验，假设 2 通过 QQ 图来检验。值得一提的是 mod1 对象除了打印出来，还有很多方法 names(mod1) ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; ## [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; ## [9] &quot;contrasts&quot; &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; ## [13] &quot;model&quot; 比如获取残差，考虑到篇幅，这里仅显示前 10 个 head(mod1$residuals, 10) ## 1 2 3 4 5 6 7 8 9 10 ## -4.5 -7.5 5.5 -0.5 -0.5 -2.5 -4.5 8.5 2.5 5.5 par(mar = c(4, 4, 2, 2), mfrow = c(2,2)) plot(mod1) plot(mod1$fitted.values, mod1$residuals, main = &quot;Residuals vs. Fitted&quot;, pch = 20) abline(h = 0, lty = 2) plot(mod1$model$spray, mod1$residuals, main = &quot;Residuals vs. Levels&quot; ) plot(1:72, mod1$residuals, main = &quot;Residuals vs. Time Order&quot;) abline(h = 0, lty = 2) qqnorm(mod1$residuals, pch = 20) qqline(mod1$residuals) 如果上面的假设显著失效，我们要采用非参数检验 mod2 &lt;- kruskal.test(count ~ spray, data = InsectSprays) mod2 ## ## Kruskal-Wallis rank sum test ## ## data: count by spray ## Kruskal-Wallis chi-squared = 54.691, df = 5, p-value = 1.511e-10 计算给定水平下的置信区间，构造置信水平为 95% 的区间 \\[ \\bar{X} \\pm t_{1-\\alpha/2}(s/\\sqrt{n}) \\] 以 A 号杀虫剂为例， xbar = mean(InsectSprays[InsectSprays$spray == &quot;A&quot;, &quot;count&quot;]) t_crit &lt;- qt(0.025, mod1$df.residual, lower.tail = F) s &lt;- sqrt(sum((mod1$residuals)^2) / mod1$df.residual) n &lt;- sum(InsectSprays$spray == &quot;A&quot;) # 最后置信区间的上下限 c(xbar - t_crit * (s/ sqrt(n)), xbar + t_crit * (s/ sqrt(n))) ## [1] 12.23958 16.76042 比较 A 号和 C 号杀虫剂的效果，计算两个均值差的置信区间 \\[ \\bar{X}_1 - \\bar{X}_2 \\pm t_{1-\\alpha/2}(s/\\sqrt{1/n_1 + 1/n_2}) \\] n1 &lt;- sum(InsectSprays$spray == &quot;A&quot;) n2 &lt;- sum(InsectSprays$spray == &quot;C&quot;) x1bar = mean(InsectSprays[InsectSprays$spray == &quot;A&quot;, &quot;count&quot;]) x2bar = mean(InsectSprays[InsectSprays$spray == &quot;C&quot;, &quot;count&quot;]) 代入公式即可计算得到置信区间 (x1bar - x2bar) - t_crit * s * sqrt( 1/ n1 + 1/n2) ## [1] 9.219948 (x1bar - x2bar) + t_crit * s * sqrt( 1/ n1 + 1/n2) ## [1] 15.61339 Fisher’s 最小显著性检验 (Fisher’s Least Significant Difference Test) 即 t_crit * s * sqrt( 1/ n1 + 1/n2) ## [1] 3.196719 Tukey’s Honestly Significant Difference Test 主要测量成对实验的误差比率，假定每个水平下的实验次数是相等的，只需将上面的 aov 对象传递给函数 TukeyHSD() mod3 &lt;- TukeyHSD(mod1, ordered = TRUE) mod3 ## Tukey multiple comparisons of means ## 95% family-wise confidence level ## factor levels have been ordered ## ## Fit: aov(formula = count ~ spray, data = InsectSprays) ## ## $spray ## diff lwr upr p adj ## E-C 1.4166667 -3.282742 6.116075 0.9488669 ## D-C 2.8333333 -1.866075 7.532742 0.4920707 ## A-C 12.4166667 7.717258 17.116075 0.0000000 ## B-C 13.2500000 8.550591 17.949409 0.0000000 ## F-C 14.5833333 9.883925 19.282742 0.0000000 ## D-E 1.4166667 -3.282742 6.116075 0.9488669 ## A-E 11.0000000 6.300591 15.699409 0.0000000 ## B-E 11.8333333 7.133925 16.532742 0.0000000 ## F-E 13.1666667 8.467258 17.866075 0.0000000 ## A-D 9.5833333 4.883925 14.282742 0.0000014 ## B-D 10.4166667 5.717258 15.116075 0.0000002 ## F-D 11.7500000 7.050591 16.449409 0.0000000 ## B-A 0.8333333 -3.866075 5.532742 0.9951810 ## F-A 2.1666667 -2.532742 6.866075 0.7542147 ## F-B 1.3333333 -3.366075 6.032742 0.9603075 其中，diff 表示均值之差，lwr 和 upr 表示置信区间的上下限，\\(p_{adj}\\) 是对应的。检查一下，看看哪些置信区间包含 0 ，包含 0 的表示不显著，从第三行来看， A 和 C 之间差别显著。之前计算过 A、C 均值，均值之差即 (x1bar - x2bar) ## [1] 12.41667 在误差比率 \\(\\alpha = 0.05\\) 的情况下，如果你想手动计算 HSD 值 q_crit &lt;- qtukey(p = 0.05, nmeans = length(mod1$xlevels[[1]]), df = mod1$df.residual, lower.tail = F) # mod1$df.residual 是 6 hsd &lt;- q_crit * s / sqrt(6) hsd ## [1] 6.645967 将模型结果 mod3 用图画出来，见下图 plot(mod3) 图 22.2: 成对显著性水平 关于多重比较请见 Frank Bretz, Torsten Hothorn, Peter Westfall 的书《Multiple Comparisons Using R》及配套 R 包 multcomp，该 R 包现由 Torsten Hothorn 维护，他还维护了一个由数据集构成的 R 包 TH.data，我们后续章节也会用到。 参考文献 "],["sec-multiple-comparison.html", "22.3 重复数不等的多重比较", " 22.3 重复数不等的多重比较 Tukey 的检验方法要求各个组的重复数相等，而方差分析的重复数不等时，我们需要用如下方法 \\[ \\frac{(\\bar{y}_{i\\cdot} - \\bar{y}_{j\\cdot}) - (\\mu_i - \\mu_j)}{\\sqrt{\\frac{1}{m_i} + \\frac{1}{m_j}} \\hat{\\sigma}} \\sim t(f_e) \\] \\[ c_{ij} = \\sqrt{(r-1)F_{1-\\alpha}(r-1, f_e)(\\frac{1}{m_i} +\\frac{1}{m_j})\\hat{\\sigma^2}} \\] \\(\\hat{\\sigma^2} = S_e/ f_e\\) 是 \\(\\sigma^2\\) 无偏估计。 \\[ y_{ij} = \\mu + a_i + \\epsilon_{ij}, \\quad i = 1,2,\\ldots,r, \\quad j = 1,2, \\ldots, m_i. \\quad \\sum_{i=1}^{r}m_{i}a_{i} = 0, \\] 其中，\\(\\epsilon_{ij}\\) 相互独立，服从 \\(\\mathcal{N}(0, \\sigma^2)\\). \\(f_e = n - r, S_e = \\sum_{i=1}^{r}\\sum_{j=1}^{m_{i}}(y_{ij} - \\bar{y}_{i\\cdot})^2 = S_T - S_A\\) "],["sec-co2.html", "22.4 不同地区的草类植物吸收二氧化碳的情况", " 22.4 不同地区的草类植物吸收二氧化碳的情况 通过观察不同地区的草类植物吸收二氧化碳的情况，研究植物的耐寒性 ggplot(data = CO2, aes(x = conc, y = uptake, color = Type, shape = Treatment)) + geom_point() + geom_line() + facet_wrap(~Plant, ncol = 3) + theme_minimal() + labs(x = &quot;conc (mL/L)&quot;, y = &quot;uptake (umol/m^2 sec)&quot;) 图 22.3: 草类植物吸收二氧化碳的量 "],["sec-orchard-sprays.html", "22.5 果园喷雾剂的效力", " 22.5 果园喷雾剂的效力 评估喷雾杀虫剂的在果园的效果 data(&quot;OrchardSprays&quot;) "],["sec-npk.html", "22.6 验证孟德尔的豌豆实验结果", " 22.6 验证孟德尔的豌豆实验结果 R. A. Fisher 在农业站做实验验证孟德尔的豌豆实验结果 data(&quot;npk&quot;) 豌豆产量和氮 (nitrogen, N) 磷酸盐 (phosphate, P) 钾盐 (potassium, K) 的关系 "],["chap-linear-models.html", "第 23 章 线性模型", " 第 23 章 线性模型 There’s probably some examples, but there are some examples of people using solve(t(X) %*% W %*% X) %*% W %*% Y to compute regression coefficients, too. — Thomas Lumley38 https://stat.ethz.ch/pipermail/r-help/2006-March/101596.html↩︎ "],["sec-anova.html", "23.1 方差分析", " 23.1 方差分析 I was profoundly disappointed when I saw that S-PLUS 4.5 now provides “Type III” sums of squares as a routine option for the summary method for aov objects. I note that it is not yet available for multistratum models, although this has all the hallmarks of an oversight (that is, a bug) rather than common sense seeing the light of day. When the decision was being taken of whether to include this feature, “because the FDA requires it” a few of my colleagues and I were consulted and our reply was unhesitatingly a clear and unequivocal “No,” but it seems the FDA and SAS speak louder and we were clearly outvoted. — Bill Venables39 方差分析、 A/B Test 和多重比较多用于互联网数据 lme 的特例 来源于 Exegeses on Linear Models↩︎ "],["One-Way-ANOVA.html", "23.2 单因素方差分析", " 23.2 单因素方差分析 chickwts 不同的喂食方式对体重的影响 boxplot(weight ~ feed, data = chickwts, col = &quot;lightgray&quot;, varwidth = TRUE, notch = TRUE, main = &quot;chickwt data&quot;, ylab = &quot;Weight at six weeks (gm)&quot;) ## Warning in (function (z, notch = FALSE, width = NULL, varwidth = FALSE, : some ## notches went outside hinges (&#39;box&#39;): maybe set notch=FALSE anova(fm1 &lt;- lm(weight ~ feed, data = chickwts)) ## Analysis of Variance Table ## ## Response: weight ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## feed 5 231129 46226 15.365 5.936e-10 *** ## Residuals 65 195556 3009 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 opar &lt;- par(mfrow = c(2, 2), oma = c(0, 0, 1.1, 0), mar = c(4.1, 4.1, 2.1, 1.1)) plot(fm1) par(opar) sleep ## Student&#39;s paired t-test 成对样本的 t 检验 with(sleep, t.test(extra[group == 1], extra[group == 2], paired = TRUE)) ## ## Paired t-test ## ## data: extra[group == 1] and extra[group == 2] ## t = -4.0621, df = 9, p-value = 0.002833 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -2.4598858 -0.7001142 ## sample estimates: ## mean of the differences ## -1.58 ## The sleep *prolongations* sleep1 &lt;- with(sleep, extra[group == 2] - extra[group == 1]) summary(sleep1) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.00 1.05 1.30 1.58 1.70 4.60 stripchart(sleep1, method = &quot;stack&quot;, xlab = &quot;hours&quot;, main = &quot;Sleep prolongation (n = 10)&quot;) boxplot(sleep1, horizontal = TRUE, add = TRUE, at = .6, pars = list(boxwex = 0.5, staplewex = 0.25)) 另一个关于测量光速的例子，带分类变量的 michelson &lt;- transform(morley, Expt = factor(Expt), Run = factor(Run)) xtabs(~ Expt + Run, data = michelson) # 5 x 20 balanced (two-way) ## Run ## Expt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## 2 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## 3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 plot(Speed ~ Expt, data = michelson, main = &quot;Speed of Light Data&quot;, xlab = &quot;Experiment No.&quot;) fm &lt;- aov(Speed ~ Run + Expt, data = michelson) summary(fm) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Run 19 113344 5965 1.105 0.36321 ## Expt 4 94514 23629 4.378 0.00307 ** ## Residuals 76 410166 5397 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 fm0 &lt;- update(fm, . ~ . - Run) anova(fm0, fm) ## Analysis of Variance Table ## ## Model 1: Speed ~ Expt ## Model 2: Speed ~ Run + Expt ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 95 523510 ## 2 76 410166 19 113344 1.1053 0.3632 ToothGrowth 维生素 C 对牙齿增长的关系 coplot(len ~ dose | supp, data = ToothGrowth, panel = panel.smooth, xlab = &quot;ToothGrowth data: length vs dose, given type of supplement&quot;) "],["sec-two-way-anova.html", "23.3 双因素方差分析", " 23.3 双因素方差分析 ?lm mlm "],["sec-manova.html", "23.4 多因素方差分析", " 23.4 多因素方差分析 MANOVA.RM 和 ffmanova 包处理多因素方差分析 "],["sec-kernal-smooth.html", "23.5 核学习", " 23.5 核学习 基于核的机器学习算法 kernlab David Meyer 基于 libsvm 开发了 e1071 包，基于核方法实现了非线性回归分类算法 线性模型、逻辑回归模型、多项逻辑回归模型、神经网络、朴素贝叶斯、分类回归树等模型和算法借助 Shiny 整合在一起 https://radiant-rstats.github.io/docs/ 和 http://radiant-rstats.github.io/radiant.model/ "],["sec-unify-machine-learning.html", "23.6 通用机器学习", " 23.6 通用机器学习 表 23.1: R 包之间的不一致性，计算预测分类的概率的语法 函数 R 包 代码 lda MASS predict(obj) glm stats predict(obj, type = \"response\") gbm gbm predict(obj, type = \"response\", n.trees) mda mda predict(obj, type = \"posterior\") rpart rpart predict(obj, type = \"prob\") Weka RWeka predict(obj, type = \"probability\") logitboost LogitBoost predict(obj, type = \"raw\", nIter) pamr.train pamr pamr.predict(obj, type = \"posterior\") "],["sec-linear-model-theory.html", "23.7 理论基础", " 23.7 理论基础 \\[\\begin{align} Y &amp;= X \\beta + \\epsilon \\\\ X^{\\top}Y &amp;= X^{\\top}X\\beta \\\\ \\hat{\\beta} &amp;= (X^{\\top}X)^{-1}X^{\\top}Y \\\\ \\hat{Y} &amp;= X(X^{\\top}X)^{-1}X^{\\top}Y \\\\ \\hat{\\sigma^2} &amp;= \\frac{\\|Y - \\hat{Y}\\|_2}{n - rk(X)} \\\\ &amp; = \\frac{\\|(I - X(X^{\\top}X)^{-1}X^{\\top})Y\\|_2}{n - rk(X)}\\\\ &amp; = \\frac{Y^{\\top}(I - X(X^{\\top}X)^{-1}X^{\\top})Y}{n - rk(X)} \\end{align}\\] "],["sec-multivariate-multiple-linear-regression.html", "23.8 多重多元线性回归", " 23.8 多重多元线性回归 参考 John Fox 和 Sanford Weisberg 的著作(Fox and Weisberg 2019) 附录40 多个响应变量和协变量41 多重多元线性回归 multiply linear regression lm R 版本 3.6 以上 PR#17407 fit_mtcars &lt;- lm(cbind(mpg, qsec) ~ 1, data = mtcars, offset = cbind(wt, wt * 2)) summary(fit_mtcars) ## Response mpg : ## ## Call: ## lm(formula = mpg ~ 1, data = mtcars, offset = cbind(wt, wt * ## 2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -11.897 -4.947 -1.316 2.984 15.192 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 16.873 1.219 13.85 8.1e-15 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 6.893 on 31 degrees of freedom ## ## ## Response qsec : ## ## Call: ## lm(formula = qsec ~ 1, data = mtcars, offset = cbind(wt, wt * ## 2)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -4.6842 -2.0793 -0.1693 2.2693 5.1857 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 11.4142 0.5076 22.49 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.871 on 31 degrees of freedom 参考文献 "],["sec-regression-diagnostics.html", "23.9 回归诊断", " 23.9 回归诊断 包括线性模型和广义线性模型 Regression Deletion Diagnostics ?influence.measures library(extrafont) # 注册字体 CM Roman 到 PDF 设备 data(anscombe) form &lt;- paste(paste0(&quot;y&quot;, seq(4)), paste0(&quot;x&quot;, seq(4)), sep = &quot;~&quot;) # form &lt;- sprintf(&#39;y%d ~ x%d&#39;, 1:4, 1:4) fit &lt;- lapply(form, lm, data = anscombe) par(mfrow = c(2, 2), mar = 0.1 + c(4, 4, 1, 1), oma = c(0, 0, 2, 0), family = &quot;CM Roman&quot;) for (i in 1:4) { plot(as.formula(form[i]), data = anscombe, col = &quot;black&quot;, pch = 19, cex = 1.2, xlim = c(3, 19), ylim = c(3, 13), xlab = as.expression(substitute(bold(x[i]), list(i = i))), ylab = as.expression(substitute(bold(y[i]), list(i = i))) ) abline(fit[[i]], col = &quot;red&quot;, lwd = 2) text(7, 12, bquote(bold(R)^2 == .(round(summary(fit[[i]])$r.squared, 3)))) } mtext(&quot;Anscombe&#39;s 4 Regression data sets&quot;, outer = TRUE, cex = 1.2) 图 23.1: 模型诊断很重要 library(ggplot2) library(patchwork) data(&quot;anscombe&quot;) form &lt;- sprintf(&#39;y%d ~ x%d&#39;, 1:4, 1:4) fit &lt;- lapply(form, lm, data = anscombe) plot_lm &lt;- function(i) { annotate_texts &lt;- c(&quot;&quot;, &quot;nonlinearity&quot;, &quot;outlier&quot;, &quot;influential point&quot;) p &lt;- ggplot(data = anscombe, aes_string(x = paste0(&quot;x&quot;, i), y = paste0(&quot;y&quot;, i))) + geom_point() + geom_abline(intercept = coef(fit[[i]])[1], slope = coef(fit[[i]])[2], color = &quot;red&quot;) + theme_minimal() + labs( x = substitute(bold(x[a]), list(a = i)), y = substitute(bold(y[b]), list(b = i)), title = bquote(bold(R)^2 == .(round(summary(fit[[i]])$r.squared, 3))) ) p + annotate(&quot;text&quot;, x = 12, y = 11, label = annotate_texts[i]) } Reduce(&quot;+&quot;, lapply(1:4, plot_lm)) 图 23.2: 线性模型可能在欺骗你 "],["sec-states.html", "23.10 1977 年美国人口普查", " 23.10 1977 年美国人口普查 state_data &lt;- data.frame(state.x77, row.names = state.abb) fit_state &lt;- lm(Life.Exp ~ ., data = state_data) summary(fit_state) ## ## Call: ## lm(formula = Life.Exp ~ ., data = state_data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.48895 -0.51232 -0.02747 0.57002 1.49447 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 7.094e+01 1.748e+00 40.586 &lt; 2e-16 *** ## Population 5.180e-05 2.919e-05 1.775 0.0832 . ## Income -2.180e-05 2.444e-04 -0.089 0.9293 ## Illiteracy 3.382e-02 3.663e-01 0.092 0.9269 ## Murder -3.011e-01 4.662e-02 -6.459 8.68e-08 *** ## HS.Grad 4.893e-02 2.332e-02 2.098 0.0420 * ## Frost -5.735e-03 3.143e-03 -1.825 0.0752 . ## Area -7.383e-08 1.668e-06 -0.044 0.9649 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.7448 on 42 degrees of freedom ## Multiple R-squared: 0.7362, Adjusted R-squared: 0.6922 ## F-statistic: 16.74 on 7 and 42 DF, p-value: 2.534e-10 # step(fit_state) "],["sec-rock.html", "23.11 石油岩石样品的测量", " 23.11 石油岩石样品的测量 data(rock) 多元线性回归 "],["sec-swiss.html", "23.12 1888 年瑞士生育率分析", " 23.12 1888 年瑞士生育率分析 1888 年瑞士生育率和社会经济指标数据，各个指标都是百分比的形式，探索性分析 图 23.3: 1888 年瑞士生育率和社会经济指标的关系 fit_swiss &lt;- lm(Fertility ~ . - 1, data = swiss) summary(fit_swiss) ## ## Call: ## lm(formula = Fertility ~ . - 1, data = swiss) ## ## Residuals: ## Min 1Q Median 3Q Max ## -16.8358 -6.3606 -0.5603 6.0585 23.3203 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## Agriculture 0.11100 0.07424 1.495 0.14233 ## Examination 0.44406 0.31435 1.413 0.16514 ## Education -0.70674 0.25009 -2.826 0.00719 ** ## Catholic 0.11707 0.04860 2.409 0.02046 * ## Infant.Mortality 2.98366 0.31683 9.417 6.53e-12 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 9.893 on 42 degrees of freedom ## Multiple R-squared: 0.9828, Adjusted R-squared: 0.9807 ## F-statistic: 478.8 on 5 and 42 DF, p-value: &lt; 2.2e-16 anova(fit_swiss) ## Analysis of Variance Table ## ## Response: Fertility ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## Agriculture 1 204039 204039 2084.6865 &lt; 2.2e-16 *** ## Examination 1 16781 16781 171.4556 &lt; 2.2e-16 *** ## Education 1 24 24 0.2454 0.6229 ## Catholic 1 4782 4782 48.8556 1.504e-08 *** ## Infant.Mortality 1 8680 8680 88.6858 6.528e-12 *** ## Residuals 42 4111 98 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Cook 距离 ?plot.lm par(mar = c(4, 4, 2, 2)) plot(fit_swiss, which = 4, sub.caption = &quot;&quot;) par(mar = c(4, 4, 2, 2)) plot(fit_swiss, which = 5, sub.caption = &quot;&quot;) X &lt;- as.matrix(swiss[, setdiff(names(swiss), &quot;Fertility&quot;)]) Y &lt;- as.matrix(swiss[, &quot;Fertility&quot;]) # beta 的估计 (beta_hat &lt;- solve(a = crossprod(X, X), b = crossprod(X, Y))) ## [,1] ## Agriculture 0.1110005 ## Examination 0.4440591 ## Education -0.7067362 ## Catholic 0.1170662 ## Infant.Mortality 2.9836617 # Y 的预测 MSE 残差平方和 sigma2_hat &lt;- (t(Y) %*% (diag(rep(1, dim(X)[1])) - X %*% solve(crossprod(X)) %*% t(X)) %*% Y)/(dim(X)[1] - qr(X)$rank) # RMSE sqrt(sigma2_hat) ## [,1] ## [1,] 9.893187 "],["sec-life-cycle-savings.html", "23.13 Intercountry Life-Cycle Savings Data 1960-1970", " 23.13 Intercountry Life-Cycle Savings Data 1960-1970 data(&quot;LifeCycleSavings&quot;) "],["sec-longley.html", "23.14 Longley’s Economic Regression Data 1947-1962", " 23.14 Longley’s Economic Regression Data 1947-1962 data(&quot;longley&quot;) "],["sec-Formaldehyde.html", "23.15 甲醛的测定", " 23.15 甲醛的测定 ggplot(data = Formaldehyde, aes(x = carb, y = optden)) + geom_point() + theme_minimal() "],["sec-morley.html", "23.16 迈克尔逊光速数据分析", " 23.16 迈克尔逊光速数据分析 1879 年迈克尔逊光速测量数据，记录了五次实验，每次试验测量 20 次光速，得到表格 23.2 reshape( data = morley, v.names = &quot;Speed&quot;, idvar = &quot;Expt&quot;, timevar = &quot;Run&quot;, direction = &quot;wide&quot;, sep = &quot;&quot; ) %&gt;% knitr::kable(., caption = &quot;迈克尔逊光速数据&quot;, row.names = FALSE, col.names = gsub(&quot;(Speed)&quot;, &quot;&quot;, names(.)), align = &quot;c&quot; ) 表 23.2: 迈克尔逊光速数据 Expt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 850 740 900 1070 930 850 950 980 980 880 1000 980 930 650 760 810 1000 1000 960 960 2 960 940 960 940 880 800 850 880 900 840 830 790 810 880 880 830 800 790 760 800 3 880 880 880 860 720 720 620 860 970 950 880 910 850 870 840 840 850 840 840 840 4 890 810 810 820 800 770 760 740 750 760 910 920 890 860 880 720 840 850 850 780 5 890 840 780 810 760 810 790 810 820 850 870 870 810 740 810 940 950 800 810 870 数据集 morley 中光速 Speed 已经编码过了，原始观测速度减去了 299000 (km/sec)，为了展示方便 ggplot(data = morley, aes(x = Expt, y = Speed, group = Expt)) + geom_boxplot() + geom_jitter() + theme_minimal() + labs(x = &quot;Expt&quot;, y = &quot;Speed (km/sec)&quot;) 图 23.4: 1879 年迈克尔逊光速实验数据 "],["sec-chickwts.html", "23.17 不同喂食方式对小鸡体重的影响 I", " 23.17 不同喂食方式对小鸡体重的影响 I ggplot(data = chickwts, aes(x = feed, y = weight, color = feed)) + geom_boxplot() + geom_jitter() + theme_minimal() 图 23.5: 不同喂食方式对小鸡的影响 "],["sec-ChickWeight.html", "23.18 不同喂食方式对小鸡体重的影响 II", " 23.18 不同喂食方式对小鸡体重的影响 II ggplot(data = ChickWeight, aes(x = Time, y = weight, group = Chick, color = Diet)) + geom_point() + geom_line() + facet_wrap(~Diet) + theme_minimal() 添加趋势线 ggplot(data = ChickWeight, aes(x = Time, y = weight, group = Diet, colour = Diet)) + facet_wrap(~Diet) + geom_jitter() + stat_summary(fun = &quot;mean&quot;, geom = &quot;line&quot;, colour = &quot;black&quot;) + theme_minimal() + labs( title = &quot;Chick Weight over Time by Diet&quot;, x = &quot;Time (days)&quot;, y = &quot;Weight (grams)&quot; ) "],["sec-DNase.html", "23.19 酶的酶联免疫吸附测定", " 23.19 酶的酶联免疫吸附测定 ggplot(data = DNase, aes(x= conc,y= density, color = Run)) + geom_point() + theme_minimal() "],["sec-BirthWeight.html", "23.20 婴儿的体重随年龄的变化情况", " 23.20 婴儿的体重随年龄的变化情况 BirthWeight 数据集记录了婴儿的体重随年龄的变化情况，年龄以周为单位计，体重以克为单位计 性别和年龄两个变量，分别是离散型的分类变量和连续型的变量 # 带截距项和不带截距项 summary(l1 &lt;- lm(birthw ~ sex + age), correlation = TRUE) ## ## Call: ## lm(formula = birthw ~ sex + age) ## ## Residuals: ## Min 1Q Median 3Q Max ## -257.49 -125.28 -58.44 169.00 303.98 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1610.28 786.08 -2.049 0.0532 . ## sexF -163.04 72.81 -2.239 0.0361 * ## age 120.89 20.46 5.908 7.28e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 177.1 on 21 degrees of freedom ## Multiple R-squared: 0.64, Adjusted R-squared: 0.6057 ## F-statistic: 18.67 on 2 and 21 DF, p-value: 2.194e-05 ## ## Correlation of Coefficients: ## (Intercept) sexF ## sexF 0.07 ## age -1.00 -0.12 anova(l1) ## Analysis of Variance Table ## ## Response: birthw ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## sex 1 76163 76163 2.4279 0.1341 ## age 1 1094940 1094940 34.9040 7.284e-06 *** ## Residuals 21 658771 31370 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # 与带交互项的模型比较 summary(li &lt;- lm(birthw ~ sex + sex:age), correlation = TRUE) ## ## Call: ## lm(formula = birthw ~ sex + sex:age) ## ## Residuals: ## Min 1Q Median 3Q Max ## -246.69 -138.11 -39.13 176.57 274.28 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1268.67 1114.64 -1.138 0.268492 ## sexF -872.99 1611.33 -0.542 0.593952 ## sexM:age 111.98 29.05 3.855 0.000986 *** ## sexF:age 130.40 30.00 4.347 0.000313 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 180.6 on 20 degrees of freedom ## Multiple R-squared: 0.6435, Adjusted R-squared: 0.59 ## F-statistic: 12.03 on 3 and 20 DF, p-value: 0.000101 ## ## Correlation of Coefficients: ## (Intercept) sexF sexM:age ## sexF -0.69 ## sexM:age -1.00 0.69 ## sexF:age 0.00 -0.72 0.00 anova(li, l1) ## Analysis of Variance Table ## ## Model 1: birthw ~ sex + sex:age ## Model 2: birthw ~ sex + age ## Res.Df RSS Df Sum of Sq F Pr(&gt;F) ## 1 20 652425 ## 2 21 658771 -1 -6346.2 0.1945 0.6639 # 类似，只是使用 glm 命令来拟合而已 summary(zi &lt;- glm(birthw ~ sex + age, family = gaussian())) ## ## Call: ## glm(formula = birthw ~ sex + age, family = gaussian()) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -257.49 -125.28 -58.44 169.00 303.98 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1610.28 786.08 -2.049 0.0532 . ## sexF -163.04 72.81 -2.239 0.0361 * ## age 120.89 20.46 5.908 7.28e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for gaussian family taken to be 31370.04) ## ## Null deviance: 1829873 on 23 degrees of freedom ## Residual deviance: 658771 on 21 degrees of freedom ## AIC: 321.39 ## ## Number of Fisher Scoring iterations: 2 anova(zi) ## Analysis of Deviance Table ## ## Model: gaussian, link: identity ## ## Response: birthw ## ## Terms added sequentially (first to last) ## ## ## Df Deviance Resid. Df Resid. Dev ## NULL 23 1829873 ## sex 1 76163 22 1753711 ## age 1 1094940 21 658771 # summary(z.o4 &lt;- update(zi, subset = -4)) summary(zz &lt;- update(zi, birthw ~ sex + age + sex:age)) ## ## Call: ## glm(formula = birthw ~ sex + age + sex:age, family = gaussian()) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -246.69 -138.11 -39.13 176.57 274.28 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1268.67 1114.64 -1.138 0.268492 ## sexF -872.99 1611.33 -0.542 0.593952 ## age 111.98 29.05 3.855 0.000986 *** ## sexF:age 18.42 41.76 0.441 0.663893 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for gaussian family taken to be 32621.23) ## ## Null deviance: 1829873 on 23 degrees of freedom ## Residual deviance: 652425 on 20 degrees of freedom ## AIC: 323.16 ## ## Number of Fisher Scoring iterations: 2 anova(zi, zz) ## Analysis of Deviance Table ## ## Model 1: birthw ~ sex + age ## Model 2: birthw ~ sex + age + sex:age ## Resid. Df Resid. Dev Df Deviance ## 1 21 658771 ## 2 20 652425 1 6346.2 "],["sec-loblolly.html", "23.21 火炬松树的生长情况", " 23.21 火炬松树的生长情况 表 23.3 记录了 14 颗火炬树种子的生长情况 reshape(Loblolly, idvar = &quot;Seed&quot;, timevar = &quot;age&quot;, v.names = &quot;height&quot;, direction = &quot;wide&quot;, sep = &quot;&quot;) %&gt;% knitr::kable(., caption = &quot;火炬松树的高度（英尺）随时间（年）的变化&quot;, row.names = FALSE, col.names = gsub(&quot;(height)&quot;, &quot;&quot;, names(.)), align = &quot;c&quot; ) 表 23.3: 火炬松树的高度（英尺）随时间（年）的变化 Seed 3 5 10 15 20 25 301 4.51 10.89 28.72 41.74 52.70 60.92 303 4.55 10.92 29.07 42.83 53.88 63.39 305 4.79 11.37 30.21 44.40 55.82 64.10 307 3.91 9.48 25.66 39.07 50.78 59.07 309 4.81 11.20 28.66 41.66 53.31 63.05 311 3.88 9.40 25.99 39.55 51.46 59.64 315 4.32 10.43 27.16 40.85 51.33 60.07 319 4.57 10.57 27.90 41.13 52.43 60.69 321 3.77 9.03 25.45 38.98 49.76 60.28 323 4.33 10.79 28.97 42.44 53.17 61.62 325 4.38 10.48 27.93 40.20 50.06 58.49 327 4.12 9.92 26.54 37.82 48.43 56.81 329 3.93 9.34 26.08 37.79 48.31 56.43 331 3.46 9.05 25.85 39.15 49.12 59.49 图 23.6 火炬树种子基本决定了树的长势，不同种子预示最后的高度，并且在生长期也是很稳定地生长 p &lt;- ggplot(data = Loblolly, aes(x = age, y = height, color = Seed)) + geom_point() + geom_line() + theme_minimal() + labs(x = &quot;age (yr)&quot;, y = &quot;height (ft)&quot;) p 图 23.6: 不同火炬树的生长情况 library(gganimate) p + transition_reveal(age) "],["sec-Puromycin.html", "23.22 酶促反应的反应速率", " 23.22 酶促反应的反应速率 Puromycin 酶促反应的反应速度，模型拟合 ?SSmicmen ggplot(data = Puromycin, aes(x = conc, y = rate, color = state)) + geom_point() + geom_line() + theme_minimal() + labs( x = &quot;Substrate concentration (ppm)&quot;, y = &quot;Reaction velocity (counts/min/min)&quot;, title = &quot;Puromycin data and fitted Michaelis-Menten curves&quot; ) "],["sec-Theoph.html", "23.23 茶碱的药代动力学", " 23.23 茶碱的药代动力学 ggplot(data = Theoph, aes(x = Time, y = conc, color = Subject)) + geom_point() + geom_line() + facet_wrap(Wt ~ Dose, ncol = 3, labeller = &quot;label_both&quot;) + theme_minimal() + labs( x = &quot;Time since drug administration (hr)&quot;, y = &quot;Theophylline concentration (mg/L)&quot;, title = &quot;Observed concentrations and fitted model&quot; ) Theoph %&gt;% transform(., wt_dose = paste(Wt, Dose, sep = &quot;~&quot;)) %&gt;% ggplot(., aes(x = Time, y = conc, color = wt_dose)) + geom_point() + geom_line() + theme_minimal() + labs( x = &quot;Time since drug administration (hr)&quot;, y = &quot;Theophylline concentration (mg/L)&quot;, title = &quot;Observed concentrations and fitted model&quot; ) ggplot(data = Theoph, aes(x = Time, y = conc, color = Subject)) + geom_point() + geom_line() + theme_minimal() + labs( x = &quot;Time since drug administration (hr)&quot;, y = &quot;Theophylline concentration (mg/L)&quot;, title = &quot;Observed concentrations and fitted model&quot; ) "],["sec-linear-model-summary.html", "23.24 本章总结", " 23.24 本章总结 模型永远没完，总是需要自己去构造符合自己需求的模型及其实现，只有自己能够实现，才能在海洋中遨游 This is a bit like asking how should I tweak my sailboat so I can explore the ocean floor. — Roger Koenker42 https://stat.ethz.ch/pipermail/r-help/2013-May/354311.html↩︎ "],["sec-linear-model-sessioninfo.html", "23.25 运行环境", " 23.25 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] patchwork_1.1.1 extrafont_0.17 gganimate_1.0.7 ggplot2_3.3.5 ## [5] magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] progress_1.2.2 tidyselect_1.1.1 xfun_0.24 bslib_0.2.5.1 ## [5] purrr_0.3.4 lattice_0.20-44 splines_4.1.0 colorspace_2.0-2 ## [9] vctrs_0.3.8 generics_0.1.0 htmltools_0.5.1.1 viridisLite_0.4.0 ## [13] mgcv_1.8-36 yaml_2.2.1 utf8_1.2.1 rlang_0.4.11 ## [17] jquerylib_0.1.4 pillar_1.6.1 glue_1.4.2 withr_2.4.2 ## [21] DBI_1.1.1 tweenr_1.0.2 lifecycle_1.0.0 stringr_1.4.0 ## [25] munsell_0.5.0 gtable_0.3.0 evaluate_0.14 labeling_0.4.2 ## [29] knitr_1.33 fansi_0.5.0 gifski_1.4.3-1 Rttf2pt1_1.3.8 ## [33] highr_0.9 Rcpp_1.0.7 scales_1.1.1 jsonlite_1.7.2 ## [37] farver_2.1.0 hms_1.1.0 digest_0.6.27 stringi_1.7.3 ## [41] bookdown_0.22 dplyr_1.0.7 grid_4.1.0 tools_4.1.0 ## [45] sass_0.4.0 tibble_3.1.2 crayon_1.4.1 extrafontdb_1.0 ## [49] pkgconfig_2.0.3 Matrix_1.3-4 ellipsis_0.3.2 prettyunits_1.1.1 ## [53] assertthat_0.2.1 rmarkdown_2.9 R6_2.5.0 nlme_3.1-152 ## [57] compiler_4.1.0 "],["chap-generalized-linear-models.html", "第 24 章 广义线性模型", " 第 24 章 广义线性模型 It’s not meant for sampling weights. It’s meant for precision weights. How best to include sampling weights in mixed models is a research problem at the moment, but you can rely on getting the wrong answer if you just use the weights = argument. — Thomas Lumley43 一般广义线性模型理论参考文献 An Introduction to Generalized Linear Models (Dobson and Barnett 2018) 和 Generalized Linear Models (McCullagh and Nelder 1989)，逻辑回归模型主要参考 Applied Logistic Regression (Hosmer and Lemeshow 2000) 和 Discrete Choice Methods with Simulation (Train 2009)。 简单线性模型（Linear Models，简称 LM），stats::lm() 函数可以拟合线性模型，而一般线性模型（General Linear Models，简称 GLM）允许线性模型方差非齐性、存在相关关系，甚至可以扩展到线性混合效应模型，将线性回归模型，方差分析模型，协方差分析模型统一地看待，一般要采用广义最小二乘（Generalized Least Squares，简称 GLS）拟合， nlme::gls() 函数实现广义最小二乘拟合线性模型，类似地，nlme::gnls() 函数实现广义最小二乘拟合非线性模型。glm2::glm2() 补充 glm()，提供更加稳定的拟合方法，适应于 glm() 不收敛的情况，而 fastglm::fastglm() 主要是加快 glm() 求解效率，收敛效果也比 glm() 和 glm2() 好。 glmnet 包是处理广义线性模型的事实标准。 其官网见 https://glmnet.stanford.edu/，而 glmnetUtils 补充公式接口，适用于弹性网络回归，交叉验证筛选 \\(\\alpha\\) 参数等。 glmpath 包实现 path-following 算法用于带 L1 正则项的广义线性模型和 Cox 比例风险模型。Boom 和 BoomSpikeSlab 包实现 MCMC 算法用于 Spike 和 Slab 回归，而 spikeslab 包进一步实现预测和变量选择 (Ishwaran and Rao 2005)。Cyclops 包实现 Cyclic coordinate descent 算法 用于逻辑回归、泊松回归和生存分析，适用于大规模正则回归 large scale regularized regressions，达到百万级别的观测和特征变量，交叉验证自动选择超参数，独立变量稀疏表示，用剖面似然估计某个变量的置信区间。plsRglm 包实现偏最小二乘回归方法用于广义线性模型。biglm、speedglm 和 bigReg 用于处理大数据集的回归，求解限制内存的 GLM biglmm。cglm 估计带聚类数据的条件 GLM 的回归系数和发散参数。MGLM 拟合多个响应变量的广义线性回归模型（多重 GLM ）。robmixglm 响应变量扩展到混合分布的情形，实现稳健 GLM 回归估计。ClusterBootstrap 实现自主法估计带聚类数据的 GLM。lcpm 和 oglmx 处理有序输出的回归。 gmnl、 mlogit (Train 2009) 和 mnlogit (Hasan, Wang, and Mahani 2016) 处理多项逻辑回归。pscl 包（Political Science Computational Laboratory）可以处理贝叶斯 IRT 模型，zero-inflated 零膨胀模型，广义线性模型的拟合优度度量。 参考文献 "],["sec-glm-introduction.html", "24.1 介绍", " 24.1 介绍 模型结构，模型种类，参数估计办法，相当于综述 响应变量分别服从二项分布、多项分布、对数正态分布、泊松分布、伽马分布 "],["sec-glm-theory.html", "24.2 理论基础", " 24.2 理论基础 分两个段落分别介绍指数族和 GLM \\[ f(y;\\theta,\\phi) = \\exp[(a(y) b(\\theta) + c(\\theta))/f(\\phi) + d(y,\\phi)] \\] 泊松分布 (with \\(\\lambda \\to \\theta\\), \\(x \\to y\\)) (\\(\\phi=1\\)): \\[\\begin{equation} \\begin{split} f(y,\\theta) &amp; = \\exp(-\\theta) \\theta^y/(y!) \\\\ &amp; = \\exp\\left( \\underbrace{y}_{a(y)} \\underbrace{\\log \\theta}_{b(\\theta)} + \\underbrace{(-\\theta)}_{c(\\theta)} + \\underbrace{(- \\log(y!))}_{d(y)} \\right) \\end{split} \\end{equation}\\] 24.2.1 岭回归 Geometry and properties of generalized ridge regression in high dimensions http://web.ccs.miami.edu/~hishwaran/papers/IR.conmath2014.pdf 这篇文章借助三维几何图形展示高维情形下的广义岭回归 24.2.2 Lasso glmnet: Lasso and Elastic-Net Regularized Generalized Linear Models https://glmnet.stanford.edu 24.2.3 最优子集回归 bestglm: Best Subset GLM and Regression Utilities 24.2.4 偏最小二乘回归 pls 包 (Mevik and Wehrens 2007) 实现了偏最小二乘回归（partial least squares regression， PLS）和主成分回归 （principal component regression， PCR），详见主页 https://mevik.net/work/software/pls.html 帮助文档的质量较高，是比较完整全面的。 several algorithms: the traditional orthogonal scores (NIPALS) PLS algorithm, kernel PLS, wide kernel PLS, Simpls and PCR through svd supports multi-response models (aka PLS2) flexible cross-validation Jackknife variance estimates of regression coefficients extensive and flexible plots: scores, loadings, predictions, coefficients, (R)MSEP, R², correlation loadings formula interface, modelled after lm(), with methods for predict, print, summary, plot, update, etc. extraction functions for coefficients, scores and loadings MSEP, RMSEP and R² estimates multiplicative scatter correction (MSC) 参考文献 "],["sec-alcohol.html", "24.3 吸烟喝酒和食道癌的关系", " 24.3 吸烟喝酒和食道癌的关系 存在有序分类数据 酒精的作用 effects of alcohol, tobacco and interaction, age-adjusted 数据集描述见 help(esoph) head(esoph) ## agegp alcgp tobgp ncases ncontrols ## 1 25-34 0-39g/day 0-9g/day 0 40 ## 2 25-34 0-39g/day 10-19 0 10 ## 3 25-34 0-39g/day 20-29 0 6 ## 4 25-34 0-39g/day 30+ 0 5 ## 5 25-34 40-79 0-9g/day 0 27 ## 6 25-34 40-79 10-19 0 7 str(esoph) ## &#39;data.frame&#39;: 88 obs. of 5 variables: ## $ agegp : Ord.factor w/ 6 levels &quot;25-34&quot;&lt;&quot;35-44&quot;&lt;..: 1 1 1 1 1 1 1 1 1 1 ... ## $ alcgp : Ord.factor w/ 4 levels &quot;0-39g/day&quot;&lt;&quot;40-79&quot;&lt;..: 1 1 1 1 2 2 2 2 3 3 ... ## $ tobgp : Ord.factor w/ 4 levels &quot;0-9g/day&quot;&lt;&quot;10-19&quot;&lt;..: 1 2 3 4 1 2 3 4 1 2 ... ## $ ncases : num 0 0 0 0 0 0 0 0 0 0 ... ## $ ncontrols: num 40 10 6 5 27 7 4 7 2 1 ... p1 &lt;- ggplot(data = esoph, aes(x = agegp, y = ncases / ncontrols, color = agegp)) + geom_boxplot(show.legend = FALSE) + geom_jitter(show.legend = FALSE) + theme_minimal() p2 &lt;- ggplot(data = esoph, aes(x = alcgp, y = ncases / ncontrols, color = alcgp)) + geom_boxplot(show.legend = FALSE) + geom_jitter(show.legend = FALSE) + theme_minimal() p3 &lt;- ggplot(data = esoph, aes(x = tobgp, y = ncases / ncontrols, color = tobgp)) + geom_boxplot(show.legend = FALSE) + geom_jitter(show.legend = FALSE) + theme_minimal() bottom_row &lt;- plot_grid(p2, p3, labels = c(&#39;B&#39;, &#39;C&#39;), label_size = 12) ## Warning: Removed 12 rows containing non-finite values (stat_boxplot). ## Warning: Removed 12 rows containing missing values (geom_point). ## Warning: Removed 12 rows containing non-finite values (stat_boxplot). ## Warning: Removed 12 rows containing missing values (geom_point). plot_grid(p1, bottom_row, labels = c(&#39;A&#39;, &#39;&#39;), label_size = 12, ncol = 1) ## Warning: Removed 12 rows containing non-finite values (stat_boxplot). ## Warning: Removed 12 rows containing missing values (geom_point). 图 24.1: 吸烟喝酒和食道癌的关系 fit_esoph_glm &lt;- glm(cbind(ncases, ncontrols) ~ agegp + tobgp * alcgp, data = esoph, family = binomial(link = &quot;logit&quot;) ) library(Rcpp) fit_esoph_brm &lt;- brms::brm(ncases | trials(ncases + ncontrols) ~ agegp + tobgp * alcgp, data = esoph, family = binomial(link = &quot;logit&quot;), refresh = 0 ) "],["sec-infert.html", "24.4 自然流产和人工流产后的不育", " 24.4 自然流产和人工流产后的不育 help(infert) head(infert) ## education age parity induced case spontaneous stratum pooled.stratum ## 1 0-5yrs 26 6 1 1 2 1 3 ## 2 0-5yrs 42 1 1 1 0 2 1 ## 3 0-5yrs 39 6 2 1 0 3 4 ## 4 0-5yrs 34 4 2 1 0 4 2 ## 5 6-11yrs 35 3 1 1 1 5 32 ## 6 6-11yrs 36 4 2 1 1 6 36 str(infert) ## &#39;data.frame&#39;: 248 obs. of 8 variables: ## $ education : Factor w/ 3 levels &quot;0-5yrs&quot;,&quot;6-11yrs&quot;,..: 1 1 1 1 2 2 2 2 2 2 ... ## $ age : num 26 42 39 34 35 36 23 32 21 28 ... ## $ parity : num 6 1 6 4 3 4 1 2 1 2 ... ## $ induced : num 1 1 2 2 1 2 0 0 0 0 ... ## $ case : num 1 1 1 1 1 1 1 1 1 1 ... ## $ spontaneous : num 2 0 0 0 1 1 0 0 1 0 ... ## $ stratum : int 1 2 3 4 5 6 7 8 9 10 ... ## $ pooled.stratum: num 3 1 4 2 32 36 6 22 5 19 ... 存在无序分类变量 infert_glm_1 &lt;- glm(case ~ spontaneous + induced, data = infert, family = binomial() ) summary(infert_glm_1) ## ## Call: ## glm(formula = case ~ spontaneous + induced, family = binomial(), ## data = infert) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.6678 -0.8360 -0.5772 0.9030 1.9362 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.7079 0.2677 -6.380 1.78e-10 *** ## spontaneous 1.1972 0.2116 5.657 1.54e-08 *** ## induced 0.4181 0.2056 2.033 0.042 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 316.17 on 247 degrees of freedom ## Residual deviance: 279.61 on 245 degrees of freedom ## AIC: 285.61 ## ## Number of Fisher Scoring iterations: 4 考虑其他潜在的因素 infert_glm_2 &lt;- glm(case ~ age + parity + education + spontaneous + induced, data = infert, family = binomial() ) summary(infert_glm_2) ## ## Call: ## glm(formula = case ~ age + parity + education + spontaneous + ## induced, family = binomial(), data = infert) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.7603 -0.8162 -0.4956 0.8349 2.6536 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.14924 1.41220 -0.814 0.4158 ## age 0.03958 0.03120 1.269 0.2046 ## parity -0.82828 0.19649 -4.215 2.49e-05 *** ## education6-11yrs -1.04424 0.79255 -1.318 0.1876 ## education12+ yrs -1.40321 0.83416 -1.682 0.0925 . ## spontaneous 2.04591 0.31016 6.596 4.21e-11 *** ## induced 1.28876 0.30146 4.275 1.91e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 316.17 on 247 degrees of freedom ## Residual deviance: 257.80 on 241 degrees of freedom ## AIC: 271.8 ## ## Number of Fisher Scoring iterations: 4 实际上应该使用条件逻辑回归， 调用 survival 包 library(survival) infert_glm_3 &lt;- clogit(case ~ spontaneous + induced + strata(stratum), data = infert ) summary(infert_glm_3) ## Call: ## coxph(formula = Surv(rep(1, 248L), case) ~ spontaneous + induced + ## strata(stratum), data = infert, method = &quot;exact&quot;) ## ## n= 248, number of events= 83 ## ## coef exp(coef) se(coef) z Pr(&gt;|z|) ## spontaneous 1.9859 7.2854 0.3524 5.635 1.75e-08 *** ## induced 1.4090 4.0919 0.3607 3.906 9.38e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## exp(coef) exp(-coef) lower .95 upper .95 ## spontaneous 7.285 0.1373 3.651 14.536 ## induced 4.092 0.2444 2.018 8.298 ## ## Concordance= 0.776 (se = 0.044 ) ## Likelihood ratio test= 53.15 on 2 df, p=3e-12 ## Wald test = 31.84 on 2 df, p=1e-07 ## Score (logrank) test = 48.44 on 2 df, p=3e-11 "],["sec-australia-bacteria.html", "24.5 细菌数据集", " 24.5 细菌数据集 流感嗜血杆菌的细菌与中耳炎患儿 data(bacteria, package = &quot;MASS&quot;) # 惩罚拟似然 fit_glmmpql &lt;- MASS::glmmPQL(y ~ trt + I(week &gt; 2), random = ~ 1 | ID, verbose = FALSE, family = binomial, data = bacteria ) summary(fit_glmmpql) ## Linear mixed-effects model fit by maximum likelihood ## Data: bacteria ## AIC BIC logLik ## NA NA NA ## ## Random effects: ## Formula: ~1 | ID ## (Intercept) Residual ## StdDev: 1.410637 0.7800511 ## ## Variance function: ## Structure: fixed weights ## Formula: ~invwt ## Fixed effects: y ~ trt + I(week &gt; 2) ## Value Std.Error DF t-value p-value ## (Intercept) 3.412014 0.5185033 169 6.580506 0.0000 ## trtdrug -1.247355 0.6440635 47 -1.936696 0.0588 ## trtdrug+ -0.754327 0.6453978 47 -1.168779 0.2484 ## I(week &gt; 2)TRUE -1.607257 0.3583379 169 -4.485311 0.0000 ## Correlation: ## (Intr) trtdrg trtdr+ ## trtdrug -0.598 ## trtdrug+ -0.571 0.460 ## I(week &gt; 2)TRUE -0.537 0.047 -0.001 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -5.1985361 0.1572336 0.3513075 0.4949482 1.7448845 ## ## Number of Observations: 220 ## Number of Groups: 50 # 拉普拉斯近似 fit_glmer &lt;- lme4::glmer(y ~ trt + I(week &gt; 2) + (1 | ID), family = binomial, data = bacteria ) summary(fit_glmer) ## Generalized linear mixed model fit by maximum likelihood (Laplace ## Approximation) [glmerMod] ## Family: binomial ( logit ) ## Formula: y ~ trt + I(week &gt; 2) + (1 | ID) ## Data: bacteria ## ## AIC BIC logLik deviance df.resid ## 202.3 219.2 -96.1 192.3 215 ## ## Scaled residuals: ## Min 1Q Median 3Q Max ## -4.5615 0.1359 0.3022 0.4217 1.1276 ## ## Random effects: ## Groups Name Variance Std.Dev. ## ID (Intercept) 1.543 1.242 ## Number of obs: 220, groups: ID, 50 ## ## Fixed effects: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 3.5479 0.6958 5.099 3.41e-07 *** ## trtdrug -1.3667 0.6770 -2.019 0.043516 * ## trtdrug+ -0.7826 0.6831 -1.146 0.251926 ## I(week &gt; 2)TRUE -1.5985 0.4759 -3.359 0.000783 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Correlation of Fixed Effects: ## (Intr) trtdrg trtdr+ ## trtdrug -0.593 ## trtdrug+ -0.537 0.487 ## I(wk&gt;2)TRUE -0.656 0.126 0.064 "],["sec-birthwt.html", "24.6 研究婴儿出生体重低的相关危险因素", " 24.6 研究婴儿出生体重低的相关危险因素 在线性回归的基础上，响应变量是离散的类别，且无序 (Hasan, Wang, and Mahani 2016) birthwt 数据是 1986 年在马萨诸塞州斯普林菲尔德的 Baystate 医疗中心收集的，用于研究婴儿出生体重低的相关危险因素 # 加载数据 # library(MASS) data(birthwt, package = &quot;MASS&quot;) # 查看 birthwt 数据集 `help(birthwt)` head(birthwt) ## low age lwt race smoke ptl ht ui ftv bwt ## 85 0 19 182 2 0 0 0 1 0 2523 ## 86 0 33 155 3 0 0 0 0 3 2551 ## 87 0 20 105 1 1 0 0 0 1 2557 ## 88 0 21 108 1 1 0 0 1 2 2594 ## 89 0 18 107 1 1 0 0 1 0 2600 ## 91 0 21 124 3 0 0 0 0 0 2622 str(birthwt) ## &#39;data.frame&#39;: 189 obs. of 10 variables: ## $ low : int 0 0 0 0 0 0 0 0 0 0 ... ## $ age : int 19 33 20 21 18 21 22 17 29 26 ... ## $ lwt : int 182 155 105 108 107 124 118 103 123 113 ... ## $ race : int 2 3 1 1 1 3 1 3 1 1 ... ## $ smoke: int 0 0 1 1 1 0 0 0 1 1 ... ## $ ptl : int 0 0 0 0 0 0 0 0 0 0 ... ## $ ht : int 0 0 0 0 0 0 0 0 0 0 ... ## $ ui : int 1 0 0 1 1 0 0 0 0 0 ... ## $ ftv : int 0 3 1 2 0 0 1 1 1 0 ... ## $ bwt : int 2523 2551 2557 2594 2600 2622 2637 2637 2663 2665 ... low 表示婴儿出生体重小于 2.5kg，age 表示母亲的年龄（年），lwt 母亲最后一次月经期间的体重(磅)，race 母亲的种族(1 =白人，2 =黑人，3 =其他)。，smoke 怀孕期间的吸烟状况，ptl 以前早产的次数，ht 高血压病史，ui 子宫过敏，ftv 妊娠头三个月的医生就诊次数，bwt 出生体重（克） with(birthwt, tapply(lwt, ui, var)) ## 0 1 ## 940.8472 783.7196 t.test(lwt ~ ui, data = birthwt, var.equal = TRUE) ## ## Two Sample t-test ## ## data: lwt by ui ## t = 2.1138, df = 187, p-value = 0.03586 ## alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 ## 95 percent confidence interval: ## 0.8753389 25.3544748 ## sample estimates: ## mean in group 0 mean in group 1 ## 131.7578 118.6429 t.test(lwt ~ ui, data = birthwt) ## ## Welch Two Sample t-test ## ## data: lwt by ui ## t = 2.2547, df = 39.163, p-value = 0.02982 ## alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 ## 95 percent confidence interval: ## 1.351128 24.878685 ## sample estimates: ## mean in group 0 mean in group 1 ## 131.7578 118.6429 # birthwt$ui &lt;- as.factor(birthwt$ui) # library(lattice) # bwplot(lwt ~ ui, data = birthwt, pch = &quot;|&quot;) boxplot(lwt ~ ui, data = birthwt) # 重新编码，数据预处理，方便代入模型 bwt &lt;- with(birthwt, { race &lt;- factor(race, labels = c(&quot;white&quot;, &quot;black&quot;, &quot;other&quot;)) ptd &lt;- factor(ptl &gt; 0) ftv &lt;- factor(ftv) levels(ftv)[-(1:2)] &lt;- &quot;2+&quot; # 除了前两个水平外，其余的都编码为 2+ data.frame( low = factor(low), age, lwt, race, smoke = (smoke &gt; 0), ptd, ht = (ht &gt; 0), ui = (ui &gt; 0), ftv ) }) # 查看编码后的数据 head(bwt) ## low age lwt race smoke ptd ht ui ftv ## 1 0 19 182 black FALSE FALSE FALSE TRUE 0 ## 2 0 33 155 other FALSE FALSE FALSE FALSE 2+ ## 3 0 20 105 white TRUE FALSE FALSE FALSE 1 ## 4 0 21 108 white TRUE FALSE FALSE TRUE 2+ ## 5 0 18 107 white TRUE FALSE FALSE TRUE 0 ## 6 0 21 124 other FALSE FALSE FALSE FALSE 0 str(bwt) ## &#39;data.frame&#39;: 189 obs. of 9 variables: ## $ low : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ age : int 19 33 20 21 18 21 22 17 29 26 ... ## $ lwt : int 182 155 105 108 107 124 118 103 123 113 ... ## $ race : Factor w/ 3 levels &quot;white&quot;,&quot;black&quot;,..: 2 3 1 1 1 3 1 3 1 1 ... ## $ smoke: logi FALSE FALSE TRUE TRUE TRUE FALSE ... ## $ ptd : Factor w/ 2 levels &quot;FALSE&quot;,&quot;TRUE&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ ht : logi FALSE FALSE FALSE FALSE FALSE FALSE ... ## $ ui : logi TRUE FALSE FALSE TRUE TRUE FALSE ... ## $ ftv : Factor w/ 3 levels &quot;0&quot;,&quot;1&quot;,&quot;2+&quot;: 1 3 2 3 1 1 2 2 2 1 ... 广义线性模型拟合，二项逻辑回归，响应变量为婴儿出生的体重，以2.5kg为界，它被编码成二分类变量 0或1 options(contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;)) glm(formula = low ~ ., family = binomial, data = bwt) ## ## Call: glm(formula = low ~ ., family = binomial, data = bwt) ## ## Coefficients: ## (Intercept) age lwt raceblack raceother smokeTRUE ## 0.82302 -0.03723 -0.01565 1.19241 0.74068 0.75553 ## ptdTRUE htTRUE uiTRUE ftv1 ftv2+ ## 1.34376 1.91317 0.68020 -0.43638 0.17901 ## ## Degrees of Freedom: 188 Total (i.e. Null); 178 Residual ## Null Deviance: 234.7 ## Residual Deviance: 195.5 AIC: 217.5 多项逻辑回归 library(nnet) (bwt.mu &lt;- multinom(formula = low ~ ., data = bwt)) ## # weights: 12 (11 variable) ## initial value 131.004817 ## iter 10 value 98.029803 ## final value 97.737759 ## converged ## Call: ## multinom(formula = low ~ ., data = bwt) ## ## Coefficients: ## (Intercept) age lwt raceblack raceother smokeTRUE ## 0.82320102 -0.03723828 -0.01565359 1.19240391 0.74065606 0.75550487 ## ptdTRUE htTRUE uiTRUE ftv1 ftv2+ ## 1.34375901 1.91320116 0.68020207 -0.43638470 0.17900392 ## ## Residual Deviance: 195.4755 ## AIC: 217.4755 summary(bwt.mu) ## Call: ## multinom(formula = low ~ ., data = bwt) ## ## Coefficients: ## Values Std. Err. ## (Intercept) 0.82320102 1.24476766 ## age -0.03723828 0.03870437 ## lwt -0.01565359 0.00708079 ## raceblack 1.19240391 0.53598076 ## raceother 0.74065606 0.46176615 ## smokeTRUE 0.75550487 0.42503626 ## ptdTRUE 1.34375901 0.48063449 ## htTRUE 1.91320116 0.72076133 ## uiTRUE 0.68020207 0.46434974 ## ftv1 -0.43638470 0.47941107 ## ftv2+ 0.17900392 0.45639129 ## ## Residual Deviance: 195.4755 ## AIC: 217.4755 计算 Z 分数和 P 值 z &lt;- summary(bwt.mu)$coefficients / summary(bwt.mu)$standard.errors z ## (Intercept) age lwt raceblack raceother smokeTRUE ## 0.6613291 -0.9621210 -2.2107121 2.2247140 1.6039635 1.7775069 ## ptdTRUE htTRUE uiTRUE ftv1 ftv2+ ## 2.7958023 2.6544170 1.4648486 -0.9102516 0.3922159 p &lt;- (1 - pnorm(abs(z), 0, 1)) * 2 p ## (Intercept) age lwt raceblack raceother smokeTRUE ## 0.508401310 0.335988847 0.027055777 0.026100443 0.108722092 0.075484881 ## ptdTRUE htTRUE uiTRUE ftv1 ftv2+ ## 0.005177106 0.007944557 0.142962228 0.362689827 0.694898695 模型解释 参考文献 "],["sec-housing.html", "24.7 哥本哈根住房状况调查", " 24.7 哥本哈根住房状况调查 响应变量是离散类别，且存在强弱，等级，大小之分 调用函数 MASS::polr() 数据集 housing 哥本哈根住房状况调查中的次数分布表，Sat 住户对目前居住环境的满意程度，是一个有序的因子变量，Infl 住户对物业管理的感知影响程度，Type 租赁住宿类型，如塔楼、中庭、公寓、露台，Cont 联系居民可与其他居民联系(低、高)，Freq 每个类中的居民人数，调查的人数 data(&quot;housing&quot;, package = &quot;MASS&quot;) # 查看数据 help(housing) head(housing) ## Sat Infl Type Cont Freq ## 1 Low Low Tower Low 21 ## 2 Medium Low Tower Low 21 ## 3 High Low Tower Low 28 ## 4 Low Medium Tower Low 34 ## 5 Medium Medium Tower Low 22 ## 6 High Medium Tower Low 36 str(housing) ## &#39;data.frame&#39;: 72 obs. of 5 variables: ## $ Sat : Ord.factor w/ 3 levels &quot;Low&quot;&lt;&quot;Medium&quot;&lt;..: 1 2 3 1 2 3 1 2 3 1 ... ## $ Infl: Factor w/ 3 levels &quot;Low&quot;,&quot;Medium&quot;,..: 1 1 1 2 2 2 3 3 3 1 ... ## $ Type: Factor w/ 4 levels &quot;Tower&quot;,&quot;Apartment&quot;,..: 1 1 1 1 1 1 1 1 1 2 ... ## $ Cont: Factor w/ 2 levels &quot;Low&quot;,&quot;High&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Freq: int 21 21 28 34 22 36 10 11 36 61 ... 居民对居住环境满意度 Sat 三个等级的有序回归 options(contrasts = c(&quot;contr.treatment&quot;, &quot;contr.poly&quot;)) house.plr &lt;- MASS::polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing) house.plr ## Call: ## MASS::polr(formula = Sat ~ Infl + Type + Cont, data = housing, ## weights = Freq) ## ## Coefficients: ## InflMedium InflHigh TypeApartment TypeAtrium TypeTerrace ## 0.5663937 1.2888191 -0.5723501 -0.3661866 -1.0910149 ## ContHigh ## 0.3602841 ## ## Intercepts: ## Low|Medium Medium|High ## -0.4961353 0.6907083 ## ## Residual Deviance: 3479.149 ## AIC: 3495.149 再计算一下 P 值，置信区间 ctable &lt;- coef(summary(house.plr)) p &lt;- pnorm(abs(ctable[, &quot;t value&quot;]), lower.tail = FALSE) * 2 ctable &lt;- cbind(ctable, &quot;p value&quot; = p) # confidence intervals 计算置信区间 ci &lt;- confint(house.plr) exp(coef(house.plr)) ## InflMedium InflHigh TypeApartment TypeAtrium TypeTerrace ## 1.7619017 3.6284990 0.5641979 0.6933734 0.3358754 ## ContHigh ## 1.4337368 ## OR and CI exp(cbind(OR = coef(house.plr), ci)) ## OR 2.5 % 97.5 % ## InflMedium 1.7619017 1.4356845 2.1639915 ## InflHigh 3.6284990 2.8319659 4.6626461 ## TypeApartment 0.5641979 0.4462124 0.7121941 ## TypeAtrium 0.6933734 0.5114084 0.9398410 ## TypeTerrace 0.3358754 0.2492277 0.4514276 ## ContHigh 1.4337368 1.1892931 1.7296674 模型解释 参考文档 help(housing) 包含泊松回归、多项回归、比例风险模型，以及 https://www.analyticsvidhya.com/blog/2016/02/multinomial-ordinal-logistic-regression/ 好好看文档 help(housing) 和对应的参考书籍，把原理弄清楚 有序因子变量是如何实现编码的 "],["sec-epileptics-counts.html", "24.8 癫痫病发作次数", " 24.8 癫痫病发作次数 纵向数据 (Thall and Vail 1990)，考虑了过度发散 overdispersion 异方差 heteroscedasticity 观测不独立 数据集 epil 记录癫痫发作的次数及病人的特征，下面是数据建模分析过程 data(epil, package = &quot;MASS&quot;) fit_glm_epil &lt;- glm(y ~ lbase * trt + lage + V4, family = poisson, data = epil ) summary(fit_glm_epil) fit_glmm_epil&lt;- MASS::glmmPQL(y ~ lbase * trt + lage + V4, random = ~ 1 | subject, family = poisson, data = epil ) summary(fit_glmm_epil) fit_glmm_lme4 &lt;- lme4::glmer(y ~ lbase * trt + lage + V4 + (1 | subject), family = poisson, data = epil ) summary(fit_glmm_lme4) fit_glmm_glmmtmb &lt;- glmmTMB::glmmTMB(y ~ lbase * trt + lage + V4 + (1 | subject), data = epil, family = poisson, REML = TRUE ) # REML 估计 summary(fit_glmm_glmmtmb) # https://github.com/drizopoulos/GLMMadaptive fit_glmm_glmmadaptive &lt;- GLMMadaptive::mixed_model( fixed = y ~ lbase * trt + lage + V4, random = ~ 1 | subject, data = epil, family = poisson() ) summary(fit_glmm_glmmadaptive) 参考文献 "],["sec-generalized-log-linear-model.html", "24.9 对数线性模型", " 24.9 对数线性模型 当响应变量 \\(Y\\) 服从对数正态分布的时候，广义线性模型具化为对数线性模型，gllm 包 (Espeland and Hui 1987) 参考文献 "],["sec-generalized-possion-linear-model.html", "24.10 泊松回归模型", " 24.10 泊松回归模型 加载数据 data(beall.webworms, package = &quot;agridat&quot;) 查看数据 head(beall.webworms) ## row col y block trt spray lead ## 1 1 1 1 B1 T1 N N ## 2 2 1 0 B1 T1 N N ## 3 3 1 1 B1 T1 N N ## 4 4 1 3 B1 T1 N N ## 5 5 1 6 B1 T1 N N ## 6 6 1 0 B2 T1 N N 描述响应变量的分布 hist(beall.webworms$y, main = &quot;Histogram of Worm Count&quot;, xlab = &quot;Number of Worms&quot;) boxplot(y ~ trt, data = beall.webworms) 抖动图 plot(y ~ trt, data = beall.webworms, xlab = &quot;Types of Worms&quot;, ylab = &quot;Worm Count&quot;) ggplot(beall.webworms, aes(trt, y)) + geom_boxplot(colour = &quot;red&quot;) + geom_jitter() + labs(x = &quot;Types of Worms&quot;, y = &quot;Worm Count&quot;) + theme_minimal() pois.mod &lt;- glm(y ~ trt, data = beall.webworms, family = &quot;poisson&quot;) summary(pois.mod) ## ## Call: ## glm(formula = y ~ trt, family = &quot;poisson&quot;, data = beall.webworms) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.6733 -1.0046 -0.9081 0.6141 4.2771 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.33647 0.04688 7.177 7.12e-13 *** ## trtT2 -1.02043 0.09108 -11.204 &lt; 2e-16 *** ## trtT3 -0.49628 0.07621 -6.512 7.41e-11 *** ## trtT4 -1.22246 0.09829 -12.438 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 1955.9 on 1299 degrees of freedom ## Residual deviance: 1720.4 on 1296 degrees of freedom ## AIC: 3125.5 ## ## Number of Fisher Scoring iterations: 6 模型系数 T2 的解释，这里 GLM 使用了对数联系函数(log link function) ，因此 -1.02 是对数变换后的值，T2的系数实际是 0.3605949 ，实际意义是相对于T1，T2 类型的蠕虫数量是 T1 的 0.3605949 倍 The first valuable information is related to the residuals of the model, which should be symmetrical as for any normal linear model. From this output we can see that minimum and maximum, as well as the first and third quartiles, are similar, so this assumption is confirmed. Then we can see that the variable trt (i.e. treatment factor) is highly significant for the model, with very low p-values. The statistical test in this case is not a t-test, as in the output of the function lm, but a Wald Test (Wald Test). This test computes the probability that the coefficient is 0, if the p is significant it means the chances the coefficient is zero are very low so the variable should be included in the model since it has an effect on y. Another important information is the deviance, particularly the residual deviance. As a general rule, this value should be lower or in line than the residuals degrees of freedom for the model to be good. In this case the fact that the residual deviance is high (even though not dramatically) may suggests the explanatory power of the model is low. We will see below how to obtain p-value for the significance of the model. par(mfrow = c(2, 2)) plot(pois.mod) predict(pois.mod, newdata = data.frame(trt = c(&quot;T1&quot;, &quot;T2&quot;))) ## 1 2 ## 0.3364722 -0.6839588 模型的P值 1 - pchisq(deviance(pois.mod), df.residual(pois.mod)) ## [1] 1.709743e-14 模型选择 pois.mod2 &lt;- glm(y ~ block + spray * lead, data = beall.webworms, family = &quot;poisson&quot;) 两模型的 AIC 比较 AIC(pois.mod, pois.mod2) ## df AIC ## pois.mod 4 3125.478 ## pois.mod2 16 3027.438 假设响应变量 Y 服从泊松分布，意味着随机变量 Y 的期望和方差相等 mean(beall.webworms$y) ## [1] 0.7923077 var(beall.webworms$y) ## [1] 1.290164 实际上方差比均值大，这种情况称之为过度发散 (overdispersed)，分布应该修正为拟（似然）泊松分布 pois.mod3 &lt;- glm(y ~ trt, data = beall.webworms, family = c(&quot;quasipoisson&quot;)) summary(pois.mod3) ## ## Call: ## glm(formula = y ~ trt, family = c(&quot;quasipoisson&quot;), data = beall.webworms) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.6733 -1.0046 -0.9081 0.6141 4.2771 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.33647 0.05457 6.166 9.32e-10 *** ## trtT2 -1.02043 0.10601 -9.626 &lt; 2e-16 *** ## trtT3 -0.49628 0.08870 -5.595 2.69e-08 *** ## trtT4 -1.22246 0.11440 -10.686 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for quasipoisson family taken to be 1.35472) ## ## Null deviance: 1955.9 on 1299 degrees of freedom ## Residual deviance: 1720.4 on 1296 degrees of freedom ## AIC: NA ## ## Number of Fisher Scoring iterations: 6 计算得知发散参数(dispersion parameter) 是 1.35472，可见数据Y并不是发散得离谱，泊松分布可能仍然是对这个数据的合理假设 AER 包是书籍 Applied Econometrics with R 的配套材料 (Kleiber and Zeileis 2008)，可用于直接检验发散参数是否大于1 # AER::dispersiontest(pois.mod, alternative=&quot;greater&quot;) 如果数据真的过度离散，就应该使用负二项分布作为响应变量的拟合分布，拟合它就采用 MASS 包 (Venables and Ripley 2002) 提供的 glm.nb函数 NB.mod1 &lt;- MASS::glm.nb(y ~ trt, data = beall.webworms) summary(NB.mod1) ## ## Call: ## MASS::glm.nb(formula = y ~ trt, data = beall.webworms, init.theta = 2.004130573, ## link = log) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.4572 -0.9488 -0.8660 0.5340 2.7698 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 0.33647 0.06110 5.507 3.65e-08 *** ## trtT2 -1.02043 0.10661 -9.572 &lt; 2e-16 *** ## trtT3 -0.49628 0.09423 -5.267 1.39e-07 *** ## trtT4 -1.22246 0.11283 -10.834 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for Negative Binomial(2.0041) family taken to be 1) ## ## Null deviance: 1442.7 on 1299 degrees of freedom ## Residual deviance: 1275.3 on 1296 degrees of freedom ## AIC: 3053 ## ## Number of Fisher Scoring iterations: 1 ## ## ## Theta: 2.004 ## Std. Err.: 0.325 ## ## 2 x log-likelihood: -3042.969 两个模型的方差分析 anova(pois.mod, pois.mod2, test = &quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model 1: y ~ trt ## Model 2: y ~ block + spray * lead ## Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) ## 1 1296 1720.4 ## 2 1284 1598.4 12 122.04 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 从方差分析比较的结果来看，P值告诉我们，两模型是显著不同的，由上面对两模型的 AIC 计算结果来看，模型 pois.mod2 比模型 pois.mod 要好，模型的 AIC 值越小，表明拟合得越准确。 参考文献 "],["chap-case-study.html", "第 25 章 案例研究", " 第 25 章 案例研究 提升回归模型的10个提示 10 quick tips to improve your regression modeling tidymodels 和 easystats 都是基于 tidyverse (Wickham et al. 2019) 的统计模型套件，strengejacke、 mlr3verse 目的和 tidymodels 差不多，都是提供做数据建模的完整解决方案，区别在于它不基于 tidyverse 这套东西。 easystats 包含 insight (Lüdecke, Waggoner, and Makowski 2019) 和 bayestestR (Makowski, Ben-Shachar, and Lüdecke 2019) 等共 9 个R 包，tidymodels 也包含差不多量的 R 包。 rms Regression Modeling Strategies modelsummary 整理模型输出，提供丰富的格式输出，如 PDF, Text/Markdown, LaTeX, MS Word, RTF, JPG, and PNG. DrWhy R for Data Science Online Learning Community 在线学习社区以 tidytuesday 闻名遐迩。 图 25.1: 模型 统计建模：两种文化 (Breiman 2001) 这些案例来自 Kaggle、 Tudesday 或者自己找的数据集，而不是论文里，或者 R 包里的小数据集，应该更加真实，贴近实际问题，考虑更多细节 参考文献 "],["sec-life-of-statisticians.html", "25.1 统计学家生平", " 25.1 统计学家生平 世纪统计学家 100 位统计学家，寿命的影响因素，关联分析，图展示数据本身的 注明每位统计学家所在的年代经历的重大事件，如欧洲中世纪霍乱，第二次世界大战，文化大革命，用图形来讲故事，展现数据可视化的魅力，参考文献 (Johnson and Kotz 1997) 参考文献 "],["sec-history-of-r.html", "25.2 R 语言发展历史", " 25.2 R 语言发展历史 R 语言发展历史和现状，用图来表达 "],["sec-PlantGrowth.html", "25.3 不同实验条件下植物生长情况", " 25.3 不同实验条件下植物生长情况 PlantGrowth 数据集收集自 Annette J. Dobson 所著书籍《An Introduction to Statistical Modelling》(Dobson 1983) 第 2 章第 2 节的案例 — 研究植物在两种不同试验条件下的生长情况，植物通过光合作用吸收土壤的养分和空气中的二氧化碳，完成积累，故以植物的干重来刻画植物的生长情况，首先将几乎相同的种子随机地分配到实验组和对照组，基于完全随机实验设计（completely randomized experimental design），经过预定的时间后，将植物收割，干燥并称重，结果如表 25.1 所示 # do.call(&quot;cbind&quot;, lapply(split(PlantGrowth, f = PlantGrowth$group), subset, select = &quot;weight&quot;)) ## 或者 library(magrittr) split(PlantGrowth, f = PlantGrowth$group) %&gt;% # 分组 lapply(., subset, select = &quot;weight&quot;) %&gt;% # 计算 Reduce(&quot;cbind&quot;, .) %&gt;% # 合并 setNames(., levels(PlantGrowth$group)) %&gt;% # 重命名 `colnames&lt;-`(., levels(PlantGrowth$group)) t %&gt;% knitr::kable(., caption = &quot;不同生长环境下植物的干重&quot;, row.names = TRUE, align = &quot;c&quot; ) 表 25.1: 不同生长环境下植物的干重 1 2 3 4 5 6 7 8 9 10 ctrl 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14 trt1 4.81 4.17 4.41 3.59 5.87 3.83 6.03 4.89 4.32 4.69 trt2 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26 设立对照组（控制组）ctrl 和实验组 trt1 和 trt2，比较不同的处理方式对植物干重的影响 summary(PlantGrowth) ## weight group ## Min. :3.590 ctrl:10 ## 1st Qu.:4.550 trt1:10 ## Median :5.155 trt2:10 ## Mean :5.073 ## 3rd Qu.:5.530 ## Max. :6.310 每个组都有10颗植物，生长情况如图25.2所示 图 25.2: 植物干重 实验条件 trt1 和 trt2 对植物生长状况有显著的影响，为了量化这种影响，建立线性回归模型 fit_sublm &lt;- lm(weight ~ group, data = PlantGrowth, subset = group %in% c(&quot;ctrl&quot;, &quot;trt1&quot;) ) anova(fit_sublm) ## Analysis of Variance Table ## ## Response: weight ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 1 0.6882 0.68820 1.4191 0.249 ## Residuals 18 8.7292 0.48496 summary(fit_sublm) ## ## Call: ## lm(formula = weight ~ group, data = PlantGrowth, subset = group %in% ## c(&quot;ctrl&quot;, &quot;trt1&quot;)) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.0710 -0.4938 0.0685 0.2462 1.3690 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.0320 0.2202 22.850 9.55e-15 *** ## grouptrt1 -0.3710 0.3114 -1.191 0.249 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6964 on 18 degrees of freedom ## Multiple R-squared: 0.07308, Adjusted R-squared: 0.02158 ## F-statistic: 1.419 on 1 and 18 DF, p-value: 0.249 下面再通过检验的方式比较实验组和对照组相比，是否有显著作用 # 控制组和实验组1比较 t.test(weight ~ group, data = PlantGrowth, subset = group %in% c(&quot;ctrl&quot;, &quot;trt1&quot;)) ## ## Welch Two Sample t-test ## ## data: weight by group ## t = 1.1913, df = 16.524, p-value = 0.2504 ## alternative hypothesis: true difference in means between group ctrl and group trt1 is not equal to 0 ## 95 percent confidence interval: ## -0.2875162 1.0295162 ## sample estimates: ## mean in group ctrl mean in group trt1 ## 5.032 4.661 # 控制组和实验组2比较 t.test(weight ~ group, data = PlantGrowth, subset = group %in% c(&quot;ctrl&quot;, &quot;trt2&quot;)) ## ## Welch Two Sample t-test ## ## data: weight by group ## t = -2.134, df = 16.786, p-value = 0.0479 ## alternative hypothesis: true difference in means between group ctrl and group trt2 is not equal to 0 ## 95 percent confidence interval: ## -0.98287213 -0.00512787 ## sample estimates: ## mean in group ctrl mean in group trt2 ## 5.032 5.526 检验结果表明，实验条件 trt2 会对植物生长产生显著效果，而实验条件 trt1 不会。在假定同方差的情况下，建立线性回归模型，同时考虑实验条件 trt1 和 trt2 # 模型拟合 fit_lm &lt;- lm(weight ~ group, data = PlantGrowth) ## 模型输出 summary(fit_lm) ## ## Call: ## lm(formula = weight ~ group, data = PlantGrowth) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.0710 -0.4180 -0.0060 0.2627 1.3690 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.0320 0.1971 25.527 &lt;2e-16 *** ## grouptrt1 -0.3710 0.2788 -1.331 0.1944 ## grouptrt2 0.4940 0.2788 1.772 0.0877 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.6234 on 27 degrees of freedom ## Multiple R-squared: 0.2641, Adjusted R-squared: 0.2096 ## F-statistic: 4.846 on 2 and 27 DF, p-value: 0.01591 ## 方差分析 anova(fit_lm) ## Analysis of Variance Table ## ## Response: weight ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## group 2 3.7663 1.8832 4.8461 0.01591 * ## Residuals 27 10.4921 0.3886 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## 参数估计 coef(summary(fit_lm)) ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 5.032 0.1971284 25.526514 1.936575e-20 ## grouptrt1 -0.371 0.2787816 -1.330791 1.943879e-01 ## grouptrt2 0.494 0.2787816 1.771996 8.768168e-02 模型输出整理成表 25.2 所示 表 25.2: 线性回归的输出 估计值 标准差 t 统计量 P 值 \\(\\alpha\\) 5.032 0.1971 25.5265 0.0000 \\(\\beta_1\\) -0.371 0.2788 -1.3308 0.1944 \\(\\beta_2\\) 0.494 0.2788 1.7720 0.0877 还可以将模型转化为数学公式 # 理论模型 equatiomatic::extract_eq(fit_lm) \\[ \\operatorname{weight} = \\alpha + \\beta_{1}(\\operatorname{group}_{\\operatorname{trt1}}) + \\beta_{2}(\\operatorname{group}_{\\operatorname{trt2}}) + \\epsilon \\] # 拟合模型 equatiomatic::extract_eq(fit_lm, use_coefs = TRUE) \\[ \\operatorname{\\widehat{weight}} = 5.03 - 0.37(\\operatorname{group}_{\\operatorname{trt1}}) + 0.49(\\operatorname{group}_{\\operatorname{trt2}}) \\] 进一步地，我们在线性模型的基础上考虑每个实验组有不同的方差，先做方差齐性检验。 bartlett.test(weight ~ group, data = PlantGrowth) ## ## Bartlett test of homogeneity of variances ## ## data: weight by group ## Bartlett&#39;s K-squared = 2.8786, df = 2, p-value = 0.2371 fligner.test(weight ~ group, data = PlantGrowth) ## ## Fligner-Killeen test of homogeneity of variances ## ## data: weight by group ## Fligner-Killeen:med chi-squared = 2.3499, df = 2, p-value = 0.3088 检验的结果显示，可以认为三个组的方差没有显著差异，但我们还是考虑每个组有不同的方差，看看放开假设能获得多少提升，后续会发现，从对数似然的角度来看，实际提升量很小，只有 7.72% 上面同时比较多个总体的方差，会发现方差没有显著差异，那么接下来在假定方差齐性的条件下，比较均值的差异是否显著？ # 参数检验，假定异方差 oneway.test(weight ~ group, data = PlantGrowth, var.equal = FALSE) ## ## One-way analysis of means (not assuming equal variances) ## ## data: weight and group ## F = 5.181, num df = 2.000, denom df = 17.128, p-value = 0.01739 # 参数检验，假定方差齐性 oneway.test(weight ~ group, data = PlantGrowth, var.equal = TRUE) ## ## One-way analysis of means ## ## data: weight and group ## F = 4.8461, num df = 2, denom df = 27, p-value = 0.01591 # 非参数检验 kruskal.test(weight ~ group, data = PlantGrowth) ## ## Kruskal-Wallis rank sum test ## ## data: weight by group ## Kruskal-Wallis chi-squared = 7.9882, df = 2, p-value = 0.01842 检验结果显示它们的均值是有显著差异的！ # 固定效应模型 fit_gls &lt;- nlme::gls(weight ~ 1, weights = nlme::varIdent(form = ~ 1 | group), data = PlantGrowth, method = &quot;REML&quot; ) summary(fit_gls) ## Generalized least squares fit by REML ## Model: weight ~ 1 ## Data: PlantGrowth ## AIC BIC logLik ## 70.48628 75.95547 -31.24314 ## ## Variance function: ## Structure: Different standard deviations per stratum ## Formula: ~1 | group ## Parameter estimates: ## ctrl trt1 trt2 ## 1.0000000 1.5825700 0.9230865 ## ## Coefficients: ## Value Std.Error t-value p-value ## (Intercept) 5.199759 0.1162421 44.73214 0 ## ## Standardized residuals: ## Min Q1 Med Q3 Max ## -1.74647988 -0.91870713 -0.07591108 0.60676033 2.03987301 ## ## Residual standard error: 0.5896195 ## Degrees of freedom: 30 total; 29 residual # 随机效应模型 fit_lme &lt;- nlme::lme(weight ~ 1, random = ~ 1 | group, data = PlantGrowth) summary(fit_lme) ## Linear mixed-effects model fit by REML ## Data: PlantGrowth ## AIC BIC logLik ## 67.44473 71.54662 -30.72237 ## ## Random effects: ## Formula: ~1 | group ## (Intercept) Residual ## StdDev: 0.3865976 0.6233746 ## ## Fixed effects: weight ~ 1 ## Value Std.Error DF t-value p-value ## (Intercept) 5.073 0.2505443 27 20.24792 0 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -1.854449795 -0.688750457 0.006389611 0.406096866 2.059729645 ## ## Number of Observations: 30 ## Number of Groups: 3 \\(\\sigma_i^2 = Var(\\epsilon_{ij}), i = 1,2,3\\) 表示第 \\(i\\) 组的方差， \\[ y_{ij} = \\mu + \\epsilon_{ij}, i = 1,2,3 \\] 其中 \\(\\mu\\) 是固定的未知参数，我们和之前假定同方差情形下的模型比较一下，现在异方差情况下模型提升的情况，从对数似然的角度来看 logLik(fit_lm) ## &#39;log Lik.&#39; -26.80952 (df=4) logLik(fit_lm, REML = TRUE) ## &#39;log Lik.&#39; -29.00481 (df=4) logLik(fit_gls) ## &#39;log Lik.&#39; -31.24314 (df=4) logLik(fit_lme) ## &#39;log Lik.&#39; -30.72237 (df=3) 进一步地，我们考虑两水平模型，认为不同的实验组其均值和方差都不一样，检验三样本均值是否相等？ \\(\\mu_1 = \\mu_2 = \\mu_3\\) 检验，这里因为每组的样本量都一样，因此考虑 Turkey 的 T 法检验，检验均值是否有显著差别，实际上这里因为实验组数量只有2个，可以两两比对，如前所述。但是这里我们想扩展一下，考虑多组比较的问题。 和上面用 gls 拟合的模型是一致的。 \\[\\begin{align} y_{ij}&amp; = \\mu_i + \\epsilon_{ij}, \\\\ \\mu_i &amp; = \\mu_{\\theta} + \\xi_i. \\quad i = 1,\\ldots,3; \\quad j = 1, \\ldots, 10. \\end{align}\\] 其中 \\(\\mu_i\\) 是随机的未知变量，服从均值为 \\(\\mu_{\\theta}\\) 方差为 \\(Var(\\xi_i) = \\tau^2\\) 的正态分布 我们用 MASS 包提供的 glmmPQL() 函数拟合该数据集 fit_lme_pql &lt;- MASS::glmmPQL(weight ~ 1, random = ~ 1 | group, verbose = FALSE, family = gaussian(), data = PlantGrowth ) summary(fit_lme_pql) ## Linear mixed-effects model fit by maximum likelihood ## Data: PlantGrowth ## AIC BIC logLik ## NA NA NA ## ## Random effects: ## Formula: ~1 | group ## (Intercept) Residual ## StdDev: 0.2944234 0.6233746 ## ## Variance function: ## Structure: fixed weights ## Formula: ~invwt ## Fixed effects: weight ~ 1 ## Value Std.Error DF t-value p-value ## (Intercept) 5.073 0.2080656 27 24.38174 0 ## ## Standardized Within-Group Residuals: ## Min Q1 Med Q3 Max ## -1.922640850 -0.734727623 0.004564386 0.405111223 1.991538416 ## ## Number of Observations: 30 ## Number of Groups: 3 我们再借助 brms 包从贝叶斯的角度来分析数据，并建模 # 贝叶斯模型 fit_brm &lt;- brms::brm(weight ~ group, data = PlantGrowth) # 参考 https://www.xiangyunhuang.com.cn/2019/05/normal-hierarchical-model/ library(Rcpp) fit_lme_brm &lt;- brms::brm(weight ~ 1 + (1 | group), data = PlantGrowth, family = gaussian(), refresh = 0, seed = 2019 ) summary(fit_lme_brm) 参考文献 "],["sec-orange.html", "25.4 橘树生长情况", " 25.4 橘树生长情况 Orange 数据集包含三个变量，记录了加利福尼亚南部的一个小树林中的五棵橘树的生长情况，在 datasets 包里，数据集保存为 c(\"nfnGroupedData\", \"nfGroupedData\", \"groupedData\", \"data.frame\") 类型的数据，同时具有着四个类的特点。 Tree: 有序的指示变量，根据5棵橘树的最大直径划分，测量值很可能是根据林务员常用的“胸围周长” age: 橘树的树龄，自 1968 年 12 月 31 日起按天计算 circumference: 橘树树干的周长，单位是毫米 查看部分数据的情况 head(Orange) ## Grouped Data: circumference ~ age | Tree ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 ## 6 1 1372 142 查看变量的属性 str(Orange) ## Classes &#39;nfnGroupedData&#39;, &#39;nfGroupedData&#39;, &#39;groupedData&#39; and &#39;data.frame&#39;: 35 obs. of 3 variables: ## $ Tree : Ord.factor w/ 5 levels &quot;3&quot;&lt;&quot;1&quot;&lt;&quot;5&quot;&lt;&quot;2&quot;&lt;..: 2 2 2 2 2 2 2 4 4 4 ... ## $ age : num 118 484 664 1004 1231 ... ## $ circumference: num 30 58 87 115 120 142 145 33 69 111 ... ## - attr(*, &quot;formula&quot;)=Class &#39;formula&#39; language circumference ~ age | Tree ## .. ..- attr(*, &quot;.Environment&quot;)=&lt;environment: R_EmptyEnv&gt; ## - attr(*, &quot;labels&quot;)=List of 2 ## ..$ x: chr &quot;Time since December 31, 1968&quot; ## ..$ y: chr &quot;Trunk circumference&quot; ## - attr(*, &quot;units&quot;)=List of 2 ## ..$ x: chr &quot;(days)&quot; ## ..$ y: chr &quot;(mm)&quot; 说明 5 棵树之间的大小关系是 3 &lt; 1 &lt; 5 &lt; 2 &lt; 4，这里的数字 1，2，3，4，5 只是对树的编号，第一次测量时树的大小关系在 R 内用有序因子来表示。 levels(Orange$Tree) ## [1] &quot;3&quot; &quot;1&quot; &quot;5&quot; &quot;2&quot; &quot;4&quot; 表 25.3 记录了 5 颗橘树自 1968 年 12 月 31 日以来的生长情况 # aggregate(data = Orange, circumference ~ age, FUN = mean) library(magrittr) reshape( data = Orange, v.names = &quot;circumference&quot;, idvar = &quot;Tree&quot;, timevar = &quot;age&quot;, direction = &quot;wide&quot;, sep = &quot;&quot; ) %&gt;% knitr::kable(., caption = &quot;躯干周长（毫米）随时间（天）的变化&quot;, row.names = FALSE, col.names = gsub(&quot;(circumference)&quot;, &quot;&quot;, names(.)), align = &quot;c&quot; ) 表 25.3: 躯干周长（毫米）随时间（天）的变化 Tree 118 484 664 1004 1231 1372 1582 1 30 58 87 115 120 142 145 2 33 69 111 156 172 203 203 3 30 51 75 108 115 139 140 4 32 62 112 167 179 209 214 5 30 49 81 125 142 174 177 图 25.3 以直观的方式展示 5 颗橘树的生长变化，相比于表 25.3 我们能更加明确读取数据中的变化 library(ggplot2) p &lt;- ggplot(data = Orange, aes(x = age, y = circumference, color = Tree)) + geom_point() + geom_line() + theme_minimal() + labs(x = &quot;age (day)&quot;, y = &quot;circumference (mm)&quot;) p 图 25.3: 橘树生长模型 library(gganimate) p + transition_reveal(age) "],["chap-data-explorer.html", "第 26 章 数据探索", " 第 26 章 数据探索 DataExplorer DALEX 提供探索性模型分析，支持 mlr、 caret、 keras、 h2o 和 xgboost 等一系列统计建模分析的 R 包。 breakDown Model Agnostic Explainers for Individual Predictions "],["chap-survival-analysis.html", "第 27 章 生存分析", " 第 27 章 生存分析 The fact that some people murder doesn’t mean we should copy them. And murdering data, though not as serious, should also be avoided. — Frank E. Harrell44 R 软件内置了 survival包 它是实现生存分析的核心 R 包。文档见 https://cran.r-project.org/package=survival 相关书籍见 Terry M. Therneau and Patricia M. Grambsch (2000) survminer 竟然严重依赖 ggpubr 包，ggpubr 包曾被 ggtree 的作者余光创严重吐槽过。ggfortify包 大大扩展了 ggplot2 包的 autoplot() 函数，使得它适应各种模型对象的自动绘图。 参考文献 "],["sec-aml.html", "27.1 急性粒细胞白血病生存数据", " 27.1 急性粒细胞白血病生存数据 library(survival) leukemia.surv &lt;- survfit(Surv(time, status) ~ x, data = aml) library(ggfortify) autoplot(leukemia.surv, data = aml) + theme_minimal() 图 27.1: 急性粒细胞白血病生存数据 "],["chap-time-series-analysis.html", "第 28 章 时序分析", " 第 28 章 时序分析 library(formatR) `%&gt;%` &lt;- magrittr::`%&gt;%` library(ggplot2) library(ggfortify) # **ggfortify** 包提供的 `autoplot()` 函数可以根据数据对象的不同绘制不同的图形。 library(highcharter) library(dygraphs) # library(robustbase) # Robust Statistics # library(timeDate) # 日期处理 # library(timeSeries) # 序列处理 # library(fPortfolio) # 投资组合 # library(prophet) # 时间序列预测 # https://github.com/business-science/timetk # library(timetk) # 处理时间序列数据的工具箱 首先介绍时序数据对象及操作，处理时序数据的工具，包括时序图、相关图、平稳性检验，相关检验，之后才是时序建模。timeDate timeSeries 是处理日期和时间序列的 R 包，有专门的官网 https://www.rmetrics.org/，扩展到时间序列、组合优化、金融市场、投资管理等一系列书籍，非常值得一看。此外，北大李东风老师的金融时间序列分析讲义 是这方面非常好的中文参考材料。David R. Brillinger 在 1975 年出版的书 《Time Series: Data Analysis and Theory》 (Brillinger 2001) 是经典著作，我们可以从时间序列分析的综述上开始入手，比如从 ARIMA 过渡到异方差和非高斯分布 https://mason.gmu.edu/~jgentle/talks/CompFin_Tutorial.pdf， https://www.stat.berkeley.edu/~brill/Papers/encysbs.pdf 和 ARCH or GARCH 的综述 http://public.econ.duke.edu/~boller/Papers/glossary_arch.pdf ，宾州州立大学开设的 Applied Time Series Analysis 课程 https://newonlinecourses.science.psu.edu/stat510/，以及 《Time Series Analysis and Its Applications With R Examples》 已经出到第四版了，和 R 语言结合，理论和应用结合 https://www.stat.pitt.edu/stoffer/tsa4/。从时间序列中寻找规律，这样才是真的数据建模，从数据到模型，而不是相反 Finding Patterns in Time Series，识别金融时间序列的模式和统计规律。现在工业界做时序分析和预测的工具，如 facebook 出品的 prophet，微软收集了一些时间序列预测的最佳实战案例 https://github.com/microsoft/forecasting forecastML 自回归模型结合机器学习方法。 CausalImpact 时间序列中的因果关系，比如广告促销带来的点击效果。 robustbase (Maronna, Martin, and Yohai 2006) 提供稳健统计方法。 prophet 基于可加模型的时间序列预测 AnomalyDetection 时间序列数据中的异常值检测 参考文献 "],["sec-ts-data.html", "28.1 时序数据", " 28.1 时序数据 以数据集 AirPassengers 为例说明一下 R 内置的存储时间序列数据的数据结构 — ts 数据对象。函数 class() 、 mode() 和 str() 分别可以查看其数据类型、存储类型和数据结构。 # 数据类型 class(AirPassengers) ## [1] &quot;ts&quot; # 存储类型 mode(AirPassengers) ## [1] &quot;numeric&quot; # 数据结构 str(AirPassengers) ## Time-Series [1:144] from 1949 to 1961: 112 118 132 129 121 135 148 148 136 119 ... 查看该数据集开始和结束的时间点 c(start(AirPassengers), end(AirPassengers)) ## [1] 1949 1 1960 12 数据集 AirPassengers 在以上时间区间的划分 time(AirPassengers) ## Jan Feb Mar Apr May Jun Jul Aug ## 1949 1949.000 1949.083 1949.167 1949.250 1949.333 1949.417 1949.500 1949.583 ## 1950 1950.000 1950.083 1950.167 1950.250 1950.333 1950.417 1950.500 1950.583 ## 1951 1951.000 1951.083 1951.167 1951.250 1951.333 1951.417 1951.500 1951.583 ## 1952 1952.000 1952.083 1952.167 1952.250 1952.333 1952.417 1952.500 1952.583 ## 1953 1953.000 1953.083 1953.167 1953.250 1953.333 1953.417 1953.500 1953.583 ## 1954 1954.000 1954.083 1954.167 1954.250 1954.333 1954.417 1954.500 1954.583 ## 1955 1955.000 1955.083 1955.167 1955.250 1955.333 1955.417 1955.500 1955.583 ## 1956 1956.000 1956.083 1956.167 1956.250 1956.333 1956.417 1956.500 1956.583 ## 1957 1957.000 1957.083 1957.167 1957.250 1957.333 1957.417 1957.500 1957.583 ## 1958 1958.000 1958.083 1958.167 1958.250 1958.333 1958.417 1958.500 1958.583 ## 1959 1959.000 1959.083 1959.167 1959.250 1959.333 1959.417 1959.500 1959.583 ## 1960 1960.000 1960.083 1960.167 1960.250 1960.333 1960.417 1960.500 1960.583 ## Sep Oct Nov Dec ## 1949 1949.667 1949.750 1949.833 1949.917 ## 1950 1950.667 1950.750 1950.833 1950.917 ## 1951 1951.667 1951.750 1951.833 1951.917 ## 1952 1952.667 1952.750 1952.833 1952.917 ## 1953 1953.667 1953.750 1953.833 1953.917 ## 1954 1954.667 1954.750 1954.833 1954.917 ## 1955 1955.667 1955.750 1955.833 1955.917 ## 1956 1956.667 1956.750 1956.833 1956.917 ## 1957 1957.667 1957.750 1957.833 1957.917 ## 1958 1958.667 1958.750 1958.833 1958.917 ## 1959 1959.667 1959.750 1959.833 1959.917 ## 1960 1960.667 1960.750 1960.833 1960.917 期初和期末的周期 tsp(AirPassengers) ## [1] 1949.000 1960.917 12.000 函数 diff() 实现差分算子，默认参数 lag = 1 ，differences = 1 表示延迟期数为 1 的一阶差分。 # 差分前 AirPassengers ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 112 118 132 129 121 135 148 148 136 119 104 118 ## 1950 115 126 141 135 125 149 170 170 158 133 114 140 ## 1951 145 150 178 163 172 178 199 199 184 162 146 166 ## 1952 171 180 193 181 183 218 230 242 209 191 172 194 ## 1953 196 196 236 235 229 243 264 272 237 211 180 201 ## 1954 204 188 235 227 234 264 302 293 259 229 203 229 ## 1955 242 233 267 269 270 315 364 347 312 274 237 278 ## 1956 284 277 317 313 318 374 413 405 355 306 271 306 ## 1957 315 301 356 348 355 422 465 467 404 347 305 336 ## 1958 340 318 362 348 363 435 491 505 404 359 310 337 ## 1959 360 342 406 396 420 472 548 559 463 407 362 405 ## 1960 417 391 419 461 472 535 622 606 508 461 390 432 # 差分后 diff(AirPassengers) ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 6 14 -3 -8 14 13 0 -12 -17 -15 14 ## 1950 -3 11 15 -6 -10 24 21 0 -12 -25 -19 26 ## 1951 5 5 28 -15 9 6 21 0 -15 -22 -16 20 ## 1952 5 9 13 -12 2 35 12 12 -33 -18 -19 22 ## 1953 2 0 40 -1 -6 14 21 8 -35 -26 -31 21 ## 1954 3 -16 47 -8 7 30 38 -9 -34 -30 -26 26 ## 1955 13 -9 34 2 1 45 49 -17 -35 -38 -37 41 ## 1956 6 -7 40 -4 5 56 39 -8 -50 -49 -35 35 ## 1957 9 -14 55 -8 7 67 43 2 -63 -57 -42 31 ## 1958 4 -22 44 -14 15 72 56 14 -101 -45 -49 27 ## 1959 23 -18 64 -10 24 52 76 11 -96 -56 -45 43 ## 1960 12 -26 28 42 11 63 87 -16 -98 -47 -71 42 # 延迟一期的二阶差分 diff(AirPassengers, lag = 1, differences = 2) ## Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ## 1949 8 -17 -5 22 -1 -13 -12 -5 2 29 ## 1950 -17 14 4 -21 -4 34 -3 -21 -12 -13 6 45 ## 1951 -21 0 23 -43 24 -3 15 -21 -15 -7 6 36 ## 1952 -15 4 4 -25 14 33 -23 0 -45 15 -1 41 ## 1953 -20 -2 40 -41 -5 20 7 -13 -43 9 -5 52 ## 1954 -18 -19 63 -55 15 23 8 -47 -25 4 4 52 ## 1955 -13 -22 43 -32 -1 44 4 -66 -18 -3 1 78 ## 1956 -35 -13 47 -44 9 51 -17 -47 -42 1 14 70 ## 1957 -26 -23 69 -63 15 60 -24 -41 -65 6 15 73 ## 1958 -27 -26 66 -58 29 57 -16 -42 -115 56 -4 76 ## 1959 -4 -41 82 -74 34 28 24 -65 -107 40 11 88 ## 1960 -31 -38 54 14 -31 52 24 -103 -82 51 -24 113 "],["sec-ts-plot.html", "28.2 时序图", " 28.2 时序图 美国纽黑文自1912年至1971年的年平均气温变化见图 28.1。 plot(nhtemp, main = &quot;美国纽黑文的年平均气温&quot;, family = &quot;source-han-sans-cn&quot;) 图 28.1: 美国纽黑文的年平均气温，单位：华氏温度 "],["sec-ts-tests.html", "28.3 时序检验", " 28.3 时序检验 参数的计算公式，实现的 R 代码 Applies linear filtering to a univariate time series or to each series separately of a multivariate time series. 过滤 一元时间序列的线性过滤，或者对多元时间序列的单个序列分别做线性过滤 \\[ y[i] = x[i] + f[1]*y[i-1] +\\ldots+ f[p]*y[i-p] \\] \\[ y[i] = f[1]*x[i+o] + \\ldots + f[p]*x[i+o-(p-1)] \\] 其中 \\(o\\) 代表 offset 介绍 FTT 算法细节 不同的方法对时间序列平滑的影响 FTT 快速傅里叶变换算法 usage(stats::filter) ## filter(x, filter, method = c(&quot;convolution&quot;, &quot;recursive&quot;), sides = 2L, ## circular = FALSE, init = NULL) filter() 时间序列线性过滤 fft() 快速离散傅里叶变换 "],["sec-exponential-smoothing.html", "28.4 指数平滑", " 28.4 指数平滑 "],["sec-holt-winters.html", "28.5 Holt-Winters", " 28.5 Holt-Winters 可加 Holt-Winters (Winters 1960; Holt 2004) 预测函数，周期长度为 p \\[ \\hat{Y}[t+h] = a[t] + h * b[t] + s[t - p + 1 + (h - 1) \\mod p \\] 其中 \\(a[t], b[t], s[t]\\) 由以下决定 \\[\\begin{align} a[t] &amp;= \\alpha (Y[t] - s[t-p]) + (1-\\alpha) (a[t-1] + b[t-1]) \\\\ b[t] &amp;= \\beta (a[t] - a[t-1]) + (1-\\beta) b[t-1] \\\\ s[t] &amp;= \\gamma (Y[t] - a[t]) + (1-\\gamma) s[t-p] \\end{align}\\] 可乘 Holt-Winters \\[ \\hat{Y}[t+h] = (a[t] + h * b[t]) * s[t - p + 1 + (h - 1) \\mod p] \\] 其中 \\(a[t], b[t], s[t]\\) 由如下决定 \\[\\begin{align} a[t] &amp;= \\alpha (Y[t] / s[t-p]) + (1-\\alpha) (a[t-1] + b[t-1]) \\\\ b[t] &amp;= \\beta (a[t] - a[t-1]) + (1-\\beta) b[t-1] \\\\ s[t] &amp;= \\gamma (Y[t] / a[t]) + (1-\\gamma) s[t-p] \\end{align}\\] HoltWinters() 用 Shiny App / 动画的形式展示 \\(\\alpha, \\beta, \\gamma\\) 三个参数对模型预测的影响，参数的确定通过最小化预测均方误差 ## Seasonal Holt-Winters (m &lt;- HoltWinters(co2)) plot(m) plot(fitted(m)) p &lt;- predict(m, 50, prediction.interval = TRUE) plot(m, p) (m &lt;- HoltWinters(AirPassengers, seasonal = &quot;mult&quot;)) plot(m) ## 指数平滑 Exponential Smoothing m2 &lt;- HoltWinters(x, gamma = FALSE, beta = FALSE) lines(fitted(m2)[,1], col = 3) 参考文献 "],["sec-sunspots.html", "28.6 1749-2013 年太阳黑子数据", " 28.6 1749-2013 年太阳黑子数据 再从官网拿到最近的数据 plot(sunspot.month, xlab = &quot;Year&quot;, ylab = &quot;Monthly sunspot numbers&quot;, main = &quot;Monthly mean relative sunspot numbers from 1749 to 2013&quot;) autoplot(sunspot.month, main = &quot;Monthly mean relative sunspot numbers from 1749 to 2013&quot;, xlab = &quot;Year&quot;, ylab = &quot;Monthly sunspot numbers&quot; ) 图 28.2: 时序图：太阳黑子月均数量 autoplot(sunspots) autoplot(sunspot.year, xlab = &quot;Year&quot;, ylab = &quot;Yearly Sunspot Data, 1700-1988&quot;) + theme_minimal() 图 28.3: 太阳黑子数量年平均时序图 library(dygraphs) hw &lt;- HoltWinters(sunspot.month) predicted &lt;- predict(hw, n.ahead = 72, prediction.interval = TRUE) dygraph(predicted, main = &quot;Predicted sunspot numbers&quot;) %&gt;% dyAxis(&quot;x&quot;, drawGrid = FALSE) %&gt;% dySeries(c(&quot;lwr&quot;, &quot;fit&quot;, &quot;upr&quot;), label = &quot;sunspot&quot;) %&gt;% dyOptions(colors = hcl.colors(3)) par(family = &quot;source-han-sans-cn&quot;) plot(sunspot.month, col = &quot;black&quot;) lines(sunspots, col = &quot;red&quot;) legend(&quot;topright&quot;, legend = c(&quot;1749 至今&quot;, &quot;1749-1983&quot;), col = c(&quot;black&quot;, &quot;red&quot;), lty = 1) 图 28.4: 月均太阳黑子数 "],["sec-EuStockMarkets.html", "28.7 1991-1998 年欧洲主要股票市场日闭市价格指数", " 28.7 1991-1998 年欧洲主要股票市场日闭市价格指数 matplot(time(EuStockMarkets), EuStockMarkets, main = &quot;&quot;, xlab = &quot;Date&quot;, ylab = &quot;closing prices&quot;, pch = 17, type = &quot;l&quot;, col = 1:4 ) legend(&quot;topleft&quot;, colnames(EuStockMarkets), pch = 17, lty = 1, col = 1:4) 图 28.5: 1991-1998年间欧洲主要股票市场日闭市价格指数图 德国 DAX (Ibis), Switzerland SMI, 法国 CAC 和 英国 FTSE # 考虑收集加入最新的数据 1991~1998年的数据 plot(EuStockMarkets, plot.type = &quot;single&quot;, col = hcl.colors(4)) legend(&quot;topleft&quot;, colnames(EuStockMarkets), col = hcl.colors(4), text.col = hcl.colors(4), lty = 1, box.col = NA, inset = 0.05 ) "],["sec-autoregressive.html", "28.8 自回归模型", " 28.8 自回归模型 ar() "],["sec-moving-average.html", "28.9 移动平均模型", " 28.9 移动平均模型 arima() "],["sec-autoregressive-movement-average.html", "28.10 自回归移动平均模型", " 28.10 自回归移动平均模型 arima() ARIMA "],["sec-autoregressive-conditional-heteroskedasticity.html", "28.11 自回归条件异方差模型", " 28.11 自回归条件异方差模型 自回归条件异方差模型 ARCH "],["sec-generalized-autoregressive-conditional-heteroskedasticity.html", "28.12 广义自回归条件异方差模型", " 28.12 广义自回归条件异方差模型 广义自回归条件异方差模型 （Generalized Autoregressive Conditional Heteroskedasticity，简称 GARCH ） "],["sec-other-ts.html", "28.13 其它特征的时间序列", " 28.13 其它特征的时间序列 plot(JohnsonJohnson) plot(AirPassengers) plot(nottem) plot(lynx) 图 28.6: 时间序列：非平稳、周期性、非线性 "],["sec-hk-stock.html", "28.14 港股走势", " 28.14 港股走势 美团、阿里巴巴在香港上市 # 美团 meituan &lt;- quantmod::getSymbols(&quot;3690.HK&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2019-06-30&#39;) # 阿里 ali &lt;- quantmod::getSymbols(&quot;9988.HK&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2019-06-30&#39;) # 京东 sw &lt;- quantmod::getSymbols(&quot;9618.HK&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2019-06-30&#39;) # 腾讯 tx &lt;- quantmod::getSymbols(&quot;0700.HK&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2019-06-30&#39;) highchart(type = &quot;stock&quot;) %&gt;% hc_add_series(meituan, type = &quot;ohlc&quot;, name = &#39;美团&#39;) %&gt;% hc_add_series(ali, type = &quot;ohlc&quot;, name = &#39;阿里巴巴&#39;) %&gt;% hc_add_series(sw, type = &quot;ohlc&quot;, name = &#39;京东&#39;) %&gt;% hc_add_series(tx, type = &quot;ohlc&quot;, name = &#39;腾讯&#39;) 图 10.22: 港股走势 # 如何共 x 轴，右对齐 plot(as.ts(meituan[, &quot;3690.HK.Close&quot;]), col = &quot;orange&quot;, ylab = &quot;股价&quot;) lines(as.ts(ali[, &quot;9988.HK.Close&quot;]), col = &quot;springgreen4&quot;) lines(as.ts(sw[, &quot;9618.HK.Close&quot;]), col = &quot;purple4&quot;) lines(as.ts(tx[, &quot;0700.HK.Close&quot;]), col = &quot;lightsteelblue4&quot;) legend(&quot;topright&quot;, col = c(&quot;Orange&quot;, &quot;springgreen4&quot;, &quot;purple4&quot;, &quot;lightsteelblue4&quot;), lty = 1, legend = c(&quot;美团&quot;, &quot;阿里&quot;, &quot;京东&quot;, &quot;腾讯&quot;) ) "],["sec-us-stock.html", "28.15 美股走势", " 28.15 美股走势 拼多多、京东、阿里巴巴、51Talk 在美股上市 # 拼多多 pdd &lt;- quantmod::getSymbols(&quot;PDD&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;) # 京东 jd &lt;- quantmod::getSymbols(&quot;JD&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;) # 阿里巴巴 baba &lt;- quantmod::getSymbols(&quot;BABA&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;) # 51Talk coe &lt;- quantmod::getSymbols(&quot;COE&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2016-06-30&#39;) highchart(type = &quot;stock&quot;) %&gt;% hc_add_series(pdd, type = &quot;ohlc&quot;, name = &#39;拼多多&#39;) %&gt;% hc_add_series(jd, type = &quot;ohlc&quot;, name = &#39;京东&#39;) %&gt;% hc_add_series(baba, type = &quot;ohlc&quot;, name = &#39;阿里巴巴&#39;) %&gt;% hc_add_series(coe, type = &quot;ohlc&quot;, name = &#39;51Talk&#39;) 图 28.7: 美股走势 "],["sec-coe-stock.html", "28.16 51Talk 股价走势", " 28.16 51Talk 股价走势 Joshua M. Ulrich 开发维护的 quantmod 包可以下载国内外股票市场的数据 51talk 于 2016年6月10日在美国纽交所上市，股票代码 COE， 2020年1月22日，武汉封城，受新冠肺炎病毒影响，政府停课不停学的号召，线下教育纷纷转线上，线上教育的春天来临，股价开始回升到发行价的水平，在公司将资源转变为能力后，预期公司股价继续翻倍，回到理性的水平。 coe &lt;- quantmod::getSymbols(&quot;COE&quot;, auto.assign = FALSE, src = &quot;yahoo&quot;, from = &#39;2016-06-30&#39;) 读者可以从雅虎财经获取数据源 https://finance.yahoo.com/ COE 股价变化趋势见图 28.8，包含开盘价 Open、最低价 Low、最高价 High、闭市价 Close 和调整价 Adjust 和交易额 Volume autoplot(coe) 图 28.8: CEO 股价变化趋势 "],["sec-tsa-sessioninfo.html", "28.17 运行环境", " 28.17 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] dygraphs_1.1.1.6 highcharter_0.8.2 ggfortify_0.4.12 ggplot2_3.3.5 ## [5] formatR_1.11 ## ## loaded via a namespace (and not attached): ## [1] zoo_1.8-9 tidyselect_1.1.1 xfun_0.24 bslib_0.2.5.1 ## [5] purrr_0.3.4 lattice_0.20-44 colorspace_2.0-2 vctrs_0.3.8 ## [9] generics_0.1.0 htmltools_0.5.1.1 yaml_2.2.1 utf8_1.2.1 ## [13] rlang_0.4.11 jquerylib_0.1.4 pillar_1.6.1 glue_1.4.2 ## [17] withr_2.4.2 DBI_1.1.1 TTR_0.24.2 lifecycle_1.0.0 ## [21] quantmod_0.4.18 stringr_1.4.0 munsell_0.5.0 gtable_0.3.0 ## [25] htmlwidgets_1.5.3 evaluate_0.14 labeling_0.4.2 knitr_1.33 ## [29] curl_4.3.2 fansi_0.5.0 highr_0.9 broom_0.7.8 ## [33] xts_0.12.1 Rcpp_1.0.7 scales_1.1.1 backports_1.2.1 ## [37] showtext_0.9-2 jsonlite_1.7.2 sysfonts_0.8.3 farver_2.1.0 ## [41] gridExtra_2.3 digest_0.6.27 stringi_1.7.3 showtextdb_3.0 ## [45] rlist_0.4.6.1 bookdown_0.22 dplyr_1.0.7 grid_4.1.0 ## [49] tools_4.1.0 magrittr_2.0.1 sass_0.4.0 tibble_3.1.2 ## [53] crayon_1.4.1 tidyr_1.1.3 pkgconfig_2.0.3 ellipsis_0.3.2 ## [57] data.table_1.14.0 lubridate_1.7.10 assertthat_0.2.1 rmarkdown_2.9 ## [61] R6_2.5.0 igraph_1.2.6 compiler_4.1.0 "],["chap-spatial-analysis.html", "第 29 章 空间分析", " 第 29 章 空间分析 mapdeck 支持调用 GPU 渲染 deck.gl MIT 协议 Edzer Pebesma UseR2020 Analyzing and visualising spatial and spatiotemporal data cubes - Part I UseR2019 UseR! 2019 Spatial workshop part I UseR! 2019 Spatial workshop part II UseR2017 Spatial Data in R: New Directions UseR2016 Handling and Analyzing Spatial, Spatiotemporal and Movement Data library(sp) library(RColorBrewer) library(raster) library(lattice) library(latticeExtra) library(rasterVis) # https://oscarperpinan.github.io/rastervis/ # https://oscarperpinan.github.io/rastervis/FAQ.html library(sf) library(rgdal) library(highcharter) "],["sec-gambia-malaria.html", "29.1 冈比亚儿童疟疾", " 29.1 冈比亚儿童疟疾 冈比亚地形 sp_path &lt;- &quot;data/&quot; # 存储临时地形文件 if (!dir.exists(sp_path)) dir.create(sp_path, recursive = TRUE) # Gambia 海拔数据 gambia_alt &lt;- raster::getData(name = &quot;alt&quot;, country = &quot;GMB&quot;, mask = TRUE, path = sp_path) # Gambia 市级行政边界数据 gambia_map &lt;- raster::getData(&quot;GADM&quot;, country = &quot;GMB&quot;, level = 2, path = sp_path) # 绘制冈比亚地形 rasterVis::levelplot(gambia_alt, margin = FALSE, main = &quot;Elevation&quot;, colorkey = list( space = &quot;top&quot;, labels = list(at = seq(from = -5, to = 65, by = 10)), axis.line = list(col = &quot;black&quot;) ), par.settings = list( axis.line = list(col = &quot;transparent&quot;) ), scales = list(draw = FALSE), col.regions = hcl.colors, at = seq(-5, 65, len = 101) ) + latticeExtra::layer(sp::sp.polygons(gambia_map, lwd = 1.5)) 图 29.1: 冈比亚地形海拔数据 rgdal 包可以实现坐标变换 # 加载数据 data(gambia, package = &quot;geoR&quot;) # 坐标变换 library(rgdal) sps &lt;- SpatialPoints(gambia[, c(&quot;x&quot;, &quot;y&quot;)], proj4string = CRS(&quot;+proj=utm +zone=28&quot;) ) spst &lt;- spTransform(sps, CRS(&quot;+proj=longlat +datum=WGS84&quot;)) gambia[, c(&quot;x&quot;, &quot;y&quot;)] &lt;- coordinates(spst) # 聚合数据 gambia_agg &lt;- aggregate( formula = cbind(pos, netuse, treated) ~ x + y + green + phc, data = gambia, FUN = function(x) sum(x) / length(x) ) # 抽取指定位置的海拔数据 # raster::extract(gambia_alt, gambia[, c(&quot;x&quot;, &quot;y&quot;)]) \\(Y \\sim b(1,p)\\) 每个人检验结果，就是感染 1 或是没有感染 0，感染率 \\(p\\) 的建模分析，个体水平 library(highcharter) hchart(gambia_agg, &quot;bubble&quot;, hcaes(x = x, y = y, fill = pos, size = pos), maxSize = &quot;5%&quot;, name = &quot;Gambia&quot;, showInLegend = FALSE ) %&gt;% hc_yAxis(title = list(text = &quot;Latitude&quot;)) %&gt;% hc_xAxis(title = list(text = &quot;Longitude&quot;), labels = list(align = &quot;center&quot;)) %&gt;% hc_colorAxis( stops = color_stops(colors = hcl.colors(palette = &quot;Plasma&quot;, n = 10)) ) %&gt;% hc_tooltip( pointFormat = &quot;({point.x:.2f}, {point.y:.2f}) &lt;br/&gt; Size: {point.z:.2f}&quot; ) 图 29.2: 各个村庄疟疾流行度 # gm_data &lt;- download_map_data(&quot;https://code.highcharts.com/mapdata/countries/gm/gm-all.js&quot;) # get_data_from_map(gm_data) hcmap(&quot;countries/gm/gm-all.js&quot;) %&gt;% hc_title(text = &quot;Gambia&quot;) data(&quot;USArrests&quot;, package = &quot;datasets&quot;) data(&quot;usgeojson&quot;) # 加载地图数据 地图数据的结构 USArrests &lt;- transform(USArrests, state = rownames(USArrests)) highchart() %&gt;% hc_title(text = &quot;Violent Crime Rates by US State&quot;) %&gt;% hc_subtitle(text = &quot;Source: USArrests data&quot;) %&gt;% hc_add_series_map(usgeojson, USArrests, name = &quot;Murder arrests (per 100,000)&quot;, value = &quot;Murder&quot;, joinBy = c(&quot;woename&quot;, &quot;state&quot;), dataLabels = list( enabled = TRUE, format = &quot;{point.properties.postalcode}&quot; ) ) %&gt;% hc_colorAxis(stops = color_stops()) %&gt;% hc_legend(valueDecimals = 0, valueSuffix = &quot;%&quot;) %&gt;% hc_mapNavigation(enabled = TRUE) highcharter 包含三个数据集分别是： worldgeojson 世界地图（国家级）、 usgeojson 美国地图（州级）、 uscountygeojson 美国地图（城镇级）。其它地图数据见 https://code.highcharts.com/mapdata/。 # 添加地图数据 hcmap(map = &quot;countries/cn/custom/cn-all-sar-taiwan.js&quot;) %&gt;% hc_title(text = &quot;中国地图&quot;) library(mapdeck) # 多边形 mapdeck() %&gt;% add_polygon( data = spatialwidget::widget_melbourne, fill_colour = &quot;SA2_NAME&quot;, palette = &quot;spectral&quot; ) mapdeck( location = c(145, -37.8), zoom = 10) %&gt;% add_geojson( data = mapdeck::geojson ) googleway、ggmap、RgoogleMaps library(RgoogleMaps) lat &lt;- c(40.702147, 40.718217, 40.711614) lon &lt;- c(-74.012318, -74.015794, -73.998284) center &lt;- c(mean(lat), mean(lon)) zoom &lt;- min(MaxZoom(range(lat), range(lon))) bb &lt;- qbbox(lat, lon) par(pty = &quot;s&quot;) # OSM myMap &lt;- GetMap(center, zoom = 15) PlotOnStaticMap(myMap, lat = lat, lon = lon, pch = 20, col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), cex = 2 ) library(ggmap) us &lt;- c(left = -125, bottom = 25.75, right = -67, top = 49) get_stamenmap(us, zoom = 5, maptype = &quot;toner-lite&quot;) %&gt;% ggmap() "],["sec-spatial-analysis-session.html", "29.2 运行环境", " 29.2 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] highcharter_0.8.2 rgdal_1.5-23 sf_1.0-0 ## [4] rasterVis_0.50.2 terra_1.3-4 latticeExtra_0.6-29 ## [7] lattice_0.20-44 raster_3.4-13 RColorBrewer_1.1-2 ## [10] sp_1.4-5 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.7 lubridate_1.7.10 tidyr_1.1.3 png_0.1-7 ## [5] class_7.3-19 zoo_1.8-9 assertthat_0.2.1 digest_0.6.27 ## [9] utf8_1.2.1 R6_2.5.0 backports_1.2.1 evaluate_0.14 ## [13] e1071_1.7-7 pillar_1.6.1 rlang_0.4.11 curl_4.3.2 ## [17] data.table_1.14.0 TTR_0.24.2 jquerylib_0.1.4 hexbin_1.28.2 ## [21] rmarkdown_2.9 stringr_1.4.0 htmlwidgets_1.5.3 igraph_1.2.6 ## [25] proxy_0.4-26 broom_0.7.8 compiler_4.1.0 xfun_0.24 ## [29] pkgconfig_2.0.3 htmltools_0.5.1.1 tidyselect_1.1.1 tibble_3.1.2 ## [33] bookdown_0.22 codetools_0.2-18 fansi_0.5.0 viridisLite_0.4.0 ## [37] crayon_1.4.1 dplyr_1.0.7 grid_4.1.0 jsonlite_1.7.2 ## [41] lifecycle_1.0.0 DBI_1.1.1 magrittr_2.0.1 units_0.7-2 ## [45] rlist_0.4.6.1 KernSmooth_2.23-20 quantmod_0.4.18 stringi_1.7.3 ## [49] bslib_0.2.5.1 ellipsis_0.3.2 xts_0.12.1 generics_0.1.0 ## [53] vctrs_0.3.8 tools_4.1.0 glue_1.4.2 purrr_0.3.4 ## [57] jpeg_0.1-8.1 parallel_4.1.0 yaml_2.2.1 classInt_0.4-3 ## [61] knitr_1.33 sass_0.4.0 "],["chap-spatial-modeling.html", "第 30 章 空间建模", " 第 30 章 空间建模 library(geoR) library(INLA) # library(leaflet) library(highcharter) "],["sec-cameroon-eyeworm.html", "30.1 西非眼线虫病", " 30.1 西非眼线虫病 loaloa 眼线虫病，人群感染，村庄水平， 响应变量服从二项分布 \\(Y \\sim b(n,p)\\)，每个村庄感染的人数 \\(Y_i \\sim b(n_i, p_i)\\) 其中 \\(n_i\\) 是第 \\(i\\) 个村庄调查的人数， \\(p_i\\) 是观测的感染率 data(&quot;loaloa&quot;, package = &quot;PrevMap&quot;) hcmap(map = &quot;countries/cm/cm-all.js&quot;) %&gt;% hc_title(text = &quot;喀麦隆及其周边地区眼线虫病流行度&quot;) "],["sec-spatial-modeling-session.html", "30.2 运行环境", " 30.2 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] parallel stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] highcharter_0.8.2 geoR_1.8-1 INLA_21.02.23 sp_1.4-5 ## [5] foreach_1.5.1 Matrix_1.3-4 ## ## loaded via a namespace (and not attached): ## [1] zoo_1.8-9 tidyselect_1.1.1 xfun_0.24 ## [4] bslib_0.2.5.1 purrr_0.3.4 splines_4.1.0 ## [7] lattice_0.20-44 tcltk_4.1.0 vctrs_0.3.8 ## [10] generics_0.1.0 htmltools_0.5.1.1 yaml_2.2.1 ## [13] utf8_1.2.1 rlang_0.4.11 jquerylib_0.1.4 ## [16] pillar_1.6.1 glue_1.4.2 DBI_1.1.1 ## [19] TTR_0.24.2 lifecycle_1.0.0 quantmod_0.4.18 ## [22] stringr_1.4.0 htmlwidgets_1.5.3 codetools_0.2-18 ## [25] evaluate_0.14 knitr_1.33 curl_4.3.2 ## [28] fansi_0.5.0 xts_0.12.1 Rcpp_1.0.7 ## [31] broom_0.7.8 backports_1.2.1 jsonlite_1.7.2 ## [34] digest_0.6.27 stringi_1.7.3 rlist_0.4.6.1 ## [37] bookdown_0.22 dplyr_1.0.7 splancs_2.01-42 ## [40] grid_4.1.0 tools_4.1.0 magrittr_2.0.1 ## [43] sass_0.4.0 tibble_3.1.2 crayon_1.4.1 ## [46] tidyr_1.1.3 pkgconfig_2.0.3 MASS_7.3-54 ## [49] ellipsis_0.3.2 data.table_1.14.0 RandomFieldsUtils_0.5.3 ## [52] lubridate_1.7.10 RandomFields_3.3.8 assertthat_0.2.1 ## [55] rmarkdown_2.9 iterators_1.0.13 R6_2.5.0 ## [58] igraph_1.2.6 compiler_4.1.0 "],["chap-bayesian-models.html", "第 31 章 贝叶斯模型", " 第 31 章 贝叶斯模型 LaplacesDemon 支持常见模型的贝叶斯推断，具体可见网站 (Statisticat and LLC. 2021)，shinystan 借助 rstan 打包了一些 stan 编写的统计模型，提供模型评估的功能。相比于 rstan，brms 支持了更加广泛的模型，shinybrms 类似 shinystan 提供可视化的 shiny 前端，方便用户调用模型和评估效果。rstanarm 基于 stan 语言重写了 arm 里的模型，和 brms 一样，提供类似 lme4 的公式语法，和 Base R 内置的函数 lm() 和 glm() 保持一致，降低用户学习成本。 cmdstanr 相比于 rstan 将会更加轻量，更快地将 CmdStan 的新功能融入进来，方便用户滚动升级，相比于 rstan 包，cmdstanr 包的一个巨大优势是和 Stan 软件的更新分离。做贝叶斯计算的软件框架还包括 JAGS 和 WinBUGS，苏毓松开发的 R2jags 包 (Su and Yajima 2020) 是 JAGS 的 R 接口。 TMB 书籍： Richard McElreath 为《Statistical Rethinking》写的 rethinking 包，参考 Derek S. Young (Young 2017) 和 Michael H. Kutner 等 (Kutner et al. 2005) 论文： An Introduction to Inductive Statistical Inference: from Parameter Estimation to Decision-Making https://arxiv.org/abs/1808.10173v2 固定效应/随机效应广义线性模型：多水平各种模型回归，模型结构和 Stan 代码 课程： 线性模型的内容主要分为四大块，分别是线性回归模型、方差分析模型、协方差分析模型和线性混合效应模型。国外 David Pollard 的线性模型 课程内容 会议： Paul-Christian Bürkner 在 Stan 大会上介绍 brms 和 rstanarm https://github.com/InsuranceDataScience/StanWorkshop2018 参考文献 "],["sec-stan-setup.html", "31.1 软件配置", " 31.1 软件配置 从 GitHub 下载最新版的源码包 https://github.com/stan-dev/cmdstan/releases/latest，编译二进制版本 tar -xzf /Users/xiangyun/Desktop/cmdstan-2.26.0.tar.gz -C /opt/ cd cmdstan-2.26.0 make build 设置环境变量 CMDSTAN 指向 CmdStan 安装路径，加载 cmdstanr 包会自动检测和加载 Sys.setenv(CMDSTAN=&quot;/opt/cmdstan-2.26.0&quot;) 还可以设置环境变量 CMDSTANR_NO_VER_CHECK=TRUE，让 cmdstanr 不要检查 CmdStan 版本状态，是不是最新版，比如本书将固定下 CmdStan 版本为 2.26.0 cmdstanr 当前还在开发中，安装方式如下 remotes::install_github(&#39;stan-dev/cmdstanr&#39;) # 或者 install.packages(&quot;cmdstanr&quot;, repos = c(&quot;https://mc-stan.org/r-packages/&quot;, getOption(&quot;repos&quot;))) 另有一篇博文介绍在 Windows 系统上安装 cmdstanr 的过程，这里不做展开。 # rstan # brms # rstanarm remotes::install_github(&#39;rmcelreath/rethinking&#39;) "],["sec-bayesian-normal-distribution.html", "31.2 正态分布", " 31.2 正态分布 我们以估计正态分布参数为例说明贝叶斯估计方法 \\[Y \\sim \\mathcal{N}(\\mu,\\sigma^2)\\] 已知 \\(y_1,y_2,\\ldots,y_n\\) 是来自正态总体 \\(\\mathcal{N}(\\mu,\\sigma^2)\\) 的一个样本，我们需要估计这个正态分布模型的参数 \\(\\mu\\) 和 \\(\\sigma^2\\)。 最大似然估计，简单推导过程，计算代码；再讲 stan 的计算步骤 library(cmdstanr) mod &lt;- cmdstan_model(stan_file = &quot;code/normal_dist.stan&quot;, compile = TRUE) 打包观测数据，初始化待估参数值，指定链条数，其中 dataList 必须与 stan 代码中数据块声明保持一致（如变量名称，长度），每条链使用不同的初始值，选择合适的初始值可以有效地提高收敛的速度。 # 数据准备 set.seed(20190427) # 设置参数 mu &lt;- 10 sd &lt;- 2 # 样本量 nobs &lt;- 500 nchains &lt;- 4 # 生成随机数 y &lt;- rnorm(n = nobs, mean = mu, sd = sd) # 给每条链设置不同的参数初始值 inits_data &lt;- lapply(1:nchains, function(i) { list( mu = runif(1, min(y), max(y)), sigma = runif(1, 1, 10) ) }) 将参数初值代入模型，抽样，获取参数的后验分布 normal_fit &lt;- mod$sample( data = list( N = nobs, y = y ), init = inits_data, iter_warmup = 1000, # 每条链预处理迭代次数 iter_sampling = 2000, # 每条链总迭代次数 chains = nchains, # 马尔科夫链的数目 parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个 show_messages = FALSE, # 不显示迭代的中间过程 refresh = 0, # 不显示采样的进度 seed = 20190425 # 设置随机数种子，不要使用 set.seed() 函数 ) ## Running MCMC with 4 sequential chains... ## ## Chain 1 finished in 0.1 seconds. ## Chain 2 finished in 0.1 seconds. ## Chain 3 finished in 0.1 seconds. ## Chain 4 finished in 0.1 seconds. ## ## All 4 chains finished successfully. ## Mean chain execution time: 0.1 seconds. ## Total execution time: 0.6 seconds. 检查收敛性，Rhat 决定收敛性，所有待估参数的Rhat必须小于1.1，同时有效样本数量 n_eff 除以抽样总数 N 必须小于0.001，否则收敛性是值得怀疑的。拟合结果及解释如下： # 模型参数估计结果 normal_fit$cmdstan_summary() ## Inference for Stan model: normal_dist_model ## 4 chains: each with iter=(2000,2000,2000,2000); warmup=(0,0,0,0); thin=(1,1,1,1); 8000 iterations saved. ## ## Warmup took (0.016, 0.015, 0.014, 0.016) seconds, 0.061 seconds total ## Sampling took (0.050, 0.045, 0.044, 0.041) seconds, 0.18 seconds total ## ## Mean MCSE StdDev 5% 50% 95% N_Eff N_Eff/s R_hat ## ## lp__ -602 1.7e-02 1.0 -604 -601 -601 3591 19951 1.0 ## accept_stat__ 0.92 3.3e-03 0.11 0.69 0.96 1.0 1.1e+03 5.9e+03 1.0e+00 ## stepsize__ 0.88 6.9e-02 0.098 0.73 0.90 1.0 2.0e+00 1.1e+01 1.5e+13 ## treedepth__ 1.9 1.2e-01 0.56 1.0 2.0 3.0 2.1e+01 1.2e+02 1.1e+00 ## n_leapfrog__ 3.7 3.7e-01 1.8 1.0 3.0 7.0 2.4e+01 1.3e+02 1.0e+00 ## divergent__ 0.00 nan 0.00 0.00 0.00 0.00 nan nan nan ## energy__ 603 2.5e-02 1.4 601 602 605 3.3e+03 1.8e+04 1.0e+00 ## ## mu 10 1.2e-03 0.092 9.9 10 10 5732 31844 1.00 ## sigma 2.0 7.7e-04 0.064 1.9 2.0 2.1 6885 38249 1.00 ## ## Samples were drawn using hmc with nuts. ## For each parameter, N_Eff is a crude measure of effective sample size, ## and R_hat is the potential scale reduction factor on split chains (at ## convergence, R_hat=1). 调用 draws 方法 normal_fit$draws()，获得一个由 posterior 构造的 draws_array 对象， draws_array &lt;- normal_fit$draws() str(draws_array) ## &#39;draws_array&#39; num [1:2000, 1:4, 1:3] -601 -601 -602 -601 -601 ... ## - attr(*, &quot;dimnames&quot;)=List of 3 ## ..$ iteration: chr [1:2000] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ... ## ..$ chain : chr [1:4] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ## ..$ variable : chr [1:3] &quot;lp__&quot; &quot;mu&quot; &quot;sigma&quot; 采样结果可以直接传递给 bayesplot 包，绘制参数的后验分布和马尔科夫链蒙特卡罗采样的轨迹图（trace plot）。 library(bayesplot) mcmc_trace(normal_fit$draws(c(&quot;mu&quot;, &quot;sigma&quot;))) mcmc_hist(normal_fit$draws(c(&quot;mu&quot;, &quot;sigma&quot;))) 图 31.1: 参数 \\(\\mu, \\sigma\\) 的迭代轨迹图和后验分布图 "],["sec-gaussian-process.html", "31.3 高斯过程", " 31.3 高斯过程 模拟高斯过程例子来自 Stan 参考手册 (Stan Development Team 2019) mod &lt;- cmdstan_model(stan_file = &quot;code/normal_gp.stan&quot;) stan 库内置了核函数为二次幂指数的实现，因此可以直接调用 cov_exp_quad 函数计算协方差矩阵 mod &lt;- cmdstan_model(stan_file = &quot;code/compat_gp.stan&quot;) 以 MASS 的 topo 数据集引出高斯过程回归模型问题复杂性 参考文献 "],["sec-hierarchical-normal-models.html", "31.4 分层正态模型", " 31.4 分层正态模型 Multilevel Models 多水平模型、Hierarchical Models 层次模型 31.4.1 schools 数据 # 模型编译 mod &lt;- cmdstan_model(stan_file = &quot;code/eight_schools.stan&quot;) # 模型拟合 eight_schools_fit &lt;- mod$sample( data = list( # 观测数据 J = 8, y = c(28, 8, -3, 7, -1, 1, 18, 12), sigma = c(15, 10, 16, 11, 9, 11, 10, 18) ), iter_warmup = 1000, # 每条链预处理迭代次数 iter_sampling = 2000, # 每条链总迭代次数 chains = 4, # 马尔科夫链的数目 parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个 show_messages = FALSE, # 不显示迭代的中间过程 refresh = 0, # 不显示采样的进度 seed = 20190425 # 设置随机数种子，不要使用 set.seed() 函数 ) ## Running MCMC with 4 sequential chains... ## ## Chain 1 finished in 0.1 seconds. ## Chain 2 finished in 0.1 seconds. ## Chain 3 finished in 0.1 seconds. ## Chain 4 finished in 0.1 seconds. ## ## All 4 chains finished successfully. ## Mean chain execution time: 0.1 seconds. ## Total execution time: 0.8 seconds. 模型拟合结果 eight_schools_fit$cmdstan_summary() ## Inference for Stan model: eight_schools_model ## 4 chains: each with iter=(2000,2000,2000,2000); warmup=(0,0,0,0); thin=(1,1,1,1); 8000 iterations saved. ## ## Warmup took (0.026, 0.029, 0.026, 0.029) seconds, 0.11 seconds total ## Sampling took (0.081, 0.092, 0.089, 0.099) seconds, 0.36 seconds total ## ## Mean MCSE StdDev 5% 50% 95% N_Eff N_Eff/s R_hat ## ## lp__ -4.0e+01 5.4e-02 2.7 -44 -3.9e+01 -36 2447 6779 1.00 ## accept_stat__ 0.88 1.5e-02 0.20 0.40 0.96 1.0 1.8e+02 5.1e+02 1.0e+00 ## stepsize__ 0.34 3.2e-02 0.045 0.28 0.33 0.41 2.0e+00 5.5e+00 1.8e+13 ## treedepth__ 3.5 1.8e-01 0.54 3.0 4.0 4.0 8.4e+00 2.3e+01 1.1e+00 ## n_leapfrog__ 12 1.3e+00 4.0 7.0 15 15 9.9e+00 2.7e+01 1.1e+00 ## divergent__ 0.00 nan 0.00 0.00 0.00 0.00 nan nan nan ## energy__ 45 7.2e-02 3.5 39 44 51 2.4e+03 6.7e+03 1.0e+00 ## ## mu 8.0e+00 8.1e-02 5.0 0.015 7.9e+00 17 3886 10764 1.0 ## tau 6.6e+00 1.0e-01 5.6 0.48 5.3e+00 17 3064 8488 1.0 ## eta[1] 3.9e-01 1.1e-02 0.95 -1.2 4.2e-01 1.9 7716 21373 1.00 ## eta[2] -4.0e-04 9.5e-03 0.88 -1.4 2.1e-04 1.4 8427 23343 1.00 ## eta[3] -2.0e-01 1.0e-02 0.94 -1.7 -2.0e-01 1.4 8319 23046 1.0 ## eta[4] -3.0e-02 9.7e-03 0.88 -1.5 -2.8e-02 1.4 8220 22770 1.0 ## eta[5] -3.7e-01 1.0e-02 0.88 -1.8 -3.9e-01 1.1 7355 20374 1.0 ## eta[6] -2.2e-01 9.8e-03 0.90 -1.7 -2.5e-01 1.3 8439 23376 1.0 ## eta[7] 3.5e-01 1.0e-02 0.88 -1.1 3.7e-01 1.8 7255 20096 1.0 ## eta[8] 5.4e-02 1.1e-02 0.93 -1.5 6.6e-02 1.6 7356 20376 1.00 ## theta[1] 1.1e+01 1.1e-01 8.4 0.10 1.0e+01 27 5668 15700 1.00 ## theta[2] 7.9e+00 6.8e-02 6.4 -2.5 7.9e+00 18 8940 24765 1.0 ## theta[3] 6.2e+00 9.3e-02 7.7 -7.5 6.6e+00 18 6961 19282 1.0 ## theta[4] 7.7e+00 7.1e-02 6.5 -3.0 7.7e+00 18 8515 23588 1.0 ## theta[5] 5.0e+00 7.0e-02 6.4 -6.4 5.5e+00 14 8218 22763 1.0 ## theta[6] 6.1e+00 7.3e-02 6.7 -5.7 6.5e+00 16 8504 23556 1.00 ## theta[7] 1.1e+01 8.4e-02 6.8 0.92 1.0e+01 23 6537 18108 1.00 ## theta[8] 8.5e+00 1.0e-01 7.8 -3.8 8.2e+00 22 5904 16353 1.0 ## ## Samples were drawn using hmc with nuts. ## For each parameter, N_Eff is a crude measure of effective sample size, ## and R_hat is the potential scale reduction factor on split chains (at ## convergence, R_hat=1). 4 条马尔可夫链，19 个变量，2000 次迭代，轨迹数据如下 eight_schools_fit$draws() ## # A draws_array: 2000 iterations, 4 chains, and 19 variables ## , , variable = lp__ ## ## chain ## iteration 1 2 3 4 ## 1 -42 -39 -38 -40 ## 2 -37 -40 -37 -42 ## 3 -40 -38 -38 -43 ## 4 -39 -39 -40 -43 ## 5 -38 -45 -38 -40 ## ## , , variable = mu ## ## chain ## iteration 1 2 3 4 ## 1 9.0 -3.696 8.9 1.9 ## 2 5.9 13.895 1.5 13.5 ## 3 6.2 0.013 4.2 1.5 ## 4 12.0 2.365 10.6 15.5 ## 5 5.8 -7.633 5.2 12.2 ## ## , , variable = tau ## ## chain ## iteration 1 2 3 4 ## 1 3.20 10.3 7.93 4.11 ## 2 9.70 1.9 10.70 0.65 ## 3 0.38 6.3 4.31 1.18 ## 4 7.19 9.2 0.43 11.03 ## 5 4.06 5.6 3.36 8.74 ## ## , , variable = eta[1] ## ## chain ## iteration 1 2 3 4 ## 1 1.10 1.72 1.23 1.10 ## 2 -0.30 -0.98 1.19 -0.74 ## 3 -0.31 1.28 0.34 -0.85 ## 4 0.97 1.53 -0.86 2.02 ## 5 1.04 0.75 1.46 1.24 ## ## # ... with 1995 more iterations, and 15 more variables 提取参数 \\(\\mu\\) 的四条迭代点列 eight_schools_fit$draws(&quot;mu&quot;) ## # A draws_array: 2000 iterations, 4 chains, and 1 variables ## , , variable = mu ## ## chain ## iteration 1 2 3 4 ## 1 9.0 -3.696 8.9 1.9 ## 2 5.9 13.895 1.5 13.5 ## 3 6.2 0.013 4.2 1.5 ## 4 12.0 2.365 10.6 15.5 ## 5 5.8 -7.633 5.2 12.2 ## ## # ... with 1995 more iterations eight_schools_fit 是一个 R6 对象，包含整个模型信息 class(eight_schools_fit) ## [1] &quot;CmdStanMCMC&quot; &quot;CmdStanFit&quot; &quot;R6&quot; str(eight_schools_fit) ## Classes &#39;CmdStanMCMC&#39;, &#39;CmdStanFit&#39;, &#39;R6&#39; &lt;CmdStanMCMC&gt; ## Inherits from: &lt;CmdStanFit&gt; ## Public: ## clone: function (deep = FALSE) ## cmdstan_diagnose: function () ## cmdstan_summary: function (flags = NULL) ## data_file: function () ## draws: function (variables = NULL, inc_warmup = FALSE, format = getOption(&quot;cmdstanr_draws_format&quot;, ## init: function () ## initialize: function (runset) ## inv_metric: function (matrix = TRUE) ## latent_dynamics_files: function (include_failed = FALSE) ## loo: function (variables = &quot;log_lik&quot;, r_eff = TRUE, ...) ## lp: function () ## metadata: function () ## num_chains: function () ## num_procs: function () ## output: function (id = NULL) ## output_files: function (include_failed = FALSE) ## print: function (variables = NULL, ..., digits = 2, max_rows = getOption(&quot;cmdstanr_max_rows&quot;, ## profile_files: function (include_failed = FALSE) ## profiles: function () ## return_codes: function () ## runset: CmdStanRun, R6 ## sampler_diagnostics: function (inc_warmup = FALSE, format = getOption(&quot;cmdstanr_draws_format&quot;, ## save_data_file: function (dir = &quot;.&quot;, basename = NULL, timestamp = TRUE, random = TRUE) ## save_latent_dynamics_files: function (dir = &quot;.&quot;, basename = NULL, timestamp = TRUE, random = TRUE) ## save_object: function (file, ...) ## save_output_files: function (dir = &quot;.&quot;, basename = NULL, timestamp = TRUE, random = TRUE) ## save_profile_files: function (dir = &quot;.&quot;, basename = NULL, timestamp = TRUE, random = TRUE) ## summary: function (variables = NULL, ...) ## time: function () ## Private: ## draws_: -42.0125 -37.337 -40.2068 -38.9824 -38.4394 -38.7721 -35 ... ## init_: NULL ## inv_metric_: list ## metadata_: list ## read_csv_: function (variables = NULL, sampler_diagnostics = NULL, format = getOption(&quot;cmdstanr_draws_format&quot;, ## sampler_diagnostics_: 3 3 4 3 4 3 3 3 3 3 2 3 3 3 3 3 4 3 3 3 3 2 3 3 3 3 3 3 ... ## warmup_draws_: NULL ## warmup_sampler_diagnostics_: NULL 模型诊断：查看迭代点列的平稳性 mcmc_dens(eight_schools_fit$draws(c(&quot;mu&quot;))) 分层线性模型之生长曲线模型 (Gelfand et al. 1990) 31.4.2 rats 数据 贝叶斯分层图 # 数据准备 # modified code from https://github.com/stan-dev/example-models/tree/master/bugs_examples/vol1/rats N &lt;- 30 T &lt;- 5 y &lt;- structure(c( 151, 145, 147, 155, 135, 159, 141, 159, 177, 134, 160, 143, 154, 171, 163, 160, 142, 156, 157, 152, 154, 139, 146, 157, 132, 160, 169, 157, 137, 153, 199, 199, 214, 200, 188, 210, 189, 201, 236, 182, 208, 188, 200, 221, 216, 207, 187, 203, 212, 203, 205, 190, 191, 211, 185, 207, 216, 205, 180, 200, 246, 249, 263, 237, 230, 252, 231, 248, 285, 220, 261, 220, 244, 270, 242, 248, 234, 243, 259, 246, 253, 225, 229, 250, 237, 257, 261, 248, 219, 244, 283, 293, 312, 272, 280, 298, 275, 297, 350, 260, 313, 273, 289, 326, 281, 288, 280, 283, 307, 286, 298, 267, 272, 285, 286, 303, 295, 289, 258, 286, 320, 354, 328, 297, 323, 331, 305, 338, 376, 296, 352, 314, 325, 358, 312, 324, 316, 317, 336, 321, 334, 302, 302, 323, 331, 345, 333, 316, 291, 324 ), .Dim = c(30, 5)) x &lt;- c(8.0, 15.0, 22.0, 29.0, 36.0) xbar &lt;- 22.0 # 模型参数设置 chains &lt;- 4 iter &lt;- 1000 init &lt;- rep(list(list( alpha = rep(250, 30), beta = rep(6, 30), alpha_c = 150, beta_c = 10, tausq_c = 1, tausq_alpha = 1, tausq_beta = 1 )), chains) mod &lt;- cmdstan_model(stan_file = &quot;code/rats.stan&quot;) rats_fit &lt;- mod$sample( data = list(N = N, T = T, y = y, x = x, xbar = xbar), init = init, iter_warmup = 1000, # 每条链预处理迭代次数 iter_sampling = 2000, # 每条链总迭代次数 chains = chains, # 马尔科夫链的数目 parallel_chains = 1, # 指定 CPU 核心数，可以给每条链分配一个 show_messages = FALSE, # 不显示迭代的中间过程 refresh = 0, # 不显示采样的进度 seed = 20190425 # 设置随机数种子，不要使用 set.seed() 函数 ) ## Running MCMC with 4 sequential chains... ## ## Chain 1 finished in 0.7 seconds. ## Chain 2 finished in 0.7 seconds. ## Chain 3 finished in 0.8 seconds. ## Chain 4 finished in 0.6 seconds. ## ## All 4 chains finished successfully. ## Mean chain execution time: 0.7 seconds. ## Total execution time: 3.1 seconds. 参考文献 "],["sec-nlm-gp.html", "31.5 非线性模型", " 31.5 非线性模型 高斯过程 31.5.1 mcycle 数据 library(MASS) library(ggplot2) ggplot(data = mcycle, aes(x = times, y= accel)) + geom_point() + # geom_smooth() + labs(x = &quot;Times (ms)&quot;, y = &quot;Acceleration (g)&quot;) + theme_minimal() "],["chap-gradient-boosting-machine.html", "第 32 章 梯度提升机", " 第 32 章 梯度提升机 关于决策树和梯度提升的扩展包/库，近年来层出不穷。2001 年 Jerome H. Friedman 提出梯度提升机后 (Friedman 2001)， 2003 年 Greg Ridgeway 开发了 gbm 包，目前 Brandon Greenwell 在维护。gbm 实现了 Freund and Schapire’s AdaBoost 算法和 Friedman 的梯度提升机。h2o 是基于 Java 平台的机器学习平台，学习材料 h2o-tutorials。基于决策树的分类和回归方法 caret 和基于模型的提升方法 https://github.com/boost-R 偏向统计学习，侧重各类统计模型，仅提供 R 语言接口。xgboost 目前已然成为做梯度提升的决策树的工业标准，使用案例丰富，中文帮助文档 https://xgboost.apachecn.org/cn/latest/，也提供多种语言接口。类似的还有 compboost，其它比较小众的提升库还有 xLearn。catboost 开源的基于决策树的梯度提升库，支持分类特征，提供 R 和 Python 接口，详见官网 https://catboost.ai。 LightGBM 提供了 R 包，微软的工具主要支持 Windows 平台和 VS 编译工具。 Python 接口的中文文档 https://lightgbm.apachecn.org/， 顺便一提，袁进辉 等人开发的LightLDA 是大规模主题建模的框架。 参考文献 "],["sec-xgboost.html", "32.1 XGBoost", " 32.1 XGBoost library(xgboost) "],["chap-neural-network.html", "第 33 章 神经网络", " 第 33 章 神经网络 A big computer, a complex algorithm and a long time does not equal science. — Robert Gentleman, SSC 2003, Halifax (June 2003) 近年来，深度学习框架越来越多，比较受欢迎的有 tensorflow、pytorch 和 mxnet，RStudio 团队也陆续给它们提供了 R 接口，tensorflow、keras 和 torch。此外，相关主题的还有 fastai。 Norm Matloff 等开发的 polyreg 包以多元多项式回归替代神经网络，Brian Ripley 开发的 nnet 包以单层前馈神经网络用于多项对数线性模型。 "],["sec-mxnet.html", "33.1 mxnet", " 33.1 mxnet mxnet 的 R 接口不太稳定好用，安装也比较麻烦，因此，通过 reticulate 包将 Python 模块 mxnet 导入 R 环境，然后调用其函数。 mxnet 框架包含很多子模块，详见接口文档，比如 ndarray，gluon，symbol 等等，下面具体以多维数组 ndarray 为例展开。 # 导入 mxnet 中的 ndarray nd &lt;- reticulate::import(&quot;mxnet.ndarray&quot;, convert = FALSE) class(nd) ## [1] &quot;python.builtin.module&quot; &quot;python.builtin.object&quot; zeros 是子模块 mxnet.ndarray 下的一个函数 x &lt;- nd$zeros(c(3L, 4L)) # 得到 python 中的 mx.nd.array x ## ## [[0. 0. 0. 0.] ## [0. 0. 0. 0.] ## [0. 0. 0. 0.]] ## &lt;NDArray 3x4 @cpu(0)&gt; 将 Python 中的数据对象 mx.nd.array 转化为 R 中的矩阵，而数据对象 mx.nd.array 有 asnumpy() 方法 (m1 &lt;- x$asnumpy()) # 得到 R 中的 matrix ## [[0. 0. 0. 0.] ## [0. 0. 0. 0.] ## [0. 0. 0. 0.]] class(m1) ## [1] &quot;numpy.ndarray&quot; &quot;python.builtin.object&quot; m2 = matrix(data = 1:12, nrow = 3, ncol = 4, byrow = TRUE) class(m2) ## [1] &quot;matrix&quot; &quot;array&quot; "],["neural-network-session.html", "33.2 运行环境", " 33.2 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] tensorflow_2.5.0 nnet_7.3-16 reticulate_1.20 ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.6 whisker_0.4 knitr_1.33 magrittr_2.0.1 ## [5] lattice_0.20-44 R6_2.5.0 rlang_0.4.11 stringr_1.4.0 ## [9] tools_4.1.0 grid_4.1.0 xfun_0.24 png_0.1-7 ## [13] jquerylib_0.1.4 tfruns_1.5.0 htmltools_0.5.1.1 yaml_2.2.1 ## [17] digest_0.6.27 bookdown_0.22 Matrix_1.3-4 codetools_0.2-18 ## [21] base64enc_0.1-3 sass_0.4.0 evaluate_0.14 rmarkdown_2.9 ## [25] stringi_1.6.2 compiler_4.1.0 bslib_0.2.5.1 jsonlite_1.7.2 "],["chap-matrix-operations.html", "第 34 章 矩阵运算", " 第 34 章 矩阵运算 Eigenvectors from Eigenvalues (Denton et al. 2019) 参考 matlib 和 Matrix 包，SparseM 更加强调稀疏矩阵的 Cholesky 分解和后退法，矩阵取子集和 Kronecker 积。矩阵计算一般介绍参考在线书籍 Stephen Boyd and Lieven Vandenberghe 最新著作 Introduction to Applied Linear Algebra – Vectors, Matrices, and Least Squares (Boyd and Vandenberghe 2018) 及其 Julia 语言实现，矩阵分解部分参考 Introduction to Linear Algebra, 5th Edition fastmatrix 各种矩阵操作 分块矩阵操作，各类分解算法，及其 R 实现 library(Matrix) 以 attitude 数据集为例介绍各种矩阵操作 head(attitude) ## rating complaints privileges learning raises critical advance ## 1 43 51 30 39 61 92 45 ## 2 63 64 51 54 63 73 47 ## 3 71 70 68 69 76 86 48 ## 4 61 63 45 47 54 84 35 ## 5 81 78 56 66 71 83 47 ## 6 43 55 49 44 54 49 34 rating 总体评价 complaints 处理员工投诉 privileges 不允许特权 learning 学习机会 raises 根据表现晋升 critical 批评 advancel 进步 fit &lt;- lm(rating ~. , data = attitude) summary(fit) # 模型是显著的，很多变量的系数不显著 ## ## Call: ## lm(formula = rating ~ ., data = attitude) ## ## Residuals: ## Min 1Q Median 3Q Max ## -10.9418 -4.3555 0.3158 5.5425 11.5990 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 10.78708 11.58926 0.931 0.361634 ## complaints 0.61319 0.16098 3.809 0.000903 *** ## privileges -0.07305 0.13572 -0.538 0.595594 ## learning 0.32033 0.16852 1.901 0.069925 . ## raises 0.08173 0.22148 0.369 0.715480 ## critical 0.03838 0.14700 0.261 0.796334 ## advance -0.21706 0.17821 -1.218 0.235577 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 7.068 on 23 degrees of freedom ## Multiple R-squared: 0.7326, Adjusted R-squared: 0.6628 ## F-statistic: 10.5 on 6 and 23 DF, p-value: 1.24e-05 anova(fit) ## Analysis of Variance Table ## ## Response: rating ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## complaints 1 2927.58 2927.58 58.6026 9.056e-08 *** ## privileges 1 7.52 7.52 0.1505 0.7016 ## learning 1 137.25 137.25 2.7473 0.1110 ## raises 1 0.94 0.94 0.0189 0.8920 ## critical 1 0.56 0.56 0.0113 0.9163 ## advance 1 74.11 74.11 1.4835 0.2356 ## Residuals 23 1149.00 49.96 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 attitude_mat &lt;- as.matrix.data.frame(attitude) # 生成演示用的矩阵 demo_mat &lt;- t(attitude_mat[, -1]) %*% attitude_mat[, -1] 参考文献 "],["subsec-matrix-multiplication.html", "34.1 矩阵乘法", " 34.1 矩阵乘法 A &lt;- matrix(c(1, 2, 2, 3), nrow = 2) A ## [,1] [,2] ## [1,] 1 2 ## [2,] 2 3 B &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow =2) B ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 通常的矩阵乘法也叫矩阵内积 A %*% B ## [,1] [,2] [,3] ## [1,] 5 11 17 ## [2,] 8 18 28 A ** 2 ## [,1] [,2] ## [1,] 1 4 ## [2,] 4 9 A ^ 2 ## [,1] [,2] ## [1,] 1 4 ## [2,] 4 9 A ** A ## [,1] [,2] ## [1,] 1 4 ## [2,] 4 27 "],["subsec-hadamard-product.html", "34.2 Hadamard 积", " 34.2 Hadamard 积 Hadamard 积（法国数学家 Jacques Hadamard）也叫 Schur 积（德国数学家Issai Schur ）或 entrywise 积是两个维数相同的矩阵对应元素相乘，特别地，\\(A^2\\) 表示将矩阵 \\(A\\) 的每个元素平方 \\[ (A\\circ B)_{ij} = (A)_{ij}(B)_{ij} \\] \\[ \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\end{bmatrix} \\circ \\begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} \\\\ b_{21} &amp; b_{22} &amp; b_{23} \\\\ b_{31} &amp; b_{32} &amp; b_{33} \\end{bmatrix} = \\begin{bmatrix} a_{11}b_{11} &amp; a_{12}b_{12} &amp; a_{13}b_{13} \\\\ a_{21}b_{21} &amp; a_{22}b_{22} &amp; a_{23}b_{23} \\\\ a_{31}b_{31} &amp; a_{32}b_{32} &amp; a_{33}b_{33} \\end{bmatrix} \\] A^2 ## [,1] [,2] ## [1,] 1 4 ## [2,] 4 9 "],["subsec-matrix-transpose.html", "34.3 矩阵转置", " 34.3 矩阵转置 t(B) ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 "],["subsec-outer-product.html", "34.4 矩阵外积", " 34.4 矩阵外积 A %o% B # outer(A, B, FUN = &quot;*&quot;) ## , , 1, 1 ## ## [,1] [,2] ## [1,] 1 2 ## [2,] 2 3 ## ## , , 2, 1 ## ## [,1] [,2] ## [1,] 2 4 ## [2,] 4 6 ## ## , , 1, 2 ## ## [,1] [,2] ## [1,] 3 6 ## [2,] 6 9 ## ## , , 2, 2 ## ## [,1] [,2] ## [1,] 4 8 ## [2,] 8 12 ## ## , , 1, 3 ## ## [,1] [,2] ## [1,] 5 10 ## [2,] 10 15 ## ## , , 2, 3 ## ## [,1] [,2] ## [1,] 6 12 ## [2,] 12 18 直积/克罗内克积 A %x% B # kronecker(A, B, FUN = &quot;*&quot;) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 3 5 2 6 10 ## [2,] 2 4 6 4 8 12 ## [3,] 2 6 10 3 9 15 ## [4,] 4 8 12 6 12 18 "],["subsec-matrix-exp.html", "34.5 矩阵乘方", " 34.5 矩阵乘方 矩阵 A 首先是一个方阵，对称性和正定性未知，n 个 矩阵 A 相乘 统计之都论坛讨论如何求矩阵的乘方 https://d.cosx.org/d/5619-svd &quot;%^%&quot; &lt;- function(mat, pow) { if (!is.matrix(mat)) mat &lt;- as.matrix(mat) stopifnot(!diff(dim(mat))) if (pow &lt; 0) { pow &lt;- -pow mat &lt;- solve(mat) } pow &lt;- round(pow) switch(pow + 1, return(diag(1, nrow(mat))), return(mat)) get.exponents &lt;- function(pow) if (pow == 0) NULL else c(k &lt;- 2^floor(log2(pow)), get.exponents(pow - k)) ans &lt;- diag(nrow(mat)) dlog2exp &lt;- rev(-diff(c(log2(get.exponents(pow)), 0))) for (j in 1:length(dlog2exp)) { if (dlog2exp[j]) for (i in 1:dlog2exp[j]) mat &lt;- mat %*% mat ans &lt;- ans %*% mat } ans } 奇异值分解 s &lt;- svd(A) all.equal(s$u%*%diag(s$d)%*%t(s$v),A) ## [1] TRUE 特征值及分解 \\(A = V \\Lambda V^{-1}\\) 求解矩阵 A 的 n 次方 eigen(A) ## eigen() decomposition ## $values ## [1] 4.236068 -0.236068 ## ## $vectors ## [,1] [,2] ## [1,] 0.5257311 -0.8506508 ## [2,] 0.8506508 0.5257311 eigen(A)$vectors %*% diag(eigen(A)$values) %*% solve(eigen(A)$vectors) ## [,1] [,2] ## [1,] 1 2 ## [2,] 2 3 eigen(A)$vectors %*% diag(eigen(A)$values)^3 %*% solve(eigen(A)$vectors) ## [,1] [,2] ## [1,] 21 34 ## [2,] 34 55 A %*% A %*% A ## [,1] [,2] ## [1,] 21 34 ## [2,] 34 55 "],["subsec-matrix-power.html", "34.6 矩阵求幂", " 34.6 矩阵求幂 2^A ## [,1] [,2] ## [1,] 2 4 ## [2,] 4 8 exp(A) ## [,1] [,2] ## [1,] 2.718282 7.389056 ## [2,] 7.389056 20.085537 expm 包含 更多关于矩阵开方、取对数等计算 "],["subsec-matrix-crossproduct.html", "34.7 矩阵交叉积", " 34.7 矩阵交叉积 交叉积 \\(A^{\\top}A\\) crossprod(A, A) # t(x) %*% y ## [,1] [,2] ## [1,] 5 8 ## [2,] 8 13 tcrossprod(A, A) # x %*% t(y) ## [,1] [,2] ## [1,] 5 8 ## [2,] 8 13 "],["subsec-matrix-determinant.html", "34.8 矩阵行列式", " 34.8 矩阵行列式 det(A) ## [1] -1 expm 包计算矩阵 \\(e^{\\mathbf{A}}\\) "],["subsec-matrix-cond-num.html", "34.9 矩阵条件数", " 34.9 矩阵条件数 library(Matrix) base::rcond(A) ## [1] 0.04 kappa(A) ## [1] 21.85714 Matrix::rcond(Matrix::Hilbert(6)) ## [1] 3.439939e-08 Matrix::rcond(A) ## [1] 0.04 "],["subsec-matrix-inverse.html", "34.10 矩阵求逆", " 34.10 矩阵求逆 solve(A) ## [,1] [,2] ## [1,] -3 2 ## [2,] 2 -1 应用之线性方程组 B &lt;- Hilbert(6) b &lt;- rowSums(B) # not inv solve(B,b) ## 6 x 1 Matrix of class &quot;dgeMatrix&quot; ## [,1] ## [1,] 1 ## [2,] 1 ## [3,] 1 ## [4,] 1 ## [5,] 1 ## [6,] 1 # inv solve(B) %*% b ## 6 x 1 Matrix of class &quot;dgeMatrix&quot; ## [,1] ## [1,] 1 ## [2,] 1 ## [3,] 1 ## [4,] 1 ## [5,] 1 ## [6,] 1 Moore-Penrose generalized inverse 广义逆，如果 A 可逆则，广义逆就是逆 library(MASS) # ginv 来自 MASS 包 ginv(A) ## [,1] [,2] ## [1,] -3 2 ## [2,] 2 -1 A %*% ginv(A) %*% A ## [,1] [,2] ## [1,] 1 2 ## [2,] 2 3 ginv(A) %*% A %*% ginv(A) ## [,1] [,2] ## [1,] -3 2 ## [2,] 2 -1 t(A %*% ginv(A)) ## [,1] [,2] ## [1,] 1.000000e+00 8.881784e-16 ## [2,] -8.881784e-16 1.000000e+00 A %*% ginv(A) ## [,1] [,2] ## [1,] 1.000000e+00 -8.881784e-16 ## [2,] 8.881784e-16 1.000000e+00 t(ginv(A) %*% A) ## [,1] [,2] ## [1,] 1.000000e+00 -8.881784e-16 ## [2,] 8.881784e-16 1.000000e+00 ginv(A) %*% A ## [,1] [,2] ## [1,] 1.000000e+00 8.881784e-16 ## [2,] -8.881784e-16 1.000000e+00 "],["subsec-matrix-adjoint.html", "34.11 矩阵伴随", " 34.11 矩阵伴随 伴随矩阵 \\(A*A^{\\star} = A^{\\star} *A = |A|*I, A^{\\star} = |A|*A^{-1}\\) \\(|A^{\\star}| = |A|^{n-1}, A \\in \\mathbb{R}^{n\\times n},n \\geq 2\\) \\((A^{\\star})^{\\star} = |A|^{n-2}A, A \\in \\mathbb{R}^{n\\times n},n \\geq 2\\) \\((A^{\\star})^{\\star}\\) A 的 n 次伴随是？ det(A)*solve(A) ## [,1] [,2] ## [1,] 3 -2 ## [2,] -2 1 "],["subsec-matrix-norm.html", "34.12 矩阵范数", " 34.12 矩阵范数 向量和矩阵的范数，包括1，2，无穷范数，其他操作看 Matrix 包，尤其关于稀疏矩阵计算部分 \\(1\\)-范数 列和绝对值最大的 \\(\\infty\\) - 范数 行和绝对值最大的 Frobenius - 范数 Euclidean 范数 \\(M\\) - 范数 矩阵里模最大的元素，矩阵里面的元素可能含有复数，所以取模最大 \\(2\\) - 范数 又称谱范数，矩阵最大的奇异值，如果是方阵，就是最大的特征值 norm(A, type = &quot;1&quot;) # max(abs(colSums(A))) ## [1] 5 norm(A, type = &quot;I&quot;) # max(abs(rowSums(A))) ## [1] 5 norm(A, type = &quot;F&quot;) ## [1] 4.242641 norm(A, type = &quot;M&quot;) # ## [1] 3 norm(A, type = &quot;2&quot;) # max(svd(A)$d) ## [1] 4.236068 显然，\\(1-,\\infty-,M-\\) 的范数计算比 \\(F-\\) 范数快，函数 norm 默认情况下求 \\(1-\\) 范数 "],["subsec-matrix-rank.html", "34.13 矩阵求秩", " 34.13 矩阵求秩 qr(A)$rank # or qr.default(A)$rank ## [1] 2 "],["subsec-matrix-trace.html", "34.14 矩阵求迹", " 34.14 矩阵求迹 若 \\[ A = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\end{bmatrix} \\] 则矩阵 \\(A\\) 的迹 \\(\\operatorname{tr}(A) = \\sum_{i=1}^{n}a_{ii}\\) sum(diag(A)) ## [1] 4 特殊矩阵的构造 "],["subsec-identity-matrix.html", "34.15 单位矩阵", " 34.15 单位矩阵 矩阵对角线上全是1，其余位置都是0 \\[ A = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] diag(rep(3)) ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 而全1矩阵是所有元素都是1的矩阵，可以借助外积运算构造，如3阶全1矩阵 rep(1,3) %o% rep(1,3) ## [,1] [,2] [,3] ## [1,] 1 1 1 ## [2,] 1 1 1 ## [3,] 1 1 1 "],["subsec-matrix-diagonals.html", "34.16 对角矩阵", " 34.16 对角矩阵 diag(A) # diagonal of a matrix ## [1] 1 3 diag(diag(A)) # construct a diagonal matrix ## [,1] [,2] ## [1,] 1 0 ## [2,] 0 3 "],["subsec-upper-matrix.html", "34.17 上/下三角矩阵", " 34.17 上/下三角矩阵 矩阵下三角 row 和 col row(A) ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 2 col(A) ## [,1] [,2] ## [1,] 1 2 ## [2,] 1 2 A[row(A)] ## [1] 1 3 upper.tri(A) # 矩阵上三角 ## [,1] [,2] ## [1,] FALSE TRUE ## [2,] FALSE FALSE A[upper.tri(A)] ## [1] 2 A[lower.tri(A)] &lt;- 0 # 获得上三角矩阵 A ## [,1] [,2] ## [1,] 1 2 ## [2,] 0 3 下三角矩阵 A &lt;- matrix(c(1, 2, 2, 3), nrow = 2) A ## [,1] [,2] ## [1,] 1 2 ## [2,] 2 3 lower.tri(A) ## [,1] [,2] ## [1,] FALSE FALSE ## [2,] TRUE FALSE A[lower.tri(A)] ## [1] 2 A[upper.tri(A)] &lt;- 0 # 获得下三角矩阵 A ## [,1] [,2] ## [1,] 1 0 ## [2,] 2 3 A &lt;- matrix(c(1, 2, 2, 3), nrow = 2) A[row(A) &lt; col(A)] &lt;- 0 A ## [,1] [,2] ## [1,] 1 0 ## [2,] 2 3 "],["subsec-sparse-matrix.html", "34.18 稀疏矩阵", " 34.18 稀疏矩阵 dn &lt;- list(LETTERS[1:3], letters[1:5]) ## pointer vectors can be used, and the (i,x) slots are sorted if necessary: ## 使用指针构造 m &lt;- sparseMatrix(i = c(3,1, 3:2, 2:1), p= c(0:2, 4,4,6), x = 1:6, dimnames = dn) m ## 3 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## a b c d e ## A . 2 . . 6 ## B . . 4 . 5 ## C 1 . 3 . . ## 典型构造方式 i &lt;- c(1,3:8); j &lt;- c(2,9,6:10); x &lt;- 7 * (1:7) (AA &lt;- sparseMatrix(i, j, x = x)) ## 8 x 10 &quot;dgCMatrix&quot; ## 8 x 10 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . 7 . . . . . . . . ## [2,] . . . . . . . . . . ## [3,] . . . . . . . . 14 . ## [4,] . . . . . 21 . . . . ## [5,] . . . . . . 28 . . . ## [6,] . . . . . . . 35 . . ## [7,] . . . . . . . . 42 . ## [8,] . . . . . . . . . 49 "],["subsec-triangular-matrix.html", "34.19 三对角矩阵", " 34.19 三对角矩阵 "],["subsec-lu-decomposition.html", "34.20 LU 分解", " 34.20 LU 分解 "],["subsec-schur-decomposition.html", "34.21 Schur 分解", " 34.21 Schur 分解 "],["subsec-Choleski-Decomposition.html", "34.22 Cholesky 分解", " 34.22 Cholesky 分解 实对称正定矩阵的 Choleski 分解 chol(A + diag(rep(1,2))) ## [,1] [,2] ## [1,] 1.414214 0 ## [2,] 0.000000 2 # Inverse from Choleski (or QR) Decomposition Matrix::chol2inv(A + diag(rep(1,2))) ## [,1] [,2] ## [1,] 0.25 0.0000 ## [2,] 0.00 0.0625 Matrix::Cholesky 实现稀疏 Cholesky 分解 "],["subsec-Eigenvalues-Decomposition.html", "34.23 特征值分解", " 34.23 特征值分解 特征值分解（Eigenvalues Decomposition）也叫谱分解（Spectral Decomposition） eigen(A) ## eigen() decomposition ## $values ## [1] 3 1 ## ## $vectors ## [,1] [,2] ## [1,] 0 0.7071068 ## [2,] 1 -0.7071068 "],["subsec-Singular-Value-Decomposition.html", "34.24 SVD 分解", " 34.24 SVD 分解 Fast truncated singular value decompositions 奇异值分解是特征值分解的推广 svd(A) ## $d ## [1] 3.6502815 0.8218544 ## ## $u ## [,1] [,2] ## [1,] -0.1601822 -0.9870875 ## [2,] -0.9870875 0.1601822 ## ## $v ## [,1] [,2] ## [1,] -0.5847103 -0.8112422 ## [2,] -0.8112422 0.5847103 svd(A)$d ## [1] 3.6502815 0.8218544 邱怡轩将奇异值分解用于图像压缩 https://cosx.org/2014/02/svd-and-image-compression 并制作了 Shiny App 交互式演示 "],["subsec-QR-Decomposition.html", "34.25 QR 分解", " 34.25 QR 分解 qr.default(A) ## $qr ## [,1] [,2] ## [1,] -2.2360680 -2.683282 ## [2,] 0.8944272 1.341641 ## ## $rank ## [1] 2 ## ## $qraux ## [1] 1.447214 1.341641 ## ## $pivot ## [1] 1 2 ## ## attr(,&quot;class&quot;) ## [1] &quot;qr&quot; qr.X(qr.default(A)) ## [,1] [,2] ## [1,] 1 0 ## [2,] 2 3 qr.Q(qr.default(A)) ## [,1] [,2] ## [1,] -0.4472136 -0.8944272 ## [2,] -0.8944272 0.4472136 qr.R(qr.default(A)) ## [,1] [,2] ## [1,] -2.236068 -2.683282 ## [2,] 0.000000 1.341641 qr.Q(qr.default(A)) %*% qr.R(qr.default(A)) ## [,1] [,2] ## [1,] 1 -2.220446e-16 ## [2,] 2 3.000000e+00 用 Householder 变换 做 QR 分解 (Bates and Watts 1988) 及其 R 语言实现 https://rpubs.com/aaronsc32/qr-decomposition-householder Householder 变换是平面反射的一般情况： 要计算 \\(N\\times P\\) 维矩阵 \\(X\\) 的 QR 分解，我们采用 Householder 变换 \\[ \\mathbf{H}_{u} = \\mathbf{I} -2\\mathbf{u}\\mathbf{u}^{\\top} \\] 其中 \\(I\\) 是 \\(N\\times N\\) 维的单位矩阵，\\(u\\) 是 \\(N\\) 维单位向量，即 \\(\\| \\mathbf{u}\\| = \\sqrt{\\mathbf{u}\\mathbf{u}^{\\top}} = 1\\)。则 \\(H_u\\) 是对称正交的，因为 \\[ \\mathbf{H}_{u}^{\\top} = \\mathbf{I}^{\\top} - 2\\mathbf{u}\\mathbf{u}^{\\top} = \\mathbf{H}_{u} \\] 并且 \\[ \\mathbf{H}_{u}^{\\top}\\mathbf{H}_{u} = \\mathbf{I} -4\\mathbf{u}\\mathbf{u}^{\\top} + 4\\mathbf{u}\\mathbf{u}^{\\top}\\mathbf{u}\\mathbf{u}^{\\top} = \\mathbf{I} \\] 让 \\(\\mathbf{H}_{u}\\) 乘以向量 \\(\\mathbf{y}\\)，即 \\[ \\mathbf{H}_{u}\\mathbf{y} = \\mathbf{y} - 2\\mathbf{u}\\mathbf{u}^{\\top}\\mathbf{y} \\] 它是 \\(y\\) 关于垂直于过原点的 \\(u\\) 的直线的反射，只要 \\[\\begin{equation} \\mathbf{u} = \\frac{\\mathbf{y} - \\| \\mathbf{y} \\|\\mathbf{e}_{1}}{\\| \\mathbf{y} - \\| \\mathbf{y} \\|\\mathbf{e}_{1}\\|} \\tag{34.1} \\end{equation}\\] 或者 \\[\\begin{equation} \\mathbf{u} = \\frac{\\mathbf{y} + \\| \\mathbf{y} \\|\\mathbf{e}_{1}}{\\| \\mathbf{y} + \\| \\mathbf{y} \\|\\mathbf{e}_{1}\\|} \\tag{34.2} \\end{equation}\\] 其中 \\(\\mathbf{e}_{1} = (1,0,\\ldots,0)^{\\top}\\)，Householder 变换使得向量 \\(y\\) 成为 \\(x\\) 轴，在新的坐标系统中，向量 \\(H_{u}y\\) 的坐标为 \\((\\pm\\|y\\|, 0, \\ldots, 0)^\\top\\) 举个例子 借助 Householder 变换做 QR 分解的优势： 更快、数值更稳定比直接构造 Q，特别当 N 大于 P 的时候 相比于存储矩阵 Q 的 \\(N^2\\) 个元素，Householder 变换只存储 P 个向量 \\(u_1,\\ldots,u_P\\) QR 分解的真实实现，比如在 LINPACK 中，定义 \\(u\\) 的时候，公式 (34.1) 或 (34.2) 的选择基于\\(y\\)的第一个坐标的符号。如果坐标是负的，使用公式(34.1)，如果是正的，使用公式 (34.2)， 这个做法可以使得数值计算更加稳定。 Stan 实现的 QR 分解在贝叶斯线性回归模型中的应用45 参考文献 "],["subsec-jordan-Decomposition.html", "34.26 Jordan 分解", " 34.26 Jordan 分解 "],["subsec-Givens-Rotation.html", "34.27 Givens 旋转", " 34.27 Givens 旋转 Givens 旋转 https://www.wikiwand.com/en/Givens_rotation 帽子矩阵在统计中的应用 回归与方差分析 (Hoaglin and Welsch 1978) 参考文献 "],["sec-special-functions.html", "34.28 特殊函数", " 34.28 特殊函数 34.28.1 阶乘 阶乘 \\(n! = 1\\times 2\\times 3\\cdots n\\) 双阶乘 \\((2n+1)!! = 1 \\times 3\\times 5 \\times \\cdots \\times (2n+1), n = 0,1,2,\\cdots\\) factorial(5) # 阶乘 ## [1] 120 seq(from = 1, to = 5, length.out = 3) ## [1] 1 3 5 prod(seq(from = 1, to = 5, length.out = 3)) # 连乘 双阶乘 ## [1] 15 seq(5) ## [1] 1 2 3 4 5 cumprod(seq(5)) # 累积 ## [1] 1 2 6 24 120 cumsum(seq(5)) # 累和 ## [1] 1 3 6 10 15 此外还有 cummax 和 cummin 组合数 \\(C_{n}^{k} = \\frac{n(n-1)…(n-k+1)}{k!}\\) \\(C_{5}^{3} = \\frac{5 \\times 4 \\times 3}{3 \\times 2 \\times 1}\\) choose(5,3) ## [1] 10 斯特林公式 34.28.2 伽马函数 \\(\\Gamma(x) = \\int_{0}^{\\infty} t^{x-1}\\exp(-t)dt\\) \\(\\Gamma(n) = (n-1)!, n \\in \\mathbb{Z}^{+}\\) gamma(2) ## [1] 1 gamma(10) ## [1] 362880 gamma2 &lt;- function(t,x){ t^(x-1)*exp(-t) } integrate(gamma2, lower = 0, upper = + Inf, x = 10) ## 362880 with absolute error &lt; 0.025 psigamma(x, deriv) 表示 \\(\\psi(x)\\) 的 deriv 阶导数 \\(\\mathrm{digamma}(x) \\triangleq \\psi(x) = \\frac{d}{dx}{\\ln \\Gamma(x)} = \\Gamma&#39;(x) / \\Gamma(x)\\) # 例1 x &lt;- 2 eval(deriv(~ gamma(x), &quot;x&quot;))/gamma(x) ## [1] 1 ## attr(,&quot;gradient&quot;) ## x ## [1,] 0.4227843 # 与此等价 psigamma(2, 0) ## [1] 0.4227843 digamma(x) # psi(x) 的一阶导数 ## [1] 0.4227843 trigamma(x) # psi(x) 的二阶导数 ## [1] 0.6449341 # 例2 eval(deriv(~ psigamma(x, 1), &quot;x&quot;)) ## [1] 0.6449341 ## attr(,&quot;gradient&quot;) ## x ## [1,] -0.4041138 # 与此等价 psigamma(2, 2) ## [1] -0.4041138 # 注意与下面这个例子比较 dx2x &lt;- deriv(~ x^3, &quot;x&quot;) eval(dx2x) ## [1] 8 ## attr(,&quot;gradient&quot;) ## x ## [1,] 12 34.28.3 贝塔函数 \\(B(a,b) = \\Gamma(a)\\Gamma(b)/\\Gamma(a+b) = \\int_{0}^{1} t^{a-1} (1-t)^{b-1} dt\\) beta(1, 1) ## [1] 1 beta(2, 3) ## [1] 0.08333333 beta2 &lt;- function(t, a, b) { t^(a - 1) * (1 - t)^(b - 1) } integrate(beta2, lower = 0, upper = 1, a = 2, b = 3) ## 0.08333333 with absolute error &lt; 9.3e-16 34.28.4 贝塞尔函数 besselI(x, nu, expon.scaled = FALSE) # 修正的第一类 besselK(x, nu, expon.scaled = FALSE) # 修正的第二类 besselJ(x, nu) # 第一类 besselY(x, nu) # 第二类 \\(\\nu\\) 贝塞尔函数的阶，可以是分数 expon.scaled 是否使用指数表示 nus &lt;- c(0:5, 10, 20) x &lt;- seq(0, 4, length.out = 501) plot(x, x, ylim = c(0, 6), ylab = &quot;&quot;, type = &quot;n&quot;, main = &quot;Bessel Functions I_nu(x)&quot; ) for (nu in nus) lines(x, besselI(x, nu = nu), col = nu + 2) legend(0, 6, legend = paste(&quot;nu=&quot;, nus), col = nus + 2, lwd = 1) "],["chap-symbolic-computation.html", "第 35 章 符号计算", " 第 35 章 符号计算 相比于数值计算，符号计算可以无限精度，包括微分、积分运法，求解线性、非线性方程（组），常微分、偏微分方程（组）等，R 自带几个函数如 deriv()、D() 等可以做一些简单的微分运算，扩展包 Ryacas 提供 Yacas 核心计算引擎，symengine 引入 C++ 符号计算库SymEngine，相比于 Ryacas，symengine 不会和 Base R 函数冲突。Python 的符号计算模块 sympy (Meurer et al. 2017) 不仅支持简单的四则运算，还支持微分、积分、解方程等，详见官方文档 https://sympy.org/。 # 多元函数求偏导 ftoo &lt;- deriv(expression(sin(x1) + sin(x2) + cos(3 * x1 * x2) + x1^2 + x2^2), namevec = c(&quot;x1&quot;, &quot;x2&quot;), function.arg = TRUE ) # 隐函数求偏导 deriv(y ~ sin(cos(x) * y), namevec = c(&quot;x&quot;,&quot;y&quot;), function.arg = TRUE) ## function (x, y) ## { ## .expr1 &lt;- cos(x) ## .expr2 &lt;- .expr1 * y ## .expr4 &lt;- cos(.expr2) ## .value &lt;- sin(.expr2) ## .grad &lt;- array(0, c(length(.value), 2L), list(NULL, c(&quot;x&quot;, ## &quot;y&quot;))) ## .grad[, &quot;x&quot;] &lt;- -(.expr4 * (sin(x) * y)) ## .grad[, &quot;y&quot;] &lt;- .expr4 * .expr1 ## attr(.value, &quot;gradient&quot;) &lt;- .grad ## .value ## } 下面以标准正态分布的密度函数为例， NormDensity &lt;- expression(1 / sqrt(2 * pi) * exp(-x^2 / 2)) # 递归的方法求高阶倒数 DD &lt;- function(expr, name, order = 1) { if (order &lt; 1) { stop(&quot;&#39;order&#39; must be &gt;= 1&quot;) } if (order == 1) { D(expr, name) } else { DD(D(expr, name), name, order - 1) } } # 计算三阶导数 DD(NormDensity, &quot;x&quot;, 3) ## 1/sqrt(2 * pi) * (exp(-x^2/2) * (2 * x/2) * (2/2) + ((exp(-x^2/2) * ## (2/2) - exp(-x^2/2) * (2 * x/2) * (2 * x/2)) * (2 * x/2) + ## exp(-x^2/2) * (2 * x/2) * (2/2))) Deriv 可以将 R 表达式简化 library(Deriv) Simplify(DD(NormDensity, &quot;x&quot;, 3)) ## x * (3 - x^2) * exp(-(x^2/2))/sqrt(2 * pi) 即 \\(x (3 - x^2) \\mathrm{e}^{-x^2/2}/\\sqrt{2 \\pi}\\)，eval() 将表达式转为函数，代入数值运算。 Tetrachoric &lt;- function(x, j) { (-1)^(j - 1) / sqrt(factorial(j)) * eval(DD(NormDensity, &quot;x&quot;, j)) } Tetrachoric(2, 3) ## [1] -0.04408344 下面简单介绍 symengine 的符号计算能力 library(symengine) # 声明几个符号变量 use_vars(x, y, z) # 表达式展开 expr &lt;- (x + y + z) ^ 2L - 42L expand(expr) ## (Add) -42 + 2*x*y + 2*x*z + 2*y*z + x^2 + y^2 + z^2 变量替换 a &lt;- S(&quot;a&quot;) # z 用 a 替换 expr &lt;- subs(expr, z, a) # y 用 x^2 替换 expr &lt;- subs(expr, y, x^2L) expr ## (Add) -42 + (a + x + x^2)^2 表达式求 2 阶偏导 d1_expr &lt;- DD(expr, &quot;x&quot;, 2) expand(d1_expr) ## (Add) 2 + 4*a + 12*x + 12*x^2 求解带参数 \\(a\\) 的一元二次方程 solutions &lt;- solve(d1_expr, &quot;x&quot;) solutions ## VecBasic of length 2 ## V( -1/2 + (-1/2)*sqrt(1 + (-1/3)*(2 + 4*a)), -1/2 + (1/2)*sqrt(1 + (-1/3)*(2 + 4*a)) ) from sympy import * # 设置显示样式 init_printing(use_unicode=False, wrap_line=False) x = Symbol(&#39;x&#39;) # 积分 integrate(x**2 + x + 1, x) # 因式分解 factor(5*x**4/2 + 3*x**3 - 108*x**2/5 - 27*x - 81/10) 参考文献 "],["chap-numerical-optimization.html", "第 36 章 数值优化", " 第 36 章 数值优化 R 语言提供了相当多的优化求解器，比较完整的概览见优化视图。 本章介绍一些常用的优化算法及其R实现，涵盖线性规划、整数规划、二次规划、非线性规划等。商业的优化求解器的介绍见 MOSEK 优化材料、 Matlab 优化工具箱 Optimization Toolbox User’s Guide。 Berwin A. Turlach 开发的 quadprog 主要用于求解二次规划问题。Anqi Fu 开发的 CVXR 可解很多凸优化问题 (Fu, Narasimhan, and Boyd 2020)，详见网站 https://cvxr.rbind.io/，Jelmer Ypma 开发的 nloptr 可解无约束和有约束的非线性规划问题 (Ypma 2020)，GPareto 求解多目标优化问题，帕雷托前沿优化和估计(Binois and Picheny 2019)。igraph 可以用来解决最短路径、最大网络流、最小生成树等图优化相关的问题。 https://palomar.home.ece.ust.hk/MAFS6010R_lectures/Rsession_solvers.html 提供了一般的求解器介绍。ROI 包力图统一各个求解器的调用接口，打造一个优化算法的基础设施平台。Theußl, Schwendinger, and Hornik (2020) 详细介绍了目前优化算法发展情况及 R 社区提供的优化能力。GA 包实现了遗传算法，支持连续和离散的空间搜索，可以并行 (Scrucca 2013, 2017)，是求解 TSP 问题的重要方法。NMOF 包实现了差分进化、遗传算法、粒子群算法、模拟退火算法等启发式优化算法，还提供网格搜索和贪婪搜索工具，Gilli, Maringer, and Schumann (2019) 提供了详细的介绍。Nash (2014) 总结了 R 语言环境下最优化问题的最佳实践。RcppEnsmallen 数值优化 通用标准的优化方法，前沿最新的优化方法，包含小批量/全批量梯度下降技术、无梯度优化器，约束优化技术。RcppNumerical 无约束数值优化，一维/多维数值积分。 谷歌开源的运筹优化工具 or-tools 提供了约束优化、线性优化、混合整数优化、装箱和背包算法、TSP（Traveling Salesman Problem）、VRP（Vehicle Routing Problem）、图算法（最短路径、最小成本流、最大流等）等算法和求解器。「运筹OR帷幄」社区开源的 线性规划 一书值得一看。 # 加载 ROI 时不要自动加载插件 Sys.setenv(ROI_LOAD_PLUGINS = FALSE) library(lpSolve) # 线性规划求解器 library(ROI) # 优化工具箱 library(ROI.plugin.alabama) # 注册 alabama 求解器 library(ROI.plugin.nloptr) # 注册 nloptr 求解器 library(ROI.plugin.lpsolve) # 注册 lpsolve 求解器 library(ROI.plugin.quadprog) # 注册 quadprog 求解器 library(lattice) # 图形绘制 library(kernlab) # 优化问题和机器学习的关系 表 36.1 对目前的优化器按优化问题做了分类 表 36.1: ROI 插件按优化问题分类 Linear Quadratic Conic Functional No Box optimx Linear \\(\\mathrm{clp}^\\star\\), \\(\\mathrm{cbc}^{\\star+}\\), \\(\\mathrm{glpk}^{\\star+}\\), \\(\\mathrm{lpsolve}^{\\star+}\\), \\(\\mathrm{msbinlp}^{\\star+}\\), \\(\\mathrm{symphony}^{\\star+}\\) ipop, \\(\\mathrm{quadprog}^{\\star}\\), qpoases Quadratic \\(\\mathrm{cplex}^{+}\\), \\(\\mathrm{gurobi}^{\\star+}\\), \\(\\mathrm{mosek}^{\\star+}\\), \\(\\mathrm{neos}^{+}\\) Conic \\(\\mathrm{ecos}^{\\star+}\\), \\(\\mathrm{scs}^{\\star}\\) Functional alabama, deoptim, nlminb, nloptr * 求解器受限于凸优化问题 + 求解器可以处理整型约束 参考文献 "],["sec-linear-programming.html", "36.1 线性规划", " 36.1 线性规划 clpAPI 线性规划求解器。glpk 的两个 R 接口 – glpkAPI 和 Rglpk 提供线性规划和混合整数规划的求解能力。lp_solve 的两个 R 接口 – lpSolveAPI 和 lpSolve 也提供类似的能力。ompr 求解混合整数线性规划问题。 举个例子，如下 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad -6x_1 -5x_2 \\\\ s.t.\\left\\{ \\begin{array}{l} x_1 + 4x_2 &amp; \\leq 16\\\\ 6x_1 + 4x_2 &amp; \\leq 28\\\\ 2x_1 - 5x_2 &amp; \\leq 6 \\end{array} \\right. \\end{array} \\end{equation*}\\] 写成矩阵形式 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad \\begin{bmatrix} -6 \\\\ -5 \\end{bmatrix} ^{T} x \\\\ s.t.\\left\\{ \\begin{array}{l} \\begin{bmatrix} 1 &amp; 4 \\\\ 6 &amp; 4 \\\\ 2 &amp; -5 \\end{bmatrix} x \\leq \\begin{bmatrix} 16 \\\\ 28 \\\\ 6 \\end{bmatrix} \\end{array} \\right. \\end{array} \\end{equation*}\\] 对应成 R 代码如下 # lpSolve 添加约束条件 library(lpSolve) # 目标 f.obj &lt;- c(-6, -5) # 约束 f.con &lt;- matrix(c(1, 4, 6, 4, 2, -5), nrow = 3, byrow = TRUE) # 方向 f.dir &lt;- c(&quot;&lt;=&quot;, &quot;&lt;=&quot;, &quot;&lt;=&quot;) # 右手边 f.rhs &lt;- c(16, 28, 6) res &lt;- lp(&quot;min&quot;, f.obj, f.con, f.dir, f.rhs) res$objval ## [1] -31.4 res$solution ## [1] 2.4 3.4 "],["sec-integer-programming.html", "36.2 整数规划", " 36.2 整数规划 36.2.1 一般整数规划 \\[\\begin{equation*} \\begin{array}{l} \\max_x \\quad 0.2x_1 + 0.6x_2 \\\\ s.t.\\left\\{ \\begin{array}{l} 5x_1 + 3x_2 \\leq 250\\\\ -3x_1 + 2x_2 \\leq 4\\\\ x_1,x_2 \\geq 0, \\quad x_1,x_2 \\in \\mathbb{Z} \\end{array} \\right. \\end{array} \\end{equation*}\\] # 目标 f.obj &lt;- c(0.2, 0.6) # 约束 f.con &lt;- matrix(c(5, 3, -3, 2), nrow = 2, byrow = TRUE) # 方向 f.dir &lt;- c(&quot;&lt;=&quot;, &quot;&lt;=&quot;) # 右手边 f.rhs &lt;- c(250, 4) # 限制两个变量都是整数 res &lt;- lp(&quot;max&quot;, f.obj, f.con, f.dir, f.rhs, int.vec=1:2) res$objval ## [1] 29.2 res$solution ## [1] 26 40 36.2.2 0-1 整数规划 \\[\\begin{equation*} \\begin{array}{l} \\max_x \\quad 0.2x_1 + 0.6x_2 \\\\ s.t.\\left\\{ \\begin{array}{l} 5x_1 + 3x_2 \\leq 250\\\\ -3x_1 + 2x_2 \\leq 4\\\\ x_1,x_2 \\in \\{0,1\\} \\end{array} \\right. \\end{array} \\end{equation*}\\] # 目标 f.obj &lt;- c(0.2, 0.6) # 约束 f.con &lt;- matrix(c(5, 3, -3, 2), nrow = 2, byrow = TRUE) # 方向 f.dir &lt;- c(&quot;&lt;=&quot;, &quot;&lt;=&quot;) # 右手边 f.rhs &lt;- c(250, 4) # 限制两个变量都是0-1整数 res &lt;- lp(&quot;max&quot;, f.obj, f.con, f.dir, f.rhs, int.vec=1:2, all.bin = TRUE) res$objval ## [1] 0.8 res$solution ## [1] 1 1 36.2.3 混合整数规划 一部分变量要求是整数 \\[\\begin{equation*} \\begin{array}{l} \\max_x \\quad 3x_1 + 7x_2 - 12x_3 \\\\ s.t.\\left\\{ \\begin{array}{l} 5x_1 + 7x_2 + 2x_3 \\leq 61\\\\ 3x_1 + 2x_2 - 9x_3 \\leq 35\\\\ x_1 + 3x_2 + x_3 \\leq 31\\\\ x_1,x_2 \\geq 0, \\quad x_2, x_3 \\in \\mathbb{Z}, \\quad x_3 \\in [-10, 10] \\end{array} \\right. \\end{array} \\end{equation*}\\] 矩阵形式如下 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad \\begin{bmatrix} 3 \\\\ 7 \\\\ -12 \\end{bmatrix} ^{T} x \\\\ s.t.\\left\\{ \\begin{array}{l} \\begin{bmatrix} 5 &amp; 7 &amp; 2 \\\\ 3 &amp; 2 &amp; -9\\\\ 1 &amp; 3 &amp; 1 \\end{bmatrix} x \\leq \\begin{bmatrix} 61 \\\\ 35 \\\\ 31 \\end{bmatrix} \\end{array} \\right. \\end{array} \\end{equation*}\\] op &lt;- OP( objective = L_objective(c(3, 7, -12)), # 指定变量类型：第1个变量是连续值，第2、3个变量是整数 types = c(&quot;C&quot;, &quot;I&quot;, &quot;I&quot;), constraints = L_constraint( L = matrix(c( 5, 7, 2, 3, 2, -9, 1, 3, 1 ), ncol = 3, byrow = TRUE), dir = c(&quot;&lt;=&quot;, &quot;&lt;=&quot;, &quot;&lt;=&quot;), rhs = c(61, 35, 31) ), # 添加约束：第3个变量的下、上界分别是 -10 和 10 bounds = V_bound(li = 3, ui = 3, lb = -10, ub = 10, nobj = 3), maximum = TRUE ) op ## ROI Optimization Problem: ## ## Maximize a linear objective function of length 3 with ## - 1 continuous objective variable, ## - 2 integer objective variables, ## ## subject to ## - 3 constraints of type linear. ## - 1 lower and 1 upper non-standard variable bound. res &lt;- ROI_solve(op, solver = &quot;lpsolve&quot;) res$solution ## [1] 0.3333333 8.0000000 -2.0000000 res$objval ## [1] 81 "],["sec-quadratic-programming.html", "36.3 二次规划", " 36.3 二次规划 36.3.1 凸二次规划 在 R 中使用 quadprog (Turlach 2019) 包求解二次规划46，quadprogXT 包用来求解带绝对值约束的二次规划，pracma (Borchers 2021)包提供 quadprog() 函数就是对 quadprog 包的 solve.QP() 进行封装，调用风格更像 Matlab。quadprog 包实现了 Goldfarb and Idnani (1982, 1983) 提出的对偶方法，主要用来求解带线性约束的严格凸二次规划问题。quadprog 求解的二次型的形式如下： \\[\\min_b - d^{\\top}b +\\frac{1}{2}b^{\\top}Db , \\quad A^{\\top}b \\geq b_{0}\\] solve.QP(Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE) 参数 Dmat、dvec、Amat、bvec 分别对应二次规划问题中的 \\(D,d,A,b_{0}\\)。下面举个二次规划的具体例子 \\[ D = \\begin{bmatrix}2 &amp; -1\\\\ -1 &amp; 2 \\end{bmatrix}, \\quad d = (-3,2), \\quad A = \\begin{bmatrix}1 &amp; 1\\\\ -1 &amp; 1 \\\\ 0 &amp; -1 \\end{bmatrix}, \\quad b_{0} = (2,-2,-3) \\] 即目标函数 \\[Q(x,y) = x^2 + y^2 -xy+3x-2y+4\\] 它的可行域如图36.1所示 plot(0, 0, xlim = c(-2, 5.5), ylim = c(-1, 3.5), type = &quot;n&quot;, xlab = &quot;x&quot;, ylab = &quot;y&quot;, main = &quot;Feasible Region&quot; ) polygon(c(2, 5, -1), c(0, 3, 3), border = TRUE, lwd = 2, col = &quot;gray&quot;) 图 36.1: 可行域 调用 quadprog 包的 solve.QP() 函数求解此二次规划问题 library(quadprog) Dmat &lt;- matrix(c(2, -1, -1, 2), nrow = 2, byrow = TRUE) dvec &lt;- c(-3, 2) A &lt;- matrix(c(1, 1, -1, 1, 0, -1), ncol = 2, byrow = TRUE) bvec &lt;- c(2, -2, -3) Amat &lt;- t(A) sol &lt;- solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec) sol ## $solution ## [1] 0.1666667 1.8333333 ## ## $value ## [1] -0.08333333 ## ## $unconstrained.solution ## [1] -1.3333333 0.3333333 ## ## $iterations ## [1] 2 0 ## ## $Lagrangian ## [1] 1.5 0.0 0.0 ## ## $iact ## [1] 1 ROI 默认的二次规划的标准形式为 \\(\\frac{1}{2}x^{\\top}Qx + a^{\\top}x\\)，在传递参数值的时候注意和上面的区别。 library(ROI) op &lt;- OP( objective = Q_objective(Q = Dmat, L = -dvec), constraints = L_constraint(A, rep(&quot;&gt;=&quot;, 3), bvec), maximum = FALSE # 默认求最小 ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.slsqp&quot;, start = c(1, 2)) nlp$objval ## [1] -0.08333333 nlp$solution ## [1] 0.1666667 1.8333333 对变量 \\(x\\) 添加整型约束，原二次规划即变成混合整数二次规划 （Mixed Integer Quadratic Programming，简称 MIQP） # 目前开源的求解器都不能处理 MIQP 问题 op &lt;- OP( objective = Q_objective(Q = Dmat, L = -dvec), constraints = L_constraint(A, rep(&quot;&gt;=&quot;, 3), bvec), types = c(&quot;I&quot;, &quot;C&quot;), maximum = FALSE # 默认求最小 ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.slsqp&quot;, start = c(1, 2)) nlp$objval nlp$solution 在可行域上画出等高线，标记目标解的位置，图中红点表示无约束下的解，黄点表示线性约束下的解 qp_sol &lt;- sol$solution # 二次规划的解 uc_sol &lt;- sol$unconstrained.solution # 无约束情况下的解 # 画图 library(lattice) x &lt;- seq(-2, 5.5, length.out = 500) y &lt;- seq(-1, 3.5, length.out = 500) grid &lt;- expand.grid(x = x, y = y) # 二次规划的目标函数 grid$z &lt;- with(grid, x^2 + y^2 - x * y + 3 * x - 2 * y + 4) levelplot(z ~ x * y, grid, cuts = 40, panel = function(...) { panel.levelplot(...) panel.polygon(c(2, 5, -1), c(0, 3, 3), border = TRUE, lwd = 2, col = &quot;transparent&quot; ) panel.points( c(uc_sol[1], qp_sol[1]), c(uc_sol[2], qp_sol[2]), lwd = 5, col = c(&quot;red&quot;, &quot;yellow&quot;), pch = 19 ) }, colorkey = TRUE, col.regions = terrain.colors(40) ) 图 36.2: 无约束和有约束条件下的解 36.3.2 半正定二次优化 kernlab 提供基于核的机器学习方法，可用于分类、回归、聚类、异常检测、分位回归、降维等场景，包含支撑向量机、谱聚类、核PCA、高斯过程和二次规划求解器，将优化方法用于机器学习，展示二者的关系。 R 包 kernlab 的函数 ipop() 实现内点法可以求解半正定的二次规划问题，对应到上面的例子，就是要求 \\(A \\geq 0\\)，而 R 包 quadprog 只能求解正定的二次规划问题，即要求 \\(A &gt; 0\\)。 以二分类问题为例，采用 SMO (Sequential Minimization Optimization) 求解器，将 SVM 的二次优化问题分解。 library(kernlab) set.seed(123) x &lt;- rbind(matrix(rnorm(120), 60, 2), matrix(rnorm(120, mean = 3), 60, 2)) y &lt;- matrix(c(rep(1, 60), rep(-1, 60))) svp &lt;- ksvm(x, y, type = &quot;C-svc&quot;) plot(svp, data = x) 图 36.3: 二分类问题 参考文献 "],["sec-nonlinear-programming.html", "36.4 非线性规划", " 36.4 非线性规划 开源的非线性优化求解器，推荐使用 nloptr，它支持全局优化，同时推荐 ROI，它有统一的接口函数。 36.4.1 一元非线性优化 复合函数求极值 \\[ g(x) = \\int_{0}^{x} -\\sqrt{t}\\exp(-t^2) \\mathrm{dt}, \\quad f(y) = \\int_{0}^{y} g(s) \\exp(-s) \\mathrm{ds} \\] g &lt;- function(x) { integrate(function(t) { -sqrt(t) * exp(-t^2) }, lower = 0, upper = x)$value } f &lt;- function(y) { integrate(function(s) { Vectorize(g, &quot;x&quot;)(s) * exp(-s) }, lower = 0, upper = y)$value } optimize(f, interval = c(10, 100), maximum = FALSE) ## $minimum ## [1] 66.84459 ## ## $objective ## [1] -0.3201572 计算积分的时候，输入了一系列 s 值，参数是向量，而函数 g 只支持输入参数是单个值，g(c(1,2)) 则会报错 g(1) ## [1] -0.453392 36.4.2 多元非线性无约束优化 36.4.2.1 Himmelblau 函数 Himmelblau 函数是一个多摸函数，常用于比较优化算法的优劣。 \\[f(x,y) = (x_1^2 + x_2 -11)^2 + (x_1 + x_2^2 -7)^2\\] 它在四个位置取得一样的极小值，分别是 \\(f(-3.7793, -3.2832) = 0\\)，\\(f(-2.8051, 3.1313) = 0\\)，\\(f(3, 2) = 0\\)，\\(f(3.5844, -1.8481) = 0\\)。函数图像见图 36.4。 # 目标函数 fn &lt;- function(x) { (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2 } df &lt;- expand.grid( x = seq(-5, 5, length = 101), y = seq(-5, 5, length = 101) ) df$fnxy = apply(df, 1, fn) library(lattice) # 减少三维图形的边空 lattice.options( layout.widths = list( left.padding = list(x = -.6, units = &quot;inches&quot;), right.padding = list(x = -1.0, units = &quot;inches&quot;) ), layout.heights = list( bottom.padding = list(x = -.8, units = &quot;inches&quot;), top.padding = list(x = -1.0, units = &quot;inches&quot;) ) ) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = -240, x = -70, y = 0) ) 图 36.4: Himmelblau 函数图像 # 梯度函数 gr &lt;- function(x) { numDeriv::grad(fn, c(x[1], x[2])) } optim(par = c(-1.2, 1), fn = fn, gr = gr, method = &quot;BFGS&quot;) ## $par ## [1] -2.805118 3.131313 ## ## $value ## [1] 2.069971e-27 ## ## $counts ## function gradient ## 42 15 ## ## $convergence ## [1] 0 ## ## $message ## NULL 36.4.2.2 Rosenbrock 函数 香蕉函数 定义如下： \\[f(x,y) = 100 (x_2 -x_1^2)^2 + (1 - x_1)^2\\] fn &lt;- function(x) { (100 * (x[2] - x[1]^2)^2 + (1 - x[1])^2) } df &lt;- expand.grid( x = seq(-2.5, 2.5, length = 101), y = seq(-2.5, 2.5, length = 101) ) df$fnxy = apply(df, 1, fn) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -70, y = 0) ) 图 36.5: 香蕉函数图像 # 梯度函数 gr &lt;- function(x) { numDeriv::grad(fn, c(x[1], x[2])) } optim(par = c(-1.2, 1), fn = fn, gr = gr, method = &quot;BFGS&quot;) ## $par ## [1] 1 1 ## ## $value ## [1] 9.595012e-18 ## ## $counts ## function gradient ## 110 43 ## ## $convergence ## [1] 0 ## ## $message ## NULL op &lt;- OP( objective = F_objective(fn, n = 2L, G = gr), bounds = V_bound(ld = -3, ud = 3, nobj = 2L) ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.lbfgs&quot;, start = c(-1.2, 1)) nlp$objval ## [1] 1.364878e-17 nlp$solution ## [1] 1 1 36.4.2.3 Ackley 函数 Ackley 函数是一个非凸函数，有大量局部极小值点，获取全局极小值点是一个比较有挑战的事。它的 \\(n\\) 维形式如下： \\[f(x) = - a \\mathrm{e}^{-b\\sqrt{\\frac{1}{n}\\sum_{i=1}^{n}x_{i}^{2}}} - \\mathrm{e}^{\\frac{1}{n}\\sum_{i=1}^{n}\\cos(cx_i)} + a + \\mathrm{e}\\] 其中，\\(a = 20, b = 0.2, c = 2\\pi\\)，对 \\(\\forall i = 1,2,\\cdots, n\\)，\\(x_i \\in [-10, 10]\\)，\\(f(x)\\) 在 \\(x^{\\star} = (0,0,\\cdot,0)\\) 取得全局最小值 \\(f(x^{\\star}) = 0\\)，二维图像如图 36.6。 fn &lt;- function(x, a = 20, b = 0.2, c = 2 * pi) { mean1 &lt;- mean(x^2) mean2 &lt;- mean(cos(c * x)) -a * exp(-b * sqrt(mean1)) - exp(mean2) + a + exp(1) } df &lt;- expand.grid( x = seq(-10, 10, length.out = 201), y = seq(-10, 10, length.out = 201) ) df$fnxy = apply(df, 1, fn) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -70, y = 0) ) 图 36.6: 二维 Ackley 函数图像 以 10 维的 Ackley 函数为例，先试一下普通的局部优化算法 — Nelder–Mead 算法，选择初值 \\((2,2,\\cdots,2)\\) ，看下效果，再与全局优化算法比较。 op &lt;- OP( objective = F_objective(fn, n = 10L), bounds = V_bound(ld = -10, ud = 10, nobj = 10L) ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.neldermead&quot;, start = rep(2, 10)) nlp$solution ## [1] 2 2 2 2 2 2 2 2 2 2 nlp$objval ## [1] 6.593599 可以说完全没有优化效果，已经陷入局部极小值。根据nloptr 全局优化算法的介绍，这里采用 directL 算法，因为是全局优化，不用选择初值。 # 调全局优化器 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.directL&quot;) nlp$solution ## [1] 0 0 0 0 0 0 0 0 0 0 nlp$objval ## [1] 4.440892e-16 fn(x = c(2, 2)) ## [1] 6.593599 fn(x = rep(2, 10)) ## [1] 6.593599 36.4.2.4 Radistrigin 函数 这里，还有另外一个例子，Radistrigin 函数也是多摸函数 \\[f(\\mathsf{x})= \\sum_{i=1}^{n}\\big(x_i^2 - 10 \\cos(2\\pi x_i) + 10\\big)\\] fn &lt;- function(x) { sum(x^2 - 10 * cos(2 * pi * x) + 10) } df &lt;- expand.grid( x = seq(-4, 4, length.out = 201), y = seq(-4, 4, length.out = 201) ) df$fnxy = apply(df, 1, fn) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -65, y = 0) ) 图 36.7: Radistrigin 函数 设置 10 维 的优化 op &lt;- OP( objective = F_objective(fn, n = 10L), bounds = V_bound(ld = -50, ud = 50, nobj = 10L) ) 调全局优化器求解非凸优化问题 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.directL&quot;) nlp$solution ## [1] 0 0 0 0 0 0 0 0 0 0 nlp$objval ## [1] 0 36.4.2.5 超级复杂函数 有如下复杂的目标函数 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad \\cos(x_1)\\cos(x_2) - \\sum_{i=1}^{5}\\Big( (-1)^i \\cdot i \\cdot 2 \\cdot \\exp\\big(-500 \\cdot ( (x_1 - i \\cdot 2)^2 + (x_2 - i\\cdot 2)^2 ) \\big) \\Big) \\\\ s.t. \\quad -50 \\leq x_1, x_2 \\leq 50 \\end{array} \\end{equation*}\\] subfun &lt;- function(i, m) { (-1)^i * i * 2 * exp(-500 * ((m[1] - i * 2)^2 + (m[2] - i * 2)^2)) } fn &lt;- function(x) { cos(x[1]) * cos(x[2]) - sum(mapply(FUN = subfun, i = 1:5, MoreArgs = list(m = x))) } 目标函数的图像见图 36.8，搜索区域 \\([-50, 50] \\times [-50, 50]\\) 内几乎没有变化的梯度，给寻优过程带来很大困难。 df &lt;- expand.grid( x = seq(-50, 50, length.out = 101), y = seq(-50, 50, length.out = 101) ) df$fnxy = apply(df, 1, fn) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -65, y = 0) ) 图 36.8: 函数图像 将区域 \\([0, 12] \\times [0, 12]\\) 的图像绘制出来，不难发现，有不少局部陷阱。 df &lt;- expand.grid( x = seq(0, 12, length.out = 201), y = seq(0, 12, length.out = 201) ) df$fnxy = apply(df, 1, fn) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(x[1]), ylab = expression(x[2]), zlab = list(expression(italic(f) ~ group(&quot;(&quot;, list(x[1], x[2]), &quot;)&quot;)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -65, y = 0) ) 图 36.9: 局部放大函数图像 最优解在 \\((7.999982, 7.999982)\\) 取得，目标函数值为 -7.978832。 fn(x = c(7.999982, 7.999982)) ## [1] -7.978832 面对如此复杂的函数，调用全局优化器 op &lt;- OP( objective = F_objective(fn, n = 2L), bounds = V_bound(ld = -50, ud = 50, nobj = 2L) ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.directL&quot;) nlp$solution ## [1] 22.22222 0.00000 nlp$objval ## [1] -0.9734211 实际上，还是陷入局部最优解。 SETS: P/1..5/; Endsets Min=@cos(x1) * @cos(x2) - @Sum(P(j): (-1)^j * j * 2 * @exp(-500 * ((x1 - j * 2)^2 + (x2 - j * 2)^2))); @Bnd(-50, x1, 50); @Bnd(-50, x2, 50); Lingo 18.0 启用全局优化求解器后，在 \\((x_1 = 7.999982, x_2 = 7.999982)\\) 取得最小值 -7.978832。而默认未启用全局优化求解器的情况下，在 \\((x_1 = 18.84956, x_2 = -40.84070)\\) 取得局部极小值 -1.000000。 36.4.3 多元非线性约束优化 R 自带的函数 nlminb() 可求解无约束、箱式约束优化问题，constrOptim() 还可求解线性不等式约束优化，其中包括带线性约束的二次规划。optim() 提供一大类优化算法，且包含随机优化算法—模拟退火算法，可求解无约束、箱式约束优化问题。 36.4.3.1 普通箱式约束 有如下箱式约束优化问题，目标函数和香蕉函数有些相识。 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad (x_1 - 1)^2 + 4\\sum_{i =1}^{n -1}(x_{i+1} -x_i^2)^2 \\\\ s.t. \\quad 2 \\leq x_1,x_2,\\cdots,x_n \\leq 4 \\end{array} \\end{equation*}\\] fn &lt;- function(x) { n &lt;- length(x) sum(c(1, rep(4, n - 1)) * (x - c(1, x[-n])^2)^2) } \\(n\\) 维目标函数是非线性的，给定初值 \\((3, 3, \\cdots, 3)\\)，下面求解 25 维的箱式约束， nlminb(start = rep(3, 25), objective = fn, lower = rep(2, 25), upper = rep(4, 25)) ## $par ## [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093 ## [25] 4.000000 ## ## $objective ## [1] 368.1059 ## ## $convergence ## [1] 0 ## ## $iterations ## [1] 6 ## ## $evaluations ## function gradient ## 10 177 ## ## $message ## [1] &quot;relative convergence (4)&quot; nlminb() 出于历史兼容性的原因尚且存在，最优解的第24个分量没有在可行域的边界上。使用 constrOptim() 函数求解，默认求极小，需将箱式或线性不等式约束写成矩阵形式，即 \\(Ax \\geq b\\) 的形式，参数 ui 是 \\(k \\times n\\) 的约束矩阵 \\(A\\)，ci 是右侧 \\(k\\) 维约束向量 \\(b\\)。以上面的优化问题为例，将箱式约束 \\(2 \\leq x_1,x_2 \\leq 4\\) 转化为矩阵形式，即 \\[ A = \\begin{bmatrix} 1 &amp; 0 \\\\ 0 &amp; 1 \\\\ -1 &amp; 0 \\\\ 0 &amp; -1 \\end{bmatrix}, \\quad b = (2, 2, -4, -4) \\] constrOptim( theta = rep(3, 25), # 初始值 f = fn, # 目标函数 method = &quot;Nelder-Mead&quot;, # 没有提供梯度，则必须用 Nelder-Mead 方法 ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))), ci = c(rep(2, 25), rep(-4, 25)) ) ## $par ## [1] 2.006142 2.002260 2.003971 2.003967 2.004143 2.004255 2.001178 2.002990 ## [9] 2.003883 2.006029 2.017345 2.009236 2.000949 2.007793 2.025831 2.007896 ## [17] 2.004514 2.004381 2.008771 2.015695 2.005803 2.009127 2.017988 2.257782 ## [25] 3.999846 ## ## $value ## [1] 378.4208 ## ## $counts ## function gradient ## 12048 NA ## ## $convergence ## [1] 1 ## ## $message ## NULL ## ## $outer.iterations ## [1] 25 ## ## $barrier.value ## [1] -0.003278963 从求解的结果来看，convergence = 1 意味着迭代次数到达默认的极限 maxit = 500，结合 nlminb() 函数的求解结果来看，实际上还没有收敛。没有提供梯度，则必须用 Nelder-Mead 方法，且增加迭代次数到 1000。 constrOptim( theta = rep(3, 25), # 初始值 f = fn, # 目标函数 method = &quot;Nelder-Mead&quot;, control = list(maxit = 1000), ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))), ci = c(rep(2, 25), rep(-4, 25)) ) ## $par ## [1] 2.000081 2.000142 2.001919 2.000584 2.000007 2.000003 2.001097 2.001600 ## [9] 2.000207 2.000042 2.000250 2.000295 2.000580 2.002165 2.000453 2.000932 ## [17] 2.000456 2.000363 2.000418 2.000474 2.009483 2.001156 2.003173 2.241046 ## [25] 3.990754 ## ## $value ## [1] 370.8601 ## ## $counts ## function gradient ## 18036 NA ## ## $convergence ## [1] 1 ## ## $message ## NULL ## ## $outer.iterations ## [1] 19 ## ## $barrier.value ## [1] -0.003366467 还是没有收敛，可见 Nelder-Mead 方法在这个优化问题上收敛速度比较慢。下面考虑调用基于梯度的优化算法 — BFGS 方法。 # 输入 n 维向量，输出 n 维向量 gr &lt;- function(x) { n &lt;- length(x) c(2 * (x[1] - 2), rep(0, n - 1)) +8 * c(0, x[-1] - x[-n]^2) -16 * c(x[-n], 0) * c(x[-1] - x[-n]^2, 0) } constrOptim( theta = rep(3, 25), # 初始值 f = fn, # 目标函数 grad = gr, method = &quot;BFGS&quot;, control = list(maxit = 1000), ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))), ci = c(rep(2, 25), rep(-4, 25)) ) ## $par ## [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000001 ## [25] 3.000000 ## ## $value ## [1] 373 ## ## $counts ## function gradient ## 3721 464 ## ## $convergence ## [1] 0 ## ## $message ## NULL ## ## $outer.iterations ## [1] 3 ## ## $barrier.value ## [1] -0.003327104 相比于 Nelder-Mead 方法，目标值 373 更大，可见已陷入局部最优解，下面通过 ROI 包，分别调用求解器 L-BFGS 和 directL，发现前者同样陷入局部最优解，而后者可以获得与 nlminb() 函数一致的结果。 # 调用改进的 BFGS 算法 op &lt;- OP( objective = F_objective(fn, n = 25L, G = gr), bounds = V_bound(ld = 2, ud = 4, nobj = 25L) ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.lbfgs&quot;, start = rep(3, 25)) nlp$objval ## [1] 373 nlp$solution ## [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 # 调全局优化算法 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.directL&quot;) nlp$objval ## [1] 368.1059 nlp$solution ## [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093 ## [25] 4.000000 下面再与函数 optim() 提供的 L-BFGS-B 算法比较 optim( par = rep(3, 25), fn = fn, gr = NULL, method = &quot;L-BFGS-B&quot;, lower = rep(2, 25), upper = rep(4, 25) ) ## $par ## [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 ## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093 ## [25] 4.000000 ## ## $value ## [1] 368.1059 ## ## $counts ## function gradient ## 6 6 ## ## $convergence ## [1] 0 ## ## $message ## [1] &quot;CONVERGENCE: REL_REDUCTION_OF_F &lt;= FACTR*EPSMCH&quot; 值得注意的是，当提供梯度信息的时候，虽然求解速度提升了，但是最优解变差了。 optim( par = rep(3, 25), fn = fn, gr = gr, method = &quot;L-BFGS-B&quot;, lower = rep(2, 25), upper = rep(4, 25) ) ## $par ## [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 ## ## $value ## [1] 373 ## ## $counts ## function gradient ## 2 2 ## ## $convergence ## [1] 0 ## ## $message ## [1] &quot;CONVERGENCE: NORM OF PROJECTED GRADIENT &lt;= PGTOL&quot; 36.4.3.2 非线性严格不等式约束 第一个例子，目标函数是非线性的，约束条件也是非线性的，非线性不等式约束不包含等号。 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad (x_1 + 3x_2 + x_3)^2 + 4(x_1 - x_2)^2 \\\\ s.t.\\left\\{ \\begin{array}{l} x_1 + x_2 + x_3 &amp;= 1 \\\\ 6 x_2 + 4 x_3 - x_1^3 &amp;&gt; 3 \\\\ x_1, x_2, x_3 &gt; 0 \\end{array} \\right. \\end{array} \\end{equation*}\\] # 目标函数 fn &lt;- function(x) (x[1] + 3 * x[2] + x[3])^2 + 4 * (x[1] - x[2])^2 # 目标函数的梯度 gr &lt;- function(x) { g &lt;- rep(NA, 3) # 对 x[1] 求偏导 g[1] &lt;- 2 * (x[1] + 3 * x[2] + x[3]) + 8 * (x[1] - x[2]) # 对 x[2] 求偏导 g[2] &lt;- 6 * (x[1] + 3 * x[2] + x[3]) - 8 * (x[1] - x[2]) # 对 x[3] 求偏导 g[3] &lt;- 2 * (x[1] + 3 * x[2] + x[3]) g } # 等式约束 heq &lt;- function(x) { h &lt;- rep(NA, 1) h[1] &lt;- x[1] + x[2] + x[3] - 1 h } # 等式约束的雅可比矩阵 # 这里只有一个等式约束，所以雅可比矩阵行数为 1 heq.jac &lt;- function(x) { j &lt;- matrix(NA, 1, length(x)) j[1, ] &lt;- c(1, 1, 1) j } # 不等式约束 # 要求必须是严格不等式，不能带等号，方向是 x &gt; 0 hin &lt;- function(x) { h &lt;- rep(NA, length(x)) h[1] &lt;- 6 * x[2] + 4 * x[3] - x[1]^3 - 3 h[2] &lt;- x[1] h[3] &lt;- x[2] h[4] &lt;- x[3] h } # 不等式约束的雅可比矩阵 # 其实是有 4 个不等式约束，包括 3 个变量，雅可比矩阵行数是 4 hin.jac &lt;- function(x) { j &lt;- matrix(NA, 4, length(x)) j[1, ] &lt;- c(-3 * x[1]^2, 6, 4) j[2, ] &lt;- c(1, 0, 0) j[3, ] &lt;- c(0, 1, 0) j[4, ] &lt;- c(0, 0, 1) j } 调用 alabama 包的求解器 library(numDeriv) library(alabama) set.seed(12) # 初始值 p0 &lt;- runif(3) # 求目标函数的极小值 ans &lt;- constrOptim.nl( par = p0, # 目标函数 fn = fn, gr = gr, # 等式约束 heq = heq, heq.jac = heq.jac, # 不等式约束 hin = hin, hin.jac = hin.jac, # 不显示迭代过程 control.outer = list(trace = FALSE) ) ans ans 是 constrOptim.nl() 返回的一个 list， convergence = 0 表示迭代成功收敛，value 表示目标函数在迭代终止时的取直，par 表示满足约束条件，成功收敛的情况下，目标函数的参数值，counts 表示迭代过程中目标函数及其梯度计算的次数。 # 不提供梯度函数，照样可以求解 ans &lt;- constrOptim.nl(par = p0, fn = fn, heq = heq, hin = hin) 实际上，可以用 ROI 调用 alabama 的方式，这种方式可以简化目标函数梯度和约束条件的表示 # 目标函数 fn &lt;- function(x) (x[1] + 3 * x[2] + x[3])^2 + 4 * (x[1] - x[2])^2 # 目标函数的梯度 gr &lt;- function(x) { c( 2 * (x[1] + 3 * x[2] + x[3]) + 8 * (x[1] - x[2]), 6 * (x[1] + 3 * x[2] + x[3]) - 8 * (x[1] - x[2]), 2 * (x[1] + 3 * x[2] + x[3]) ) } heq &lt;- function(x) { x[1] + x[2] + x[3] } heq.jac &lt;- function(x) { c(1, 1, 1) } hin &lt;- function(x) { 6 * x[2] + 4 * x[3] - x[1]^3 } hin.jac &lt;- function(x) { c(-3 * x[1]^2, 6, 4) } 通过 ROI 调用 alabama 求解器 set.seed(2020) # 初始值 p0 &lt;- runif(3) # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 3L, G = gr), # 4 个目标变量 constraints = F_constraint( F = list(heq = heq, hin = hin), dir = c(&quot;==&quot;, &quot;&gt;&quot;), rhs = c(1, 3), # 等式和不等式约束的雅可比 J = list(heq.jac = heq.jac, hin.jac = hin.jac) ), bounds = V_bound(ld = 0, ud = +Inf, nobj = 3L), maximum = FALSE # 求最小 ) nlp &lt;- ROI_solve(op, solver = &quot;alabama&quot;, start = p0) nlp$solution ## [1] 1.674812e-06 9.994336e-08 9.999982e-01 nlp$objval ## [1] 1 36.4.3.3 非线性和箱式约束 与上面的例子不同，下面这个例子的不等式约束包含等号，还有箱式约束，优化问题来源于Ipopt 官网，提供的初始值为 \\(x_0 = (1,5,5,1)\\)，最优解为 \\(x_{\\star} = (1.00000000,4.74299963,3.82114998,1.37940829)\\)。优化问题的具体内容如下： \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad x_1 x_4 (x_1 + x_2 + x_3) + x_3 \\\\ s.t.\\left\\{ \\begin{array}{l} x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40 \\\\ x_1 x_2 x_3 x_4 \\geq 25 \\\\ 1 \\leq x_1, x_2, x_3, x_4 \\leq 5 \\end{array} \\right. \\end{array} \\end{equation*}\\] 考虑用 ROI 调 nloptr 实现，看结果是否和例子一致，nloptr 支持不等式约束包含等号，支持箱式约束。 # 一个 4 维的目标函数 fn &lt;- function(x) { x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3] } # 目标函数的梯度 gr &lt;- function(x) { c( x[4] * (2 * x[1] + x[2] + x[3]), x[1] * x[4], x[1] * x[4] + 1, x[1] * (x[1] + x[2] + x[3]) ) } # 等式约束 heq &lt;- function(x) { sum(x^2) } # 等式约束的雅可比 heq.jac &lt;- function(x) { 2 * c(x[1], x[2], x[3], x[4]) } # 不等式约束 hin &lt;- function(x) { prod(x) } # 不等式约束的雅可比 hin.jac &lt;- function(x) { c(prod(x[-1]), prod(x[-2]), prod(x[-3]), prod(x[-4])) } # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 4L, G = gr), # 4 个目标变量 constraints = F_constraint( F = list(heq = heq, hin = hin), dir = c(&quot;==&quot;, &quot;&gt;=&quot;), rhs = c(40, 25), # 等式和不等式约束的雅可比 J = list(heq.jac = heq.jac, hin.jac = hin.jac) ), bounds = V_bound(ld = 1, ud = 5, nobj = 4L), maximum = FALSE # 求最小 ) # 目标函数初始值 fn(c(1, 5, 5, 1)) ## [1] 16 # 目标函数最优值 fn(c(1.00000000, 4.74299963, 3.82114998, 1.37940829)) ## [1] 17.01402 求解一般的非线性约束问题，求解器 nloptr.mma / nloptr.cobyla 仅支持非线性不等式约束，不支持等式约束，而 nlminb 只支持等式约束，因此，下面分别调用 nloptr.auglag、nloptr.slsqp 和 nloptr.isres 来求解上述优化问题。 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.auglag&quot;, start = c(1, 5, 5, 1)) nlp$solution ## [1] 1.000000 4.743025 3.821117 1.379413 nlp$objval ## [1] 17.01402 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.slsqp&quot;, start = c(1, 5, 5, 1)) nlp$solution ## [1] 1.000000 4.742996 3.821155 1.379408 nlp$objval ## [1] 17.01402 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.isres&quot;, start = c(1, 5, 5, 1)) nlp$solution ## [1] 1.005330 4.938265 3.433632 1.677254 nlp$objval ## [1] 19.24545 可以看出，nloptr 提供的优化能力可以覆盖Ipopt 求解器，推荐使用 nloptr.slsqp 求解器。 36.4.3.4 非线性混合整数约束 \\[\\begin{equation*} \\begin{array}{l} \\max_x \\quad 1.5(x_1 - \\sin(x_1 - x_2))^2 + 0.5x_2^2 + x_3^2 - x_1 x_2 - 2x_1 + x_2 x_3 \\\\ s.t.\\left\\{ \\begin{array}{l} -20 &lt; x_1 &lt; 20 \\\\ -20 &lt; x_2 &lt; 20 \\\\ -10 &lt; x_3 &lt; 10 \\\\ x_1, x_2 \\in \\mathbb{R}, \\quad x_3 \\in \\mathbb{Z} \\end{array} \\right. \\end{array} \\end{equation*}\\] fn &lt;- function(x) { 1.5 * (x[1] - sin(x[1] - x[2]))^2 + 0.5 * x[2]^2 + x[3]^2 -x[1] * x[2] - 2 * x[1] + x[2] * x[3] } gr &lt;- function(x) { c( 3 * (x[1] - sin(x[1] - x[2])) * (1 - cos(x[1] - x[2])) - x[2] - 2, 3 * (x[1] - sin(x[1] - x[2])) * cos(x[1] - x[2]) - x[2] - x[1] + x[3], 2 * x[3] + x[2] ) } 目前 ROI 还解不了 # 初始值 p0 &lt;- c(2.1, 5.1, 5) # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 3L, G = gr), # 3 个目标变量 types = c(&quot;C&quot;, &quot;C&quot;, &quot;I&quot;), # 目标变量的类型 bounds = V_bound(lb = c(-20, -20, -10), ub = c(20, 20, 10), nobj = 3L), maximum = FALSE # 求最小 ) nlp &lt;- ROI_solve(op, solver = &quot;auto&quot;, start = p0) nlp$solution 目标函数在 \\((4.49712, 9.147501, -4)\\) 取得最小值 -86.72165 fn(x = c(4.49712, 9.147501, -4)) ## [1] -86.72165 36.4.3.5 含复杂目标函数 下面这个目标函数比较复杂，约束条件也是非线性的 \\[\\begin{equation*} \\begin{array}{l} \\max_x \\quad \\frac{(\\sin(2\\pi x_1))^3 \\sin(2\\pi x_2)}{x_1^3 (x_1 + x_2)} \\\\ s.t.\\left\\{ \\begin{array}{l} x_1^2 - x_2 + 1 \\leq 0 \\\\ 1 - x_1 + (x_2 - 4)^2 \\geq 0 \\\\ 0 \\leq x_1, x_2 \\leq 10 \\end{array} \\right. \\end{array} \\end{equation*}\\] # 目标函数 fn &lt;- function(x) (sin(2*pi*x[1]))^3 * sin(2*pi*x[2])/(x[1]^3*(x[1] + x[2])) # 目标函数的梯度 gr &lt;- function(x) { numDeriv::grad(fn, c(x[1], x[2])) } hin &lt;- function(x) { c( x[1]^2 - x[2] + 1, 1 - x[1] + (x[2] - 4)^2 ) } hin.jac &lt;- function(x) { matrix(c( 2 * x[1], -1, -1, 2 * x[2] ), ncol = 2, byrow = TRUE ) } # 初始值 p0 &lt;- c(2, 5) # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 2L, G = gr), # 2 个目标变量 constraints = F_constraint( F = list(hin = hin), dir = c(&quot;&lt;=&quot;, &quot;&lt;=&quot;), rhs = c(0, 0), # 不等式约束的雅可比 J = list(hin.jac = hin.jac) ), bounds = V_bound(ld = 0, ud = 10, nobj = 2L), maximum = TRUE # 求最大 ) nlp &lt;- ROI_solve(op, solver = &quot;nloptr.isres&quot;, start = p0) nlp$solution ## [1] 1.227972 4.245373 nlp$objval ## [1] 0.09582504 下面再给一个来自 Octave 优化文档 的示例，该优化问题包含多个非线性的等式约束。 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad \\mathrm{e}^{\\prod_{i=1}^{5} x_i} - \\frac{1}{2}(x_1^3 + x_2^3 + 1)^2 \\\\ s.t.\\left\\{ \\begin{array}{l} \\sum_{i=1}^{5}x_i^2 - 10 &amp;= 0 \\\\ x_2 x_3 - 5x_4 x_5 &amp;= 0 \\\\ x_1^3 + x_2^3 + 1 &amp;= 0 \\end{array} \\right. \\end{array} \\end{equation*}\\] # 一个 5 维的目标函数 fn &lt;- function(x) { exp(prod(x)) - 0.5 * (x[1]^3 + x[2]^3 + 1)^2 } # 目标函数的梯度 gr &lt;- function(x) { c( exp(prod(x))*prod(x[-1]) - 3*(x[1]^3 + x[2]^3 + 1)*x[1]^2, exp(prod(x))*prod(x[-2]) - 3*(x[1]^3 + x[2]^3 + 1)*x[2]^2, exp(prod(x))*prod(x[-3]), exp(prod(x))*prod(x[-4]), exp(prod(x))*prod(x[-5]) ) } # 等式约束 heq &lt;- function(x) { c( sum(x^2) - 10, x[2] * x[3] - 5 * x[4] * x[5], x[1]^3 + x[2]^3 + 1 ) } # 等式约束的雅可比 heq.jac &lt;- function(x) { matrix(c(2 * x[1], 2 * x[2], 2 * x[3], 2 * x[4], 2 * x[5], 0, x[3], x[2], -5 * x[5], -5 * x[4], 3 * x[1]^2, 3 * x[2]^2, 0, 0, 0), ncol = 5, byrow = TRUE ) } # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 5L, G = gr), # 5 个目标变量 constraints = F_constraint( F = list(heq = heq), dir = &quot;==&quot;, rhs = 0, # 等式的雅可比 J = list(heq.jac = heq.jac) ), bounds = V_bound(ld = -Inf, ud = Inf, nobj = 5L), maximum = FALSE # 求最小 ) 调用 SQP（序列二次规划） 求解器 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.slsqp&quot;, start = c(-1.8, 1.7, 1.9, -0.8,-0.8)) nlp$solution ## [1] -1.7171435 1.5957096 1.8272458 -0.7636431 -0.7636431 计算结果和 Octave 的示例一致。 36.4.3.6 含复杂约束条件 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\quad \\exp(\\sin(50\\cdot x)) + \\sin(60\\cdot \\exp(y)) + \\sin(70\\cdot\\sin(x)) \\\\ \\qquad + \\sin(\\sin(80\\cdot y)) - \\sin(10\\cdot (x +y)) + \\frac{(x^2 + y^2)^{\\sin(y)}}{4} \\\\ s.t. \\quad \\begin{array}{l} x - \\big((\\cos(y))^x - x\\big)^y = 0 \\\\ -50 \\leq x_1,x_2 \\leq 50 \\end{array} \\end{array} \\end{equation*}\\] Lingo 代码如下： Min = @exp(@sin(50 * x)) + @sin(60 * @exp(y)) + @sin(70 * @sin(x)) + @sin(@sin(80 * y)) - @sin(10 * (x + y)) + (x^2 + y^2)^@sin(y) / 4; x - (( @cos(y) )^x - x)^y = 0; @bnd(-50, x, 50); @bnd(-50, y, 50); 启用全局优化求解器，求解 14 分钟，在 \\((0.08256372, 24.56510)\\) 取得极小值 -2.863497。不启用全局优化器就没法解，Lingo 会报错，找不到最优解，勉强找到一个可行解 \\((0.06082750, 44.12793)\\)，目标值为 -1.29816。 fn &lt;- function(x) { exp(sin(50 * x[1])) + sin(60 * exp(x[2])) + sin(70 * sin(x[1])) + sin(sin(80 * x[2])) - sin(10 * (x[1] + x[2])) + (x[1]^2 + x[2]^2)^(sin(x[2])) / 4 } gr &lt;- function(x){ numDeriv::grad(fn, c(x[1], x[2])) } heq &lt;- function(x){ x[1] - ( (cos(x[2]))^x[1] - x[1] )^x[2] } heq.jac &lt;- function(x){ numDeriv::grad(heq, c(x[1], x[2])) } fn(x = c(0.06082750, 44.12793)) ## [1] -1.29816 fn(x = c(1, 0)) ## [1] 1.966877 heq(x = c(0.06082750, 44.12793)) ## [1] 1.923673e-08 heq(x = c(1, 0)) ## [1] 0 # 定义目标规划 op &lt;- OP( objective = F_objective(F = fn, n = 2L, G = gr), # 2 个目标变量 constraints = F_constraint( F = list(heq = heq), dir = &quot;==&quot;, rhs = 0, J = list(heq.jac = heq.jac) ), bounds = V_bound(ld = -50, ud = 50, nobj = 2L), maximum = FALSE # 求最小 ) nloptr.auglag 无法求解此优化问题 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.auglag&quot;, start = c(1, 0)) nlp$solution 调 nloptr.isres 求解器，每次执行都会得到不同的局部最优解 nlp &lt;- ROI_solve(op, solver = &quot;nloptr.isres&quot;, start = c(1, 0)) nlp$solution ## [1] 8.640377 18.506508 nlp$objval ## [1] -2.78683 比如下面三组 fn(x = c(40.95941, 41.52914)) ## [1] -1.025926 heq(x = c(40.95941, 41.52914)) ## [1] NaN fn(x = c(-21.88091, 28.96994)) ## [1] -1.467513 heq(x = c(-21.88091, 28.96994)) ## [1] NaN fn(x = c(-49.921967437, 4.8499336803)) ## [1] -3.466596 heq(x = c(-49.921967437, 4.8499336803)) ## [1] -8.515447e+208 "],["sec-nonlinear-equations.html", "36.5 非线性方程", " 36.5 非线性方程 36.5.1 一元非线性方程 牛顿-拉弗森方法 library(rootSolve) "],["sec-multi-objective-optimization.html", "36.6 多目标规划", " 36.6 多目标规划 多目标规划的基本想法是将多目标问题转化为单目标问题，常见方法有理想点法、线性加权法、非劣解集法、极大极小法。理想点法是先在给定约束条件下分别求解单个目标的最优值，构造新的单目标函数。线性加权法是给每个目标函数赋予权重系数，各个权重系数之和等于1。非劣解集法是先求解其中一个单目标函数的最优值，然后将其设为等式约束，将其最优值从最小值开始递增，然后求解另一个目标函数的最小值。极大极小法是采用标准的简面体爬山法和通用全局优化法求解多目标优化问题。 R 环境中，GPareto 主要用来求解多目标规划问题。试验设计和过程优化与R语言 的 约束优化 章节，优化和解方程 \\[\\begin{equation*} \\begin{array}{l} \\min_x \\left\\{ \\begin{array}{l} f_1(x) = 0.5x_1 + 0.6x_2 + 0.7 \\exp(\\frac{x_1 + x_3}{10}) \\\\ f_2(x) = (x_1 - 2x_2)^2 + (2x_2 - 3x_3)^2 + (5x_3 -x_1)^2 \\end{array} \\right. \\\\ s.t. \\quad x_1 \\in [10, 80], x_2 \\in [20, 90], x_3 \\in [15, 100] \\end{array} \\end{equation*}\\] library(DiceKriging) library(emoa) library(GPareto) library(DiceDesign) library(Ternary) TernaryPlot( atip = &quot;Top&quot;, btip = &quot;Bottom&quot;, ctip = &quot;Right&quot;, axis.col = &quot;red&quot;, col = rgb(0.8, 0.8, 0.8) ) HorizontalGrid(grid.lines = 2, grid.col = &quot;blue&quot;, grid.lty = 1) "],["sec-classic-optimization.html", "36.7 经典优化问题", " 36.7 经典优化问题 旅行商问题、背包问题、指派问题、选址问题、网络流量问题 规划快递员送餐的路线：从快递员出发地到各个取餐地，再到顾客家里，如何规划路线使得每个顾客下单到拿到餐的时间间隔小于 50 分钟，完成送餐，快递员的总时间最少？ "],["sec-least-squares.html", "36.8 最小二乘", " 36.8 最小二乘 经典的岭回归、Lasso 回归、最优子集回归都包含优化问题，可调 nloptr 包求解。 glmnet 和 MASS 实现岭回归 \\[y = X\\beta + \\epsilon\\] \\(\\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y, \\quad \\hat{Y} = X(X^{\\top}X)^{-1}X^{\\top}y\\) set.seed(123) n &lt;- 200 p &lt;- 50 x &lt;- matrix(rnorm(n * p), n) y &lt;- rnorm(n) lm(y ~ x + 0) # y 的估计 # 教科书版 fit_base = function(x, y) { x %*% solve(t(x) %*% x) %*% t(x) %*% y } # 先向量计算，然后矩阵计算 fit_vector = function(x, y) { x %*% (solve(t(x) %*% x) %*% (t(x) %*% y)) } # X&#39;X 是对称的，防止求逆 fit_inv = function(x, y) { x %*% solve(crossprod(x), crossprod(x, y)) } QR 分解 \\(X_{n\\times p} = Q_{n\\times p} R_{p\\times p}\\)，\\(n &gt; p\\)，\\(Q^{\\top}Q = I\\)，\\(R\\) 是上三角矩阵，\\(\\hat{Y} = X(X^{\\top}X)^{-1}X^{\\top}y = QQ^{\\top}y\\) fit_qr &lt;- function(x, y) { decomp &lt;- qr(x) qr.qy(decomp, qr.qty(decomp, y)) } lm.fit(x, y) 若 \\(A = X^{\\top}X\\) 是正定矩阵，则 \\(A = LL^{\\top}\\)，\\(L\\) 是下三角矩阵 fit_chol &lt;- function(x, y) { decomp &lt;- chol(crossprod(x)) lxy &lt;- backsolve(decomp, crossprod(x, y), transpose = TRUE) b &lt;- backsolve(decomp, lxy) x %*% b } ## Using C/C++ system.time(RcppEigen::fastLmPure(x, y, method = 1)) ## QR system.time(RcppEigen::fastLmPure(x, y, method = 2)) ## Cholesky system.time(RcppArmadillo::fastLmPure(x, y, method = 1)) ## QR system.time(RcppArmadillo::fastLmPure(x, y, method = 2)) ## Cholesky "],["sec-log-likelihood.html", "36.9 对数似然", " 36.9 对数似然 随机变量 X 服从参数为 \\(\\lambda &gt; 0\\) 的指数分布，密度函数 \\(p(x)\\) 为 \\[\\begin{equation*} \\begin{array}{l} p(x) = \\left\\{ \\begin{array}{l} \\lambda\\mathrm{e}^{-\\lambda x}, &amp; x \\geq 0\\\\ 0, &amp; x &lt; 0 \\end{array} \\right. \\end{array} \\end{equation*}\\] 其中，\\(\\lambda &gt; 0\\)，下面给定一系列模拟样本观察值 \\(x_1, x_2, \\cdots, x_n\\)，估计参数 \\(\\lambda\\)。对数似然函数 \\(\\ell(\\lambda) = \\log \\prod_{i=1}^{n} f(x_i) = n \\log \\lambda - \\lambda \\sum_{i=1}^{n}x_i\\)。解此方程即可得到 \\(\\lambda\\) 的极大似然估计 \\(\\lambda_{mle} = \\frac{1}{\\bar{X}}\\)，极大值 \\(\\ell(\\lambda_{mle}) = - n(1 + \\log \\bar{X})\\)。 根据上述样本，计算样本均值 \\((\\mu - 1.5*\\sigma/\\sqrt{n}, \\mu + 1.5*\\sigma/\\sqrt{n})\\) 和方差 \\((0.8\\sigma, 1.5\\sigma)\\)。 已知正态分布 \\(f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{- \\frac{(x - \\mu)^2}{2\\sigma^2}}\\) 的对数似然形式 \\(\\ell(\\mu,\\sigma^2) = \\log \\prod_{i=1}^{n} f(x_i) = \\sum_{i=1}^{n}\\log f(x_i)\\)。正态分布的密度函数的对数可用 dnorm(..., log = TRUE) 计算。 生成服从指数分布的样本，计算样本的均值和方差，依据均值和方差构造区间，然后将区间网格化，在此网格上绘制正态分布的对数似然函数。绕那么大一个圈子，其实就是绘制正态分布的对数似然函数。 set.seed(2021) n &lt;- 20 # 随机数的个数 x &lt;- rexp(n, rate = 5) # 服从指数分布的随机数 m &lt;- 40 # 网格数 mu &lt;- seq( mean(x) - 1.5 * sd(x) / sqrt(n), mean(x) + 1.5 * sd(x) / sqrt(n), length.out = m ) sigma &lt;- seq(0.8 * sd(x), 1.5 * sd(x), length.out = m) df &lt;- expand.grid(x = mu, y = sigma) # 正态分布的对数似然 loglik &lt;- function(b, x0) -sum(dnorm(x0, b[1], b[2], log = TRUE)) df$fnxy = apply(df, 1, loglik, x0 = x) wireframe( data = df, fnxy ~ x * y, shade = TRUE, drape = FALSE, xlab = expression(mu), ylab = expression(sigma), zlab = list(expression(-loglik(mu, sigma)), rot = 90), scales = list(arrows = FALSE, col = &quot;black&quot;), par.settings = list(axis.line = list(col = &quot;transparent&quot;)), screen = list(z = 120, x = -70, y = 0) ) 图 36.10: 正态分布参数的负对数似然函数 "],["sec-non-linear-tseries.html", "36.10 微分方程", " 36.10 微分方程 ode45 求解偏微分方程 pracma 实现了 ode23, ode23s, ode45 等几个自适应的 Runge-Kutta 求解器，deSolve 包求解 ODE（常微分方程）, DAE（微分代数方程）, DDE（延迟微分方程，包含刚性和非刚性方程）和 PDE（偏微分方程），bvpSolve包求解 DAE/ODE 方程的边值问题。 洛伦兹系统是一个常微分方程组，系统参数的默认值为 \\((\\sigma = 10, \\rho = 28, \\beta = 8/3)\\)，初值为 \\((-13, -14, 47)\\)。 \\[\\begin{equation*} \\begin{array}{l} \\frac{\\partial x}{\\partial t} &amp;= \\sigma (y - x) \\\\ \\frac{\\partial y}{\\partial t} &amp;= x(\\rho -z) - y \\\\ \\frac{\\partial x}{\\partial t} &amp;= xy - \\beta z \\end{array} \\end{equation*}\\] library(deSolve) # 参数 pars &lt;- c(a = -8 / 3, b = -10, c = 28) # 初值 state &lt;- c(X = 1, Y = 1, Z = 1) # 时间间隔 times &lt;- seq(0, 100, by = 0.01) # 定义方程组 lorenz_fun &lt;- function(t, state, parameters) { with(as.list(c(state, parameters)), { dX &lt;- a * X + Y * Z dY &lt;- b * (Y - Z) dZ &lt;- -X * Y + c * Y - Z list(c(dX, dY, dZ)) }) } out &lt;- ode( y = state, times = times, func = lorenz_fun, parms = pars ) 调用 scatterplot3d 绘制三维曲线图，如图36.11 所示 library(scatterplot3d) scatterplot3d( x = out[, &quot;X&quot;], y = out[, &quot;Y&quot;], z = out[, &quot;Z&quot;], col.axis = &quot;black&quot;, type = &quot;l&quot;, color = &quot;gray&quot;, xlab = expression(x), ylab = expression(y), zlab = expression(z), col.grid = &quot;gray&quot;, main = &quot;Lorenz&quot; ) 图 36.11: 洛伦兹曲线 "],["sec-numerical-optimization-session.html", "36.11 运行环境", " 36.11 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] scatterplot3d_0.3-41 deSolve_1.28 ## [3] rootSolve_1.8.2.2 quadprog_1.5-8 ## [5] kableExtra_1.3.4 tibble_3.1.2 ## [7] kernlab_0.9-29 lattice_0.20-44 ## [9] ROI.plugin.quadprog_1.0-0 ROI.plugin.lpsolve_1.0-1 ## [11] ROI.plugin.nloptr_1.0-0 ROI.plugin.alabama_1.0-0 ## [13] ROI_1.0-0 lpSolve_5.6.15 ## ## loaded via a namespace (and not attached): ## [1] xfun_0.24 bslib_0.2.5.1 slam_0.1-48 ## [4] colorspace_2.0-2 vctrs_0.3.8 htmltools_0.5.1.1 ## [7] viridisLite_0.4.0 yaml_2.2.1 utf8_1.2.1 ## [10] rlang_0.4.11 jquerylib_0.1.4 nloptr_1.2.2.2 ## [13] pillar_1.6.1 glue_1.4.2 registry_0.5-1 ## [16] lifecycle_1.0.0 stringr_1.4.0 munsell_0.5.0 ## [19] rvest_1.0.0 lpSolveAPI_5.5.2.0-17.7 evaluate_0.14 ## [22] knitr_1.33 fansi_0.5.0 highr_0.9 ## [25] scales_1.1.1 webshot_0.5.2 jsonlite_1.7.2 ## [28] alabama_2015.3-1 systemfonts_1.0.2 digest_0.6.27 ## [31] stringi_1.7.3 bookdown_0.22 numDeriv_2016.8-1.1 ## [34] grid_4.1.0 tools_4.1.0 magrittr_2.0.1 ## [37] sass_0.4.0 crayon_1.4.1 pkgconfig_2.0.3 ## [40] ellipsis_0.3.2 xml2_1.3.2 rmarkdown_2.9 ## [43] svglite_2.0.0 httr_1.4.2 rstudioapi_0.13 ## [46] R6_2.5.0 compiler_4.1.0 "],["chap-linux-command-bash.html", "附录 A 命令行操作", " 附录 A 命令行操作 Bash 文件查找、查看（内容、大小）、移动（重命名）、删除、创建、修改权限 Linux 命令行工具是非常强大的，命令行中的数据科学 https://www.datascienceatthecommandline.com/，Linux 命令行 https://github.com/jaywcjlove/linux-command optparse、docopt 、littler 包提供了很多便捷的命令行工具，sys， fs 在 R 中运行操作系统命令 如表A.1所示，总结了 R 和 Shell 命令的等价表示，下面以 list.files() 和 ls 为例，介绍其等价的内容 表 A.1: R 和 Shell 命令的等价表示47 R Shell 查看文件 list.files() ls 查看目录 list.dirs() dir 目录层次 fs::dir_tree() tree CentOS 系统默认没有安装 tree 软件，需要先安装才能使用此命令 sudo dnf install -y tree↩︎ "],["sec-ls.html", "A.1 查看文件", " A.1 查看文件 ls/mkdir/mv/du 查看文件 ```bash ls -a ``` 列出目录下所有文件 ```bash ls -1 ``` 一行显示一个文件或文件夹 ```bash ls -l ``` 按从 aA-zZ 的顺序列出所有文件以及所属权限 ```bash ls -rl ``` 相比于 `ls -l` 文件是逆序排列 ```bash ls -lh ``` 列出文件或文件夹（不包含子文件夹）的大小 ```bash ls -ld ``` 列出当前目录本身，而不是其所包含的内容 "],["sec-mkdir.html", "A.2 创建文件夹", " A.2 创建文件夹 ```bash mkdir images ``` 创建文件用 `touch` 如 `touch .Rprofile` ```bash # 删除文件夹及子文件夹，递归删除 rm -rf images/ # 删除文件 rm .Rprofile ``` "],["sec-mv.html", "A.3 移动文件", " A.3 移动文件 在当前目录下 ```bash # 移动文件夹 images 下的所有文件到 figures 文件夹下 mv images/* figures/ # images 文件夹移动到 figures 文件夹下 mv images/ figures/ # 移动特定的文件 mv images/*.png figures/ ``` 同一目录下有两个文件 `R-3.5.1.tar.gz` 未下载完整 和 `R-3.5.1.tar.gz.1` 完全下载 ```bash # 删除 R-3.5.1.tar.gz rm R-3.5.1.tar.gz # 重命名 R-3.5.1.tar.gz.1 mv R-3.5.1.tar.gz.1 R-3.5.1.tar.gz ``` "],["sec-du.html", "A.4 查看文件大小", " A.4 查看文件大小 当前目录下各文件夹的大小， `-h` 表示人类（相对于机器来说）可读的方式显示，如 Kb、Mb、Gb，`-d` 表示目录深度 `du --human-readable --max-depth=1 ./` ```bash du -h -d 1 ./ ``` ```bash # 对当前目录下的文件/夹 按大小排序 du -sh * | sort -nr ``` "],["sec-shell.html", "A.5 终端模拟器", " A.5 终端模拟器 oh-my-zsh 是 Z Shell 扩展，开发在 Github 上 https://github.com/ohmyzsh/ohmyzsh。 zsh 相比于 bash， 在语法高亮、自动补全等方面有优势 sudo dnf install -y zsh sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; RStudio 集成的终端支持 Zsh，操作路径 Tools -&gt; Global Options -&gt; Terminal， 见图 A.1 图 A.1: RStudio IDE 集成的 Zsh 终端模拟器 "],["sec-tar.html", "A.6 压缩和解压缩", " A.6 压缩和解压缩 最常见的压缩文件格式有 .tar、.tar.gz、.tar.bz2、.zip 和 .rar，分别对应于 Tar https://www.gnu.org/software/tar/、 Gzip https://www.gzip.org/ 、 Bzip2 https://www.bzip.org/ 、 UnZip/Zip http://www.info-zip.org 和 WinRAR https://www.rarlab.com/。 Tar 提供了基本的打包和解包工具，Gzip 和 Bzip2 在 Tar 打包的基础上提供了压缩功能， UnZip/Zip 是兼容 Windows 原生压缩/解压缩功能的程序，WinRAR 是广泛流行于 Windows 系统的压缩/解压缩收费软件，除了 WinRAR，其它都是免费甚至开源软件。 下面以 .tar.gz 和.tar.bz2 两种格式的压缩文件为例，介绍文件压缩和解压缩的操作，其它文件格式的操作类似48。WinRAR https://www.rarlab.com/ 是收费的压缩和解压缩工具，也支持 Linux 和 macOS 系统，鉴于它是收费软件，这里就不多展开介绍了，详情请见官网。 sudo dnf install -y tar gzip zip unzip # 将目录 ~/tmp 压缩成文件 filename.tar.gz tar -czf **.tar.gz ~/tmp # 将文件 filename.tar.gz 解压到目录 ~/tmp tar -xzf **.tar.gz -C ~/tmp   sudo dnf install -y bzip2 # 将目录 ~/tmp 压缩成文件 filename.tar.bz2 tar -cjf filename.tar.bz2 ~/tmp # 将文件 filename.tar.bz2 解压到目录 ~/tmp tar -xjf filename.tar.bz2 -C ~/tmp 解压不带 tar 的 .gz 文件，比如 tex.eps.gz 解压后变成 tex.eps gzip filename.gz -d ~/tmp zip 格式的文件需要额外安装 zip 和 unzip 两款软件实现压缩和解压缩。↩︎ "],["sec-build-source-code.html", "A.7 从源码安装 R", " A.7 从源码安装 R 从源码编译 R 的需求大概有以下几点： 爱折腾的极客：玩配置，学习 make 相关工具和 Linux 世界的依赖 追求性能：如 LFS 支持 和 Intel MKL 加速 环境限制：CentOS 或者红帽系统，自带的 R 版本比较落后 ./configure --prefix=/opt/R/R-devel \\ --enable-R-shlib --enable-byte-compiled-packages \\ --enable-BLAS-shlib --enable-memory-profiling --with-blas=&quot;-lopenblas&quot; R is now configured for x86_64-pc-linux-gnu Source directory: . Installation directory: /opt/R/R-devel C compiler: gcc -g -O2 Fortran fixed-form compiler: gfortran -fno-optimize-sibling-calls -g -O2 Default C++ compiler: g++ -std=gnu++11 -g -O2 C++14 compiler: g++ -std=gnu++14 -g -O2 C++17 compiler: g++ -std=gnu++17 -g -O2 C++20 compiler: g++ -std=gnu++2a -g -O2 Fortran free-form compiler: gfortran -fno-optimize-sibling-calls -g -O2 Obj-C compiler: Interfaces supported: X11, tcltk External libraries: pcre2, readline, BLAS(OpenBLAS), curl Additional capabilities: PNG, JPEG, TIFF, NLS, cairo, ICU Options enabled: shared R library, shared BLAS, R profiling, memory profiling Capabilities skipped: Options not enabled: Recommended packages: yes 配置好了以后，可以编译安装了 make &amp;&amp; sudo make install flexiblas 支持多种 BLAS 库自由切换 "],["install-softwares.html", "A.8 安装软件", " A.8 安装软件 本书在后续章节中陆续用到新的 R 包，其安装过程不会在正文中呈现，下面以在 CentOS 8 上安装 sf 包为例介绍。首先需要安装一些系统依赖，具体安装哪些依赖参见 sf 包开发站点 https://github.com/r-spatial/sf。 sudo dnf config-manager --set-disabled PowerTools # openblas-devel sudo dnf install -y sqlite-devel gdal-devel \\ proj-devel geos-devel udunits2-devel 然后，在 R 命令行窗口中，执行安装命令： install.packages(&#39;sf&#39;) 至此，安装完成。如遇本地未安装的新 R 包，可从其官方文档中找寻安装方式。如果你完全不知道自己应该安装哪些，考虑把下面的依赖都安装上 sudo dnf install -y \\ # magick ImageMagick-c++-devel \\ # pdftools poppler-cpp-devel \\ # gifski cargo 软件包管理器架构图，各个命令分别担负什么样的功能，每个命令学习的一般路径是什么，而不是详细介绍每个命令、每个参数的使用，只需给出一个命令的完整使用即可，其余给出一个查询命令帮助手册 dnf copr dnf config-manager "],["sec-install-r-pkgs.html", "A.9 安装 R 包", " A.9 安装 R 包 Iñaki Ucar 开发的 cran2copr 项目实现在 Fedora 上安装预编译好的二进制 R 包，项目目的类似 Debian 平台上的 cran2deb devtools 是开发 R 包的常用工具，同时具有很重的依赖，请看 tools::package_dependencies(&#39;devtools&#39;, recursive = TRUE) ## $devtools ## [1] &quot;usethis&quot; &quot;callr&quot; &quot;cli&quot; &quot;desc&quot; &quot;ellipsis&quot; ## [6] &quot;fs&quot; &quot;httr&quot; &quot;lifecycle&quot; &quot;memoise&quot; &quot;pkgbuild&quot; ## [11] &quot;pkgload&quot; &quot;rcmdcheck&quot; &quot;remotes&quot; &quot;rlang&quot; &quot;roxygen2&quot; ## [16] &quot;rstudioapi&quot; &quot;rversions&quot; &quot;sessioninfo&quot; &quot;stats&quot; &quot;testthat&quot; ## [21] &quot;tools&quot; &quot;utils&quot; &quot;withr&quot; &quot;processx&quot; &quot;R6&quot; ## [26] &quot;glue&quot; &quot;crayon&quot; &quot;rprojroot&quot; &quot;methods&quot; &quot;curl&quot; ## [31] &quot;jsonlite&quot; &quot;mime&quot; &quot;openssl&quot; &quot;cachem&quot; &quot;prettyunits&quot; ## [36] &quot;digest&quot; &quot;xopen&quot; &quot;brew&quot; &quot;commonmark&quot; &quot;knitr&quot; ## [41] &quot;purrr&quot; &quot;Rcpp&quot; &quot;stringi&quot; &quot;stringr&quot; &quot;xml2&quot; ## [46] &quot;brio&quot; &quot;evaluate&quot; &quot;magrittr&quot; &quot;praise&quot; &quot;ps&quot; ## [51] &quot;waldo&quot; &quot;clipr&quot; &quot;gert&quot; &quot;gh&quot; &quot;rappdirs&quot; ## [56] &quot;whisker&quot; &quot;yaml&quot; &quot;graphics&quot; &quot;grDevices&quot; &quot;fastmap&quot; ## [61] &quot;askpass&quot; &quot;credentials&quot; &quot;sys&quot; &quot;zip&quot; &quot;gitcreds&quot; ## [66] &quot;ini&quot; &quot;highr&quot; &quot;markdown&quot; &quot;xfun&quot; &quot;diffobj&quot; ## [71] &quot;fansi&quot; &quot;rematch2&quot; &quot;tibble&quot; &quot;pillar&quot; &quot;pkgconfig&quot; ## [76] &quot;vctrs&quot; &quot;utf8&quot; 其中，依赖关系见表 A.2 表 A.2: devtools 的系统依赖 curl git2r openssl Ubuntu libcurl-dev49 libgit2-dev libssl-dev CentOS libcurl-devel libgit2-devel openssl-devel sf 是处理空间数据的常用工具 tools::package_dependencies(&#39;sf&#39;, recursive = TRUE) ## $sf ## [1] &quot;methods&quot; &quot;classInt&quot; &quot;DBI&quot; &quot;graphics&quot; &quot;grDevices&quot; ## [6] &quot;grid&quot; &quot;magrittr&quot; &quot;Rcpp&quot; &quot;s2&quot; &quot;stats&quot; ## [11] &quot;tools&quot; &quot;units&quot; &quot;utils&quot; &quot;e1071&quot; &quot;class&quot; ## [16] &quot;KernSmooth&quot; &quot;wk&quot; &quot;MASS&quot; &quot;proxy&quot; &quot;cpp11&quot; 其主要的系统依赖分别是 GEOS 3.5.1, GDAL 2.2.2, PROJ 4.9.2 sudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable sudo apt-get update sudo apt-get install -y libudunits2-dev libgdal-dev libgeos-dev libproj-dev 这样也同时解决了 udunits2、 rgdal 和 rgeos 等 3个 R 包的系统依赖，其中 udunits2 使用如下命令安装 install.packages(’udunits2’, configure.args = &#39;--with-udunits2-include=/usr/include/udunits2&#39;) 图形设备支持 cairo png jpeg tiff sudo apt-get install -y libcairo2-dev libjpeg-dev libpng-dev libtiff-dev 图像处理 imager 和 magick sudo yum install fftw-devel # CentOS sudo apt-get install libfftw3-dev # Ubuntu 在 Ubuntu 系统上安装最新的 libmagick++-dev 库 sudo add-apt-repository -y ppa:opencpu/imagemagick sudo apt-get update sudo apt-get install -y libmagick++-dev 在 CentOS 系统上 sudo yum install -y ImageMagick-c++-devel 然后安装 R 包 install.packages(c('imager', 'magick')) rgl 是绘制真三维图形的重量级 R 包 sudo apt-get install libcgal-dev libglu1-mesa-dev libx11-dev # Ubuntu sudo yum install mesa-libGLU mesa-libGLU-devel # CentOS 然后安装 R 包 install.packages(&#39;rgl&#39;) 在 Ubuntu 系统上还可以这样安装 sudo add-apt-repository ppa:marutter/rrutter3.5 sudo apt-get update sudo apt-get install r-cran-rgl rJava 是 Java 语言和 R 语言之间实现通信交流的桥梁 sudo apt-get install -y default-jdk sudo R CMD javareconf 然后安装 rJava 包 install.packages(’rJava’) igraph 是网络数据分析的必备 R 包，为了发挥其最大性能，需要安装三个系统依赖 sudo apt-get install -y libgmp-dev libxml2-dev libglpk-dev 然后安装 R 包 install.packages(&#39;igraph&#39;) gpuR 是基于 GPU 进行矩阵计算的扩展包，依赖 RcppEigen 确保安装 OpenCL 和 RViennaCL 或者 安装 Nvidia 驱动和 CUDA，使用 gpuRcuda 和 gputools 扩展包，下面安装指导来自其 Wiki # Install OpenCL headers sudo apt-get install opencl-headers opencv-dev # Install NVIDIA Drivers and CUDA sudo add-apt-repository -y ppa:xorg-edgers/ppa sudo apt-get update sudo apt-get install nvidia-346 nvidia-settings nloptr 是 NLopt 的 R 语言接口，首先安装 NLopt 程序库 sudo apt-get install libnlopt-dev 然后安装 R 包install.packages('nloptr')，nloptr 被 700+ R 包依赖，如 lme4， spaMM， glmmTMB， rstanarm 等。 Rmpfr sudo apt-get install libmpfr-dev install.packages(’Rmpfr’) geojson sudo yum install jq-devel protobuf-devel install.packages(c(&#39;geojson&#39;,&#39;geojsonio&#39;,&#39;jqr&#39;,&#39;protolite&#39;)) lgcp sudo yum install bwidget install.packages(c(&#39;rpanel&#39;,&#39;lgcp&#39;)) ijtiff sudo yum install jbigkit-devel install.packages(&#39;ijtiff&#39;) webshot 包用于截图 sudo apt install phantomjs install.packages(’webshot’) gifski 包合成 GIF 动图 sudo apt-get install cargo install.packages(&#39;gifski&#39;) libcurl-dev 是一个虚包 virtual package，由 libcurl4-openssl-dev 或 libcurl4-nss-dev 或 libcurl4-gnutls-dev 实际提供，选择其中一个安装即可。↩︎ "],["sec-software-manager.html", "A.10 软件包管理器", " A.10 软件包管理器 A.10.1 dnf 清理升级后的 CentOS 8 系统内核 查找系统安装的内核 rpm -qa | sort | grep kernel kernel-4.18.0-147.8.1.el8_1.x86_64 kernel-4.18.0-193.6.3.el8_2.x86_64 kernel-core-4.18.0-147.8.1.el8_1.x86_64 kernel-core-4.18.0-193.6.3.el8_2.x86_64 kernel-headers-4.18.0-193.6.3.el8_2.x86_64 kernel-modules-4.18.0-147.8.1.el8_1.x86_64 kernel-modules-4.18.0-193.6.3.el8_2.x86_64 kernel-tools-4.18.0-193.6.3.el8_2.x86_64 kernel-tools-libs-4.18.0-193.6.3.el8_2.x86_64 仅保留一个版本的内核，其它旧的内核都删除掉 sudo dnf remove $(dnf repoquery --installonly --latest-limit=-1 -q) 模块依赖问题 问题 1: conflicting requests - nothing provides module(perl:5.26) needed by module perl-DBD-MySQL:4.046:8010020191114030811:073fa5fe-0.x86_64 问题 2: conflicting requests - nothing provides module(perl:5.26) needed by module perl-DBI:1.641:8010020191113222731:16b3ab4d-0.x86_64 问题 3: conflicting requests - nothing provides module(perl:5.26) needed by module perl-YAML:1.24:8010020191114031501:a5949e2e-0.x86_64 依赖关系解决。 ======================================================================================================================= 软件包 架构 版本 仓库 大小 ======================================================================================================================= 移除: kernel x86_64 4.18.0-147.8.1.el8_1 @BaseOS 0 kernel-core x86_64 4.18.0-147.8.1.el8_1 @BaseOS 58 M kernel-modules x86_64 4.18.0-147.8.1.el8_1 @BaseOS 20 M 事务概要 ======================================================================================================================= 移除 3 软件包 将会释放空间：78 M 确定吗？[y/N]： y 运行事务检查 事务检查成功。 运行事务测试 事务测试成功。 运行事务 准备中 : 1/1 删除 : kernel-4.18.0-147.8.1.el8_1.x86_64 1/3 运行脚本: kernel-4.18.0-147.8.1.el8_1.x86_64 1/3 删除 : kernel-modules-4.18.0-147.8.1.el8_1.x86_64 2/3 运行脚本: kernel-modules-4.18.0-147.8.1.el8_1.x86_64 2/3 运行脚本: kernel-core-4.18.0-147.8.1.el8_1.x86_64 3/3 删除 : kernel-core-4.18.0-147.8.1.el8_1.x86_64 3/3 运行脚本: kernel-core-4.18.0-147.8.1.el8_1.x86_64 3/3 验证 : kernel-4.18.0-147.8.1.el8_1.x86_64 1/3 验证 : kernel-core-4.18.0-147.8.1.el8_1.x86_64 2/3 验证 : kernel-modules-4.18.0-147.8.1.el8_1.x86_64 3/3 已移除: kernel-4.18.0-147.8.1.el8_1.x86_64 kernel-core-4.18.0-147.8.1.el8_1.x86_64 kernel-modules-4.18.0-147.8.1.el8_1.x86_64 完毕！ 解决上述模块依赖问题的办法 是重置三个 Perl 模块 sudo dnf module reset perl-DBD-MySQL perl-YAML perl-DBI 依赖关系解决。 ======================================================================================================================= 软件包 架构 版本 仓库 大小 ======================================================================================================================= 重置模块: perl-DBD-MySQL perl-DBI perl-YAML 事务概要 ======================================================================================================================= 确定吗？[y/N]： y 完毕！ A.10.2 apt 添加或删除 PPA (Personal Package Archive)，比如在 Ubuntu 20.04 及之前的版本上安装新版 Inkscape sudo add-apt-repository ppa:inkscape.dev/stable sudo add-apt-repository --remove ppa:inkscape.dev/stable sudo apt-get install build-essential # 修复依赖问题 sudo apt update # 更新资源列表 sudo apt-get upgrade # 更新软件包 sudo apt-get autoclean # 删除已卸的软件的备份 sudo apt-get clean # 删除已装或已卸的软件的备份 sudo apt-get autoremove --purge * # 推荐卸载软件的方式 apt-get list --upgradable # 列出可升级的包 找到并删除旧的内核 dpkg --list | grep linux-image sudo apt-get purge linux-image-3.19.0-{18,20,21,25} sudo update-grub2 # 搜索 apt-cache search octave | grep octave # 查询 apt show octave # 安装 sudo apt install octave sudo apt-get install lsb-core lsb_release -a adduser cloud2016 # 添加用户 passwd cloud2016 # 用户密码设为 cloud whereis sudoers # 查找文件位置 chmod -v u+w /etc/sudoers # 给文件 sudoers 添加写权限 vim /etc/sudoers # 添加 cloud2016 管理员权限 chmod -v u-w /etc/sudoers # 收回权限 安装确认 openssh-server 服务 sudo apt install openssh-server sudo /etc/init.d/ssh start ps -aux | grep ssh "],["chap-other-softwares.html", "附录 B 其它软件", " 附录 B 其它软件 I think, therefore I R. — William B. King50 https://ww2.coastal.edu/kingw/statistics/R-tutorials/↩︎ "],["sec-text-editor.html", "B.1 文本编辑器", " B.1 文本编辑器 代码文件也是纯文本，RStudio 集成了编辑器，支持语法高亮。Windows 系统上优秀的代码编辑器有 Notepad++ 非常轻量。Markdown 文本编辑器我们推荐 Typora 编辑器，它是跨平台的，下面以 Ubuntu 环境为例，介绍安装和使用过程： # or run: # sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add - # add Typora&#39;s repository sudo add-apt-repository &#39;deb https://typora.io/linux ./&#39; sudo apt-get update # install typora sudo apt-get install typora 图 B.1: Typora 主题 设置中文环境，并且将主题风格样式配置为 Vue，见图B.1（右），Vue 主题可从 Typora 官网下载 https://theme.typora.io/theme/Vue/。 Atom 编辑器 https://atom.io/ sudo add-apt-repository ppa:webupd8team/atom sudo apt-get update sudo apt-get install atom Code 编辑器微软出品 https://code.visualstudio.com/ Notepad++ 开源的 Windows 平台上的编辑器 https://notepad-plus-plus.org/ VI &amp; VIM 开源的跨平台编辑器 Atom 和 Code 有商业公司支持的开源免费的跨平台的编辑器 VI/VIM 和 Emacs 是跨平台的编辑器 Markdown 编辑器 + blogdown 记笔记 Typora Markdown 编辑器，支持自定义 CSS 样式 "],["sec-code-editor.html", "B.2 代码编辑器", " B.2 代码编辑器 VS Code, Sublime Text 和 Atom "],["sec-rstudio-ide.html", "B.3 集成开发环境", " B.3 集成开发环境 RStudio 公司的愿景，介绍 RStudio 开发环境提供的效率提升工具或功能 B.3.1 RStudio 桌面版 图 B.2: 开源桌面版 RStudio 集成开发环境 # mongolite sudo dnf install -y openssl-devel cyrus-sasl-devel # sodium sudo dnf install -y libsodium-devel # rJava R CMD javareconf # https://github.com/s-u/rJava # shinytest::installDependencies() db &lt;- rstudioapi::getRStudioPackageDependencies() invisible(lapply(db$name, function(pkg) { if (system.file(package = pkg) == &quot;&quot;) { install.packages(pkg) } })) rsthemes 主题 B.3.2 RStudio 服务器版 RStudio Server 开源服务器版可以放在虚拟机里或者容器里，RStudio 桌面版装在服务器上，服务器为 Ubuntu/CentOS/Windows 系统，然后本地是 Windows 系统，可以通过远程桌面连接服务器，使用 RStudio； 图 B.3: 虚拟机里的 RStudio 服务器上启动 Docker ，运行 RStudio 镜像，本地通过桌面浏览器，如谷歌浏览器登陆连接。 图 B.4: 容器里的 RStudio 下载 RStudio IDE 我们从 RStudio 官网下载开源桌面或服务器版本，服务器版本的使用介绍见文档，最常见的就是设置端口 wget https://download2.rstudio.org/rstudio-server-1.1.456-amd64.deb sudo apt-get install gdebi sudo gdebi rstudio-server-1.1.456-amd64.deb 设置端口 在文件 /etc/rstudio/rserver.conf 下，设置 www-port=8181 注意：修改 rserver.conf 文件后需要重启才会生效 sudo rstudio-server stop sudo rstudio-server start 接着获取机器的 IP 地址，如 192.168.141.3 ip addr 1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08:00:27:59:c0:fb brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global dynamic enp0s3 valid_lft 83652sec preferred_lft 83652sec inet6 fe80::a00:27ff:fe59:c0fb/64 scope link valid_lft forever preferred_lft forever 3: enp0s8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 08:00:27:09:33:0d brd ff:ff:ff:ff:ff:ff inet 192.168.141.3/24 brd 192.168.141.255 scope global dynamic enp0s8 valid_lft 547sec preferred_lft 547sec inet6 fe80::a00:27ff:fe09:330d/64 scope link valid_lft forever preferred_lft forever 然后，就可以从本地浏览器登陆 RStudio 服务器版本，如 http://192.168.141.3:8181/ rstudio-server 已经收录在 Fedora 33+ 仓库中了，详情见 https://cran.r-project.org/bin/linux/fedora/ 授权问题 ERROR system error 13 (Permission denied) How to Disable SELinux Temporarily or Permanently B.3.3 Shiny 服务器版 shiny 开源服务器版 B.3.4 Eclipse + StatET Eclipse 配合 StatET 插件 http://www.walware.de/goto/statet 提供R语言的集成开发环境 https://projects.eclipse.org/projects/science.statet 图 B.5: 基于 Eclipse 的 R 集成开发环境 StatET StatET 基于 Eclipse 首次建立索引很慢，估计半小时到一个小时，添加新的 R 包后，每次启动 StatET 也会建立索引缓存，此外，Eclipse 开发环境占用内存比较多，配置 StatET 的过程如下 B.3.5 Emacs + ESS Emacs 配合 ESS 插件 https://ess.r-project.org/ B.3.6 Nvim-R Nvim-R 是一个基于 Vim 的集成开发环境 https://github.com/jalvesaq/Nvim-R "],["sec-version-control.html", "B.4 Git 版本控制", " B.4 Git 版本控制 MacOS 上用 Homebrew 安装 git-delta brew install git-delta 只考虑 Ubuntu 18.04 环境下的三剑客 Git &amp; Github &amp; Gitlab summary(git2r::repository()) ## Local: devel /home/runner/work/masr/masr ## Remote: devel @ origin (https://github.com/XiangyunHuang/masr) ## Head: [6d70571] 2021-06-05: 移除蛋壳股价趋势，蛋壳已碎 ## ## Branches: 1 ## Tags: 0 ## Commits: 5 ## Contributors: 1 ## Stashes: 0 ## Ignored files: 13 ## Untracked files: 74 ## Unstaged files: 0 ## Staged files: 0 ## ## Latest commits: ## [6d70571] 2021-06-05: 移除蛋壳股价趋势，蛋壳已碎 ## [97e638f] 2021-06-05: make book ## [fa24c76] 2021-06-05: update settings ## [72ce1d8] 2021-06-05: add CMDSTAN repo ## [765ea1a] 2021-06-05: upgrade to R 4.1.0 仓库 masr 哪些人给我点赞加星了 library(gh) my_repos &lt;- gh(&quot;GET /repos/:owner/:repo/stargazers&quot;, owner = &quot;xiangyunhuang&quot;, repo = &quot;masr&quot;, page = 1) vapply(my_repos, &quot;[[&quot;, &quot;&quot;, &quot;login&quot;) [1] &quot;dddd1007&quot; &quot;boltomli&quot; &quot;JackieMium&quot; &quot;AXGL&quot; &quot;fyemath&quot; [6] &quot;rogerclarkgc&quot; &quot;swsoyee&quot; &quot;joegaotao&quot; &quot;YTLogos&quot; &quot;Accelerator086&quot; [11] &quot;yimingfish&quot; &quot;gaospecial&quot; &quot;shenxiangzhuang&quot; &quot;shuaiwang88&quot; &quot;LusiXie&quot; [16] &quot;llxlr&quot; &quot;TingjieGuo&quot; &quot;oiatz&quot; &quot;XiaogangHe&quot; &quot;xwydq&quot; [21] &quot;guohongwang1&quot; &quot;yinandong&quot; &quot;algony-tony&quot; &quot;XiangyunHuang&quot; &quot;perlatex&quot; [26] &quot;talegari&quot; &quot;hao-shefer&quot; &quot;zhouyisu&quot; &quot;tsitong&quot; &quot;liuyadong&quot; 图 B.6: Git 代码版本管理 Jeroen Ooms 开发的 gert 包实现在 R 环境中操作 Git，我们可以从幻灯片 — Gert: A minimal git client for R 学习重点内容。 library(gert) Linking to libgit2 v1.0.0, ssh support: YES, https support: YES Default user: Xiangyun Huang &lt;xiangyunfaith@outlook.com&gt; library(magrittr) git_log(max = 10) %&gt;% subset(grepl(&quot;Yihui Xie&quot;, x = author), select = c(&quot;author&quot;, &quot;message&quot;)) 提供了 git_rm()、 git_status()、 git_add() 和 git_commit() 等函数，其中包含 git_reset() 高级的 Git 操作。此外， 还有 git_branch_*() 系列分支操作函数 B.4.1 安装配置 Ubuntu 16.04.5 默认安装的 Git 版本是 2.7.4，下面安装最新版本Git和配置自己的GitHub账户 根据官网安装指导 https://git-scm.com/download/linux，在 Ubuntu 14.04.5 和 Ubuntu 16.04.5 安装最新版 GIT sudo add-apt-repository -y ppa:git-core/ppa sudo apt update &amp;&amp; sudo apt install git 配置账户 git config --global user.name &quot;你的名字&quot; git config --global user.email &quot;你的邮件地址&quot; touch .git-credentials # 记住密码 echo &quot;https://username:password@github.com&quot; &gt;&gt; .git-credentials git config --global credential.helper store 以 Fedora 为例 安装 tig，首先安装必要的依赖，然后从官网下载源码，编译安装，之后切到任意本地 Git 仓库下，输入 tig 就可以看到如图 B.7 所示的样子了 sudo yum install readline-devel ncurses-devel asciidoc docbook-utils xmlto tig 主要用于查看 git 提交的历史日志 图 B.7: Git 日志查看器 B.4.2 追踪文件 git add . 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件 git add -u 提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)，git add --update的缩写 git add -A 提交所有变化，git add --all 的缩写 git init git remote add origin https://github.com/XiangyunHuang/masr.git git add -A git commit -m &quot;添加提交说明&quot; git push -u origin master 往远程的空的 Github 仓库添加本地文件 B.4.3 合并上流 git clone --depth=5 https://github.com/XiangyunHuang/cosx.org.git git submodule update --init --recursive 查看远程分支 cd cosx.org git remote -v origin https://github.com/XiangyunHuang/cosx.org.git (fetch) origin https://github.com/XiangyunHuang/cosx.org.git (push) # 添加上流分支 git remote add upstream https://github.com/cosname/cosx.org.git # 查看远程分支 git remote -v origin https://github.com/XiangyunHuang/cosx.org.git (fetch) origin https://github.com/XiangyunHuang/cosx.org.git (push) upstream https://github.com/cosname/cosx.org.git (fetch) upstream https://github.com/cosname/cosx.org.git (push) # 获取上流 commit 并且合并到我的 master 分支 git fetch upstream git merge upstream/master master git push origin master B.4.4 大文件支持 sudo apt install git-lfs git lfs install git lfs track &quot;*.psd&quot; git add .gitattributes git commit -m &quot;track *.psd files using Git LFS&quot; git push origin master 这玩意迟早需要你购买存储空间，慎用 B.4.5 新建分支 git checkout -b stan # 新建 stan 分支 git branch -v # 查看本地分支 stan 前有个星号标记 git pull --rebase git@github.com:XiangyunHuang/cosx.org.git master # 同步到远程分支 stan git push --set-upstream origin stan git push origin master:stan git add . git commit -m &quot;balabala&quot; git push --set-upstream origin stan 本地新建仓库推送至远程分支 git remote add origin https://github.com/XiangyunHuang/notesdown.git git add . git commit -m &quot;init cos-art&quot; # 此时远程仓库 notesdown 还没有 cos-art 分支 git push origin master:cos-art 位于 Github Git Community Book 中译本 B.4.6 创建 Github Pages 站点 基于 GitHub Pages 创建站点用于存放图片和数据 在Github上创建一个空的仓库，命名为 uploads，没有 readme.md 和 LICENSE 在本地创建目录 uploads 切换到 uploads 目录下 git init git checkout -b gh-pages git remote add origin https://github.com/XiangyunHuang/uploads.git 添加图片或者数据，并且 git add 和 commit 后 git push --set-upstream origin gh-pages 这样仓库 uploads 只包含 gh-pages 分支，数据地址即为以日期为分割线 https://xiangyunhuang.github.io/uploads/data/eqList2018_05_18.xls B.4.7 博客主题 初始化博客网站 git subtree add --squash --prefix=themes/hugo-lithium \\ git@github.com:yihui/hugo-lithium.git master 在 Github 创建新的空仓库，本地创建空的目录 xiangyun cd xiangyun git init git remote add origin https://github.com/XiangyunHuang/xiangyun.git git add .gitignore git commit -m &#39;upload&#39; git push --set-upstream origin master git subtree 将另外一个仓库收缩为当前仓库的一个目录，且只产生一条提交记录 # 子库分支 git subtree add --squash --prefix=themes/hugo-xmag \\ -m &quot;add hugo-xmag&quot; git@github.com:yihui/hugo-xmag.git master # 或者子库分支 git subtree add --squash --prefix=themes/hugo-xmag \\ -m &quot;add hugo-xmag&quot; https://github.com/yihui/hugo-xmag.git master # 移除 git subtree 添加的 hugo 主题 git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch -rf themes/hugo-xmag&#39; --prune-empty -f HEAD B.4.8 修改远程仓库的位置 有时候我们将自己的仓库转移给别人/组织，或者我们将远程仓库的名字改变了，这时候需要修改远程仓库的位置。比如最近我将博客仓库从 https://github.com/XiangyunHuang/xiangyun 转移到 https://github.com/rbind/xiangyun 转移前 git remote -v origin https://github.com/XiangyunHuang/xiangyun.git (fetch) origin https://github.com/XiangyunHuang/xiangyun.git (push) 转移命令 git remote set-url origin https://github.com/rbind/xiangyun.git 转移后 git remote -v origin https://github.com/rbind/xiangyun.git (fetch) origin https://github.com/rbind/xiangyun.git (push) B.4.9 统计代码仓库的提交量 比如统计之都的主站仓库，提交量最大的20个人 git shortlog -sn | head -n 20 153 Dawei Lang 106 Yihui Xie 89 Beilei Bian 46 王佳 42 雷博文 39 Ryan Feng Lin 35 Xiangyun Huang 32 fanchao 32 闫晗 30 Lin Feng 28 Jiaao Yu 25 fyears 24 Yixuan Qiu 24 Miao YU 22 Yuxuan Li 22 qinwf 20 Alice敏 19 yanshi 18 Shuyi.Yang 13 黄湘云 B.4.10 账户共存 本节介绍如何使 Gitlab/Github 账户共存在一台机器上 如何生成 SSH 密钥见 Github 文档 — 使用 SSH 连接到 GitHub。有了密钥之后只需在目录 ~/.ssh 下创建一个配置文件 config 生成 SSH Key ssh-keygen -t rsa -f ~/.ssh/id_rsa_github -C &quot;name1@xxx1.com&quot; ssh-keygen -t rsa -f ~/.ssh/id_rsa_gitlab -C &quot;name2@xxx2.com&quot; 将 GitHub/GitLab 公钥分别上传至服务器，然后创建配置文件 touch ~/.ssh/config 配置文件内容如下 # # Github # Host github.com // 个人的代码仓库服务器地址 HostName github.com User XiangyunHuang IdentityFile ~/.ssh/id_rsa_github # # company # Host xx.xx.xx.xx // IdentityFile ~/.ssh/id_rsa_gitlab 配置成功，你会看到 ssh -T git@xx.xx.xx.xx Welcome to GitLab, xiangyunhuang! 和 ssh -T git@github.com Hi XiangyunHuang! You&#39;ve successfully authenticated, but GitHub does not provide shell access. B.4.11 回车换行 CR (Carriage Return) 表示回车，LF (Line Feed) 表示换行，Windows 下用回车加换行表示下一行，UNIX/Linux 采用换行符 (LF) 表示下一行，MAC OS 则采用回车符 (CR) 表示下一行 git config --global core.autocrlf false B.4.12 子模块 添加子模块到目录 templates/ 下 git submodule add git://github.com/jgm/pandoc-templates.git templates 移除子模块 https://stackoverflow.com/questions/1260748/how-do-i-remove-a-submodule/ B.4.13 克隆项目 git clone --depth=10 --branch=master --recursive \\ git@github.com:XiangyunHuang/pandoc4everything.git B.4.14 创建 PR git pull --rebase git@github.com:yihui/xaringan.git master # then force push to your master branch 参考 https://github.com/yihui/xaringan/pull/107 I don’t recommend you to use your master branch for pull requests, because all commits will be squashed before merging, e.g. c2c2055 Then you will have some trouble with syncing your master branch with the master branch here (your choices are (1) delete your repo and fork again; or (2) force push; either option is not good). For pull requests, I recommend that you always use different branches for different pull requests. B.4.15 修改 PR 之前一直有一个思想在阻止自己，就是别人的 repo 我是不能修改的，但是在这里，我拥有修改原始仓的权限，那么别人的复制品衍生的分支，我也有修改权限 git fetch origin refs/pull/771/head:patch-2 # 771 是 PR 对应的编号 git checkout patch-2 # 你的修改 git add -u git commit -m &quot;描述你的修改&quot; git remote add LalZzy https://github.com/LalZzy/cosx.org.git git push --set-upstream LalZzy patch-2 整理自统计之都论坛的讨论 https://d.cosx.org/d/420363 GitHub/Git 小抄英文版 https://www.runoob.com/manual/github-git-cheat-sheet.pdf GitHub/Git 小抄中文版 https://github.github.com/training-kit/downloads/zh_CN/github-git-cheat-sheet/ Github 秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md Git 简明指南 https://rogerdudler.github.io/git-guide/index.zh.html Git 奇技淫巧 https://github.com/521xueweihan/git-tips Git 官方书籍 https://git-scm.com/book/zh/v2 Git 时代的 VIM 不完全使用教程 http://beiyuu.com/git-vim-tutorial 最佳搭档：利用 SSH 及其配置文件节省你的生命 https://liam.page/2017/09/12/rescue-your-life-with-SSH-config-file/ "],["sec-pandoc.html", "B.5 Pandoc 文档处理", " B.5 Pandoc 文档处理 Pandoc 是一个万能文档转化器，安装 pandoc，下载网址 https://github.com/jgm/pandoc/releases/latest sudo apt-get install gdebi-core wget https://github.com/jgm/pandoc/releases/download/2.9.2/pandoc-2.9.2-1-amd64.deb sudo chmod +x pandoc-2.9.2-1-amd64.deb sudo gdebi pandoc-2.9.2-1-amd64.deb rmarkdown 包裹了 Pandoc 工具，使用 rmarkdown::render() 函数即可将 R Markdown 文档转化为 HTML、LaTeX 和 Markdown 等格式。 "],["sec-calibre.html", "B.6 Calibre 书籍管理", " B.6 Calibre 书籍管理 Calibre 是一款电子书转化和管理软件，首先安装 calibre sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin calibre 可以将 epub 格式电子书文档转化为 mobi 格式，bookdown 已经给这个工具穿上了一件马甲，用户只需调用 bookdown::calibre() 函数即可实现电子书格式的转换。 "],["sec-ImageMagick.html", "B.7 ImageMagick 图像处理", " B.7 ImageMagick 图像处理 图像的各种操作，包括合成、转换、旋转等等 首先安装 ImageMagick 软件包中的 convert 程序 asy -f jpg test.asy 指定分辨率 convert -geometry 1000x3000 -density 300 -units PixelsPerInch example.eps example.png 这样不改变图像的像素数，只是给出一个每个像素应该显示多大的提示。 convert -quality 100 -density 300x300 filename.pdf filename.png 高质量大图，给定像素，转化 eps 格式图片，需要先安装 Ghostscript convert -geometry 1000x3000 example.eps example.png 多页的 PDF 文件转化为多张 PNG 图片 convert -quality 100 -density 300x300 input.pdf output.png 将多页 PDF 文件合成为 GIF 动图 convert -delay 60 -density 300x300 -background white -alpha remove \\ -dispose previous pdf-mobile.pdf -layers coalesce pdf-mobile.gif "],["sec-optipng.html", "B.8 OptiPNG 图片优化", " B.8 OptiPNG 图片优化 OptiPNG 是一个非常好的图片压缩、优化工具 现在，我们设置 chunk 选项 optipng 为非空(non-NULL)的值，例如，'' 去激活这个 hook （益辉称之为钩子，这里勾的是 optipng 这个图片优化工具） knitr::knit_hooks$set(optipng = knitr::hook_optipng) library(ggplot2) ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() 图 B.8: 没有优化 library(ggplot2) ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) + geom_point() 图 B.9: 优化 optipng -o5 filename.png "],["sec-pdfcrop.html", "B.9 PDFCrop 裁剪边空", " B.9 PDFCrop 裁剪边空 PDFCrop 可将 PDF 图片中留白的部分裁去，再也不用纠结 par 了 "],["sec-phantomjs.html", "B.10 PhantomJS 网页截图", " B.10 PhantomJS 网页截图 Winston Chang 开发了 webshot 包网页截图，它依赖 PhantomJS，所以首先需要安装 install.packages(&quot;webshot&quot;) webshot::install_phantomjs() 以截取网页 https://www.r-project.org/ 为例， library(webshot) webshot(&quot;https://www.r-project.org/&quot;, &quot;r.png&quot;) webshot(&quot;https://www.r-project.org/&quot;, &quot;r.pdf&quot;) # Can also output to PDF 还可以截取 R Markdown 文档内容，注意是先编译 R Markdown 文档为 HTML 文档，然后截取网页 rmdshot(system.file(&quot;examples/knitr-minimal.Rmd&quot;, package = &quot;knitr&quot;), file = &quot;screenshots/knitr-minimal.png&quot;) 裁剪出特定大小的图片，需要额外的系统依赖 GraphicsMagick (recommended) or ImageMagick installed # Can specify pixel dimensions for resize() webshot(&quot;https://www.r-project.org/&quot;, &quot;r-small.png&quot;) %&gt;% resize(&quot;400x&quot;) %&gt;% shrink() ** Processing: r-small.png 400x442 pixels, 4x8 bits/pixel, RGB+alpha Reducing image to 3x8 bits/pixel, RGB Input IDAT size = 70570 bytes Input file size = 70867 bytes Trying: zc = 9 zm = 8 zs = 0 f = 0 IDAT size = 59441 zc = 9 zm = 8 zs = 1 f = 0 zc = 1 zm = 8 zs = 2 f = 0 zc = 9 zm = 8 zs = 3 f = 0 zc = 9 zm = 8 zs = 0 f = 5 zc = 9 zm = 8 zs = 1 f = 5 zc = 1 zm = 8 zs = 2 f = 5 zc = 9 zm = 8 zs = 3 f = 5 Selecting parameters: zc = 9 zm = 8 zs = 0 f = 0 IDAT size = 59441 Output IDAT size = 59441 bytes (11129 bytes decrease) Output file size = 59714 bytes (11153 bytes = 15.74% decrease) "],["sec-inkscape.html", "B.11 Inkscape 矢量绘图", " B.11 Inkscape 矢量绘图 Inkscape 是一款开源、免费、跨平台的矢量绘图软件。是替代 Adobe Illustrator（简称 AI） 最佳工具，没有之一 # Ubuntu 20.04 及之前版本 sudo add-apt-repository ppa:inkscape.dev/stable sudo apt update sudo apt install inkscape PDF 图片格式转化为 SVG 格式 inkscape -l output-filename.svg input-filename.pdf SVG 转 PDF 格式 inkscape -f input-filename.svg -A output-filename.pdf Jeroen Ooms 开发的 rsvg 包支持将 SVG 格式图片导出为 PNG、PDF、PS 等格式。使用它可以批量将 SVG 格式文件转化为其它格式文件，比如 PDF（rsvg::rsvg_pdf），PS （rsvg::rsvg_ps）和 PNG（rsvg::rsvg_png） svg_paths = list.files(path = &quot;images&quot;, pattern = &quot;*.svg&quot;, full.names = T) for (svg in svg_paths) { rsvg::rsvg_pdf(svg, file = gsub(pattern = &quot;\\\\.svg&quot;, replacement= &quot;\\\\.pdf&quot;, svg)) } "],["sec-qpdf.html", "B.12 QPDF PDF 文件操作", " B.12 QPDF PDF 文件操作 Jeroen Ooms 开发的另一个 qpdf 包将 C++ 库 qpdf 搬运到 R 环境中，用于 PDF 文件的拆分 pdf_split()，组合 pdf_combine()，加密（ 传递 password 参数值即可加密），提取 pdf_subset() 和压缩 pdf_compress() 等。下面以组合为例，就是将多个 PDF 文件合成一个 PDF 文件。 library(qpdf) pdf_paths = list.files(path = &quot;images&quot;, pattern = &quot;*.pdf&quot;, full.names = T) pdf_combine(input = pdf_paths, output = &quot;images/all.pdf&quot;, password = &quot;&quot;) PDF 操作：价值数百美元的开源替代方案，参考 Adobe Acrobat 的功能 "],["sec-nomnoml.html", "B.13 UML 标准建模图", " B.13 UML 标准建模图 UML (Unified Modeling Language) 表示统一建模语言 图 B.10: 图片制作、合成、优化、转换等常用工具 Javier Luraschi 将 UML 绘图库 nomnoml 引入 R 社区，开发了 nomnoml 包，相比于 DiagrammeR 包，它显得非常轻量，网站 https://www.nomnoml.com/ 还可以在线编辑、预览、下载 UML 图。 webshot 包可以将网页截图并插入 PDF 文档中。其它制作图形的工具见 B.10。 nomnoml 调 webshot 包对网页截图生成 PNG 格式的图片，其中 webshot 调 phantomjs 软件。 nomnoml 制作 R Markdown 生态图，导出为 PNG 格式 nomnoml::nomnoml(&quot; #stroke: #34A853 #fill: white #fillArrows: false #direction: down [knitr] -&gt; [动态文档|rmarkdown] [Pandoc] -&gt; [动态文档|rmarkdown] [Markdown] -&gt; [动态文档|rmarkdown] [动态文档] -&gt; [书籍笔记|bookdown] [动态文档] -&gt; [静态网站|blogdown] [动态文档] -&gt; [幻灯片|xaringan] [幻灯片] -&gt; [PowerPoint|officedown] [书籍笔记] -&gt; [毕业论文|thesisdown] [静态网站] -&gt; [个人简历|pagedown] [动态文档] -&gt; [数据面板|flexdashboard] [数据面板] --&gt; [交互图形|plotly] &quot;, png = &#39;rmarkdown-ecology.png&#39;) "],["sec-graphviz.html", "B.14 Graphviz 流程图", " B.14 Graphviz 流程图 Graphviz 官网 http://www.graphviz.org/，常用于绘制流程图，广泛用于 tensorflow 和 mxnet 的模型描述中 图 B.11: 数据分析流程图 DiagrammeR 包将 Graphviz 引入 R 语言 library(DiagrammeR) library(DiagrammeRsvg) library(magrittr) library(rsvg) graph &lt;- &quot;graph { rankdir=LR; // Left to Right, instead of Top to Bottom a -- { b c d }; b -- { c e }; c -- { e f }; d -- { f g }; e -- h; f -- { h i j g }; g -- k; h -- { o l }; i -- { l m j }; j -- { m n k }; k -- { n r }; l -- { o m }; m -- { o p n }; n -- { q r }; o -- { s p }; p -- { s t q }; q -- { t r }; r -- t; s -- z; t -- z; } &quot; # 导出图形 grViz(graph) %&gt;% export_svg %&gt;% charToRaw %&gt;% rsvg_pdf(&quot;graph.pdf&quot;) grViz(graph) %&gt;% export_svg %&gt;% charToRaw %&gt;% rsvg_png(&quot;graph.png&quot;) grViz(graph) %&gt;% export_svg %&gt;% charToRaw %&gt;% rsvg_svg(&quot;graph.svg&quot;) "],["sec-latex.html", "B.15 LaTeX 排版工具", " B.15 LaTeX 排版工具 另外值得一提的是 TikZ 和 PGF（Portable Graphic Format）宏包，支持强大的绘图功能，图形质量达到出版级别，详细的使用说明见宏包手册 https://pgf-tikz.github.io/pgf/pgfmanual.pdf。 B.15.1 TinyTeX 发行版 library(tinytex) # 升级 TinyTeX 发行版 upgrade_tinytex &lt;- function(repos = NULL) { # 此处还要考虑用户输错的情况和选择离用户最近（快）的站点 if(is.null(repos)) repos = &quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/&quot; file_ext &lt;- if (.Platform$OS.type == &quot;windows&quot;) &quot;.exe&quot; else &quot;.sh&quot; tlmgr_url &lt;- paste(repos, &quot;/systems/texlive/tlnet/update-tlmgr-latest&quot;, file_ext, sep = &quot;&quot;) file_name &lt;- paste0(&quot;update-tlmgr-latest&quot;, file_ext) download.file(url = tlmgr_url, destfile = file_name, mode = if (.Platform$OS.type == &quot;windows&quot;) &quot;wb&quot; else &quot;w&quot;) # window下 命令行窗口下 如何执行 exe 文件 if(.Platform$OS.type == &quot;windows&quot;){ shell.exec(file = file_name) file.remove(&quot;update-tlmgr-latest.exe&quot;) } else{ system(&quot;sudo sh update-tlmgr-latest.sh -- --upgrade&quot;) file.remove(&quot;update-tlmgr-latest.sh&quot;) } # 类似地 Linux 下执行 sh # 升级完了 删除 update-tlmgr-latest.exe } Winston Chang 整理了一份 LaTeX 常用命令速查小抄 https://wch.github.io/latexsheet/latexsheet.pdf B.15.2 安装和更新 tlmgr (TeXLive Manager) 是 LaTeX 包管理器 # 就近选择 CTAN 镜像站点 tlmgr option repository https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet tlmgr option repository http://mirror.ctan.org/systems/texlive/tlnet # 可更新的 TeX 包列表 tlmgr update --list # 更新所有已经安装的 TeX 包 tlmgr update --all # 更新 tlmgr 管理器本身 tlmgr update --self # 安装 tlmgr install ctex fandol # 列出套装 tlmgr list schemes tlmgr list collections # 列出已经安装的 TeX 包 tlmgr list --only-installed # 安装 GPG 公钥（只限Win/Mac） tlmgr --repository http://www.preining.info/tlgpg/ install tlgpg B.15.3 查询和搜索 tlmgr search *what* 参数 \\*what\\* 是正则表达式 tlmgr search --file tikz.sty ## langsci: ## texmf-dist/tex/xelatex/langsci/langsci-tikz.sty ## pgf: ## texmf-dist/tex/latex/pgf/frontendlayer/tikz.sty 等价于 tinytex::tlmgr_search(&#39;tikz.sty&#39;) 这样，我们就可以知道要使用 \\usepackage{tikz} 就得先安装 pgf 包，此外，管道命令也是支持的 tlmgr search --file font | grep math 查询 CTAN 仓库列表 tlmgr repository list 一般地， 只显示已安装的 LaTeX 宏包的名字及大小 tlmgr info --list --only-installed --data name,size 更多命令详见tlmgr 管理器手册 B.15.4 TikZ 绘图工具 TikZ 绘制书籍封面 https://latexdraw.com/how-to-create-a-beautiful-cover-page-in-latex-using-tikz/ TikZ 绘制知识清单，书籍章节结构等 https://www.latexstudio.net/index/lists/barsearch/author/1680.html 更多例子参考 https://github.com/FriendlyUser/LatexDiagrams "],["sec-octave.html", "B.16 Octave 科学计算", " B.16 Octave 科学计算 %% fig1 tx = ty = linspace (-8, 8, 41)&#39;; [xx, yy] = meshgrid (tx, ty); r = sqrt (xx .^ 2 + yy .^ 2) + eps; tz = sin (r) ./ r; mesh (tx, ty, tz); xlabel (&quot;tx&quot;); ylabel (&quot;ty&quot;); zlabel (&quot;tz&quot;); title (&quot;3-D Sombrero plot&quot;); % fig2 x = 0:0.01:3; hf = figure (); plot (x, erf (x)); hold on; plot (x, x, &quot;r&quot;); axis ([0, 3, 0, 1]); text (0.65, 0.6175, [&#39;$\\displaystyle\\leftarrow x = {2\\over\\sqrt{\\pi}}&#39;... &#39;\\int_{0}^{x}e^{-t^2} dt = 0.6175$&#39;]); xlabel (&quot;x&quot;); ylabel (&quot;erf (x)&quot;); title (&quot;erf (x) with text annotation&quot;); set (hf, &quot;visible&quot;, &quot;off&quot;); print (hf, &quot;plot15_7.pdf&quot;, &quot;-dpdflatexstandalone&quot;); set (hf, &quot;visible&quot;, &quot;on&quot;); system (&quot;pdflatex plot15_7&quot;); open (&quot;plot15_7.pdf&quot;); %% fig3 clf (); surf (peaks); peaks(50) print -dpswrite -PPS_printer %% images/peaks-inc hf = figure (1); surf (peaks); print (hf, &quot;peaks.pdf&quot;, &quot;-dpdflatexstandalone&quot;); %% windows hf = figure (1); peaks(10); print (hf, &quot;peaks.pdf&quot;, &quot;-dpdf&quot;); print (hf, &quot;peaks.eps&quot;, &quot;-color&quot;,&quot; -deps&quot;); print (hf, &quot;peaks.svg&quot;, &quot;-color&quot;,&quot; -dsvg&quot;); %% windows hf = figure (1); peaks(50); print (hf, &quot;peaks-more.eps&quot;, &quot;-color&quot;,&quot; -deps&quot;); print (hf, &quot;peaks-more.svg&quot;, &quot;-color&quot;,&quot; -dsvg&quot;); "],["sec-setup-python.html", "B.17 Python 环境配置", " B.17 Python 环境配置 首先创建一个 Python 虚拟环境，环境隔离可以减少对系统的侵入，方便迭代更新和项目管理。创建一个虚拟环境，步骤非常简单，下面以 CentOS 8 为例： 安装虚拟模块 virtualenv sudo dnf install -y virtualenv 准备 Python 虚拟环境存放位置 sudo mkdir -p /opt/.virtualenvs/r-tensorflow 给虚拟环境必要的访问权限 sudo chown -R $(whoami):$(whoami) /opt/.virtualenvs/r-tensorflow 初始化虚拟环境 virtualenv -p /usr/bin/python3 /opt/.virtualenvs/r-tensorflow 激活虚拟环境，安装必要的模块 source /opt/.virtualenvs/r-tensorflow/bin/activate pip install numpy 一般来讲，系统自带的 pip 版本较低，可以考虑升级 pip 版本。 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U 根据项目配置文件 requirements.txt 安装多个 Python 模块，每个 Python 项目都应该有这么个文件来描述项目需要的依赖环境，包含 Python 模块及其版本号。 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt 指定 Python 模块的镜像地址，加快下载速度，特别是对于国内的环境，加速镜像站点非常有意义，特别是遇到大型的 Python 模块，比如 tensorflow 框架 pip install -i https://pypi.tuna.tsinghua.edu.cn/simple tensorflow conda 创建 Python 3.8 虚拟环境，并命名为 tensorflow conda create -n tensorflow python=3.8 激活 tensorflow 环境 conda activate tensorflow "],["sec-plot-python.html", "B.18 Python 基础绘图", " B.18 Python 基础绘图 Python 的 matplotlib 模块支持保存的图片格式有 eps, pdf, pgf, png, ps, raw, rgba, svg, svgz，不支持 cairo_pdf 绘图设备，所以这里使用 pdf 设备，但是这样会导致图形没有字体嵌入，从而不符合出版要求。一个解决办法是在后期嵌入字体，图形默认使用数学字体 STIX 和英文字体 DejaVu Sans，所以需要预先安装这些字体。 # CentOS 8 sudo dnf install -y dejavu-fonts-common dejavu-sans-fonts \\ dejavu-serif-fonts dejavu-sans-mono-fonts 借助 grDevices 包提供的 embedFonts() 函数，它支持 postscript 和 pdf 图形设备，嵌入字体借助了 Ghostscript 以及 PDF 阅读器 MuPDF Windows 系统下需要手动指定 Ghostscript 安装路径，特别地，如果你想增加可选字体范围，需要指定相应字体搜索路径，而 Linux/MacOS 平台下不需要关心 Ghostscript 的安装路径问题， Sys.setenv(R_GSCMD = &quot;C:/Program Files/gs/gs9.26/bin/gswin64c.exe&quot;) embedFonts( file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;, fontpaths = system.file(&quot;fonts&quot;, package = &quot;fontcm&quot;) ) embedFonts(file = &quot;cm.pdf&quot;, outfile = &quot;cm-embed.pdf&quot;) 另一个解决办法是使用 LaTeX 渲染图片中的文字，这就需要额外安装一些 LaTeX 宏包，此时默认执行渲染的 LaTeX 引擎是 PDFLaTeX。 tlmgr install type1cm cm-super dvipng psnfss ucs ncntrsbk helvetic 每年 4 月是 TeX Live 的升级月，升级指导见 https://www.tug.org/texlive/upgrade.html，升级之后，需要更新所有 LaTeX 宏包。 tlmgr update --self --all 如图 B.12 所示，我们采用第二个方法，它可以支持更好的数学公式显示，更多详情见 https://matplotlib.org/tutorials/text/mathtext.html。 ## [&lt;matplotlib.lines.Line2D object at 0x7f38f43d74c0&gt;] ## Text(0.5, 0, &#39;Coord $x$&#39;) ## Text(0, 0.5, &#39;Coord $y$&#39;) 图 B.12: matplotlib 示例 如果你的系统是 Windows/MacOS 可以添加 GPG 验证以增加安全性，最简单的方式就是： tlmgr --repository http://www.preining.info/tlgpg/ install tlgpg 二维函数 \\(f(x,y) = 20 + x^2 + y^2 - 10*\\cos(2*\\pi*x) - 10*\\cos(2*\\pi*y)\\) 最小值 0 最大值 80 from math import cos, pi import numpy as np from mpl_toolkits.mplot3d import Axes3D import matplotlib.pyplot as plt from matplotlib import cm from matplotlib import rcParams rcParams.update({&#39;font.size&#39;: 18, &#39;text.usetex&#39;: True}) # 其它可配置选项见 rcParams.keys() plt.switch_backend(&#39;agg&#39;) xDomain = np.arange(-5.12, 5.12, .08) yDomain = np.arange(-5.12, 5.12, .08) X, Y = np.meshgrid(xDomain, yDomain) z = [20 + x**2 + y**2 - (10*(cos(2*pi*x) + cos(2*pi*y))) for x in xDomain for y in yDomain] Z = np.array(z).reshape(128,128) fig = plt.figure(figsize = (12,10)) ax = fig.gca(projection=&#39;3d&#39;) ## &lt;string&gt;:1: MatplotlibDeprecationWarning: Calling gca() with keyword arguments was deprecated in Matplotlib 3.4. Starting two minor releases later, gca() will take no keyword arguments. The gca() function should only be used to get the current axes, or if no axes exist, create new axes with default keyword arguments. To create a new axes with non-default arguments, use plt.axes() or plt.subplot(). surf = ax.plot_surface(X, Y, Z, cmap=cm.RdYlGn, linewidth=1, antialiased=False) ax.set_xlim(-5.12, 5.12) ## (-5.12, 5.12) ax.set_ylim(-5.12, 5.12) ## (-5.12, 5.12) ax.set_zlim(0, 80) ## (0.0, 80.0) fig.colorbar(surf, aspect=30) ## &lt;matplotlib.colorbar.Colorbar object at 0x7f38eddb2c40&gt; plt.title(r&#39;Rastrigin Function in Two Dimensions&#39;) ## Text(0.5, 0.92, &#39;Rastrigin Function in Two Dimensions&#39;) plt.show() "],["sec-basic-python.html", "B.19 Python 基础操作", " B.19 Python 基础操作 张量操作 numpy https://numpy.org/ 向量、矩阵操作 科学计算 scipy https://scipy.org/ 统计、优化和方程 数据操作 pandas https://pandas.pydata.org/ 面向数据分析 数据可视化 matplotlib https://matplotlib.org/ 静态图形 交互可视化 bokeh https://bokeh.org/ 机器学习 scikit-learn https://scikit-learn.org/ 面向机器学习 深度学习 tensorflow https://tensorflow.org/ 面向深度学习 A Python implementation of global optimization with gaussian processes. Bayesian Optimization 用 numpy 实现一个统计类的算法，比如线性回归、稳健的线性回归、广义线性回归，数据集用 Python 内置的 import numpy as np np.zeros(3) # vector ## array([0., 0., 0.]) np.ones(3) # vector ## array([1., 1., 1.]) np.diag([1,1,1]) # identy matrix # np.multiply() ## array([[1, 0, 0], ## [0, 1, 0], ## [0, 0, 1]]) np.cumsum([1,1,1]) ## array([1, 2, 3]) Python 模块 scikit-learn (Pedregosa et al. 2011) 内置的数据集 iris 为例 https://scikit-learn.org/stable/datasets/index.html 导入正则表达式库， import re m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;) m.group(0) # 必须调用 print 函数打印结果 ## &#39;def&#39; print(m.group(0)) ## def import sys print(sys.path) ## [&#39;&#39;, &#39;/usr/bin&#39;, &#39;/usr/lib/python38.zip&#39;, &#39;/usr/lib/python3.8&#39;, &#39;/usr/lib/python3.8/lib-dynload&#39;, &#39;/opt/.virtualenvs/r-tensorflow/lib/python3.8/site-packages&#39;, &#39;/home/runner/work/_temp/Library/reticulate/python&#39;, &#39;/opt/.virtualenvs/r-tensorflow/lib/python38.zip&#39;, &#39;/opt/.virtualenvs/r-tensorflow/lib/python3.8&#39;, &#39;/opt/.virtualenvs/r-tensorflow/lib/python3.8/lib-dynload&#39;] 字符串基本操作，如拆分 dir(str) ## [&#39;__add__&#39;, &#39;__class__&#39;, &#39;__contains__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__len__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;, &#39;center&#39;, &#39;count&#39;, &#39;encode&#39;, &#39;endswith&#39;, &#39;expandtabs&#39;, &#39;find&#39;, &#39;format&#39;, &#39;format_map&#39;, &#39;index&#39;, &#39;isalnum&#39;, &#39;isalpha&#39;, &#39;isascii&#39;, &#39;isdecimal&#39;, &#39;isdigit&#39;, &#39;isidentifier&#39;, &#39;islower&#39;, &#39;isnumeric&#39;, &#39;isprintable&#39;, &#39;isspace&#39;, &#39;istitle&#39;, &#39;isupper&#39;, &#39;join&#39;, &#39;ljust&#39;, &#39;lower&#39;, &#39;lstrip&#39;, &#39;maketrans&#39;, &#39;partition&#39;, &#39;replace&#39;, &#39;rfind&#39;, &#39;rindex&#39;, &#39;rjust&#39;, &#39;rpartition&#39;, &#39;rsplit&#39;, &#39;rstrip&#39;, &#39;split&#39;, &#39;splitlines&#39;, &#39;startswith&#39;, &#39;strip&#39;, &#39;swapcase&#39;, &#39;title&#39;, &#39;translate&#39;, &#39;upper&#39;, &#39;zfill&#39;] print(dir(str.split)) ## [&#39;__call__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__get__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__objclass__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__text_signature__&#39;] import re print(dir(re.split)) ## [&#39;__annotations__&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__closure__&#39;, &#39;__code__&#39;, &#39;__defaults__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__get__&#39;, &#39;__getattribute__&#39;, &#39;__globals__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__kwdefaults__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;] import sys # 模块存放路径 print(sys.path) # 已安装的模块 sys.modules.keys() dict_keys([&#39;sys&#39;, &#39;builtins&#39;, &#39;_frozen_importlib&#39;, &#39;_imp&#39;, &#39;_warnings&#39;, &#39;_frozen_importlib_external&#39;, &#39;_io&#39;, &#39;marshal&#39;, &#39;posix&#39;, &#39;_thread&#39;, &#39;_weakref&#39;, &#39;time&#39;, &#39;zipimport&#39;, &#39;_codecs&#39;, &#39;codecs&#39;, &#39;encodings.aliases&#39;, &#39;encodings.cp437&#39;, &#39;encodings&#39;, &#39;encodings.utf_8&#39;, &#39;_signal&#39;, &#39;__main__&#39;, &#39;encodings.latin_1&#39;, &#39;_abc&#39;, &#39;abc&#39;, &#39;io&#39;, &#39;_stat&#39;, &#39;stat&#39;, &#39;_collections_abc&#39;, &#39;genericpath&#39;, &#39;posixpath&#39;, &#39;os.path&#39;, &#39;os&#39;, &#39;_sitebuiltins&#39;, &#39;site&#39;, &#39;readline&#39;, &#39;atexit&#39;, &#39;rlcompleter&#39;]) pip3 install virtualenv virtualenv -p python3 &lt;desired-path&gt; source &lt;desired-path&gt;/bin/activate source /opt/virtualenv/tensorflow/bin/activate LaTeX 专家黄晨成写的译文 Matplotlib 教程 周沫凡 制作的莫烦 Python 系列视频教程之 Matplotlib 数据可视化神器 陈治兵维护的在线 Matplotlib 中文文档 Sebastian Raschka 和 Vahid Mirjalili 合著的 Python Machine Learning (3rd Edition) (Python Machine Learning, n.d.) 编译书籍使用的 Python 3 模块有 pip3 list --format=columns Package Version absl-py 0.12.0 astunparse 1.6.3 cachetools 4.2.2 certifi 2021.5.30 chardet 4.0.0 cycler 0.10.0 flatbuffers 1.12 gast 0.4.0 google-auth 1.30.1 google-auth-oauthlib 0.4.4 google-pasta 0.2.0 graphviz 0.8.4 grpcio 1.34.1 h5py 3.1.0 idna 2.10 joblib 1.0.1 keras-nightly 2.5.0.dev2021032900 Keras-Preprocessing 1.1.2 kiwisolver 1.3.1 Markdown 3.3.4 matplotlib 3.4.2 mpmath 1.2.1 mxnet 1.8.0.post0 numpy 1.20.3 oauthlib 3.1.1 opt-einsum 3.3.0 pandas 1.2.4 Pillow 8.2.0 pip 20.0.2 pkg-resources 0.0.0 plotly 4.14.3 protobuf 3.17.2 pyasn1 0.4.8 pyasn1-modules 0.2.8 pyparsing 2.4.7 python-dateutil 2.8.1 pytz 2021.1 requests 2.25.1 requests-oauthlib 1.3.0 retrying 1.3.3 rsa 4.7.2 scikit-learn 0.24.2 scipy 1.6.3 setuptools 44.0.0 six 1.15.0 sympy 1.8 tensorboard 2.5.0 tensorboard-data-server 0.6.1 tensorboard-plugin-wit 1.8.0 tensorflow 2.5.0 tensorflow-estimator 2.5.0 termcolor 1.1.0 threadpoolctl 2.1.0 typing-extensions 3.7.4.3 urllib3 1.26.5 Werkzeug 2.0.1 wheel 0.36.2 wrapt 1.12.1 # 安装 Python 虚拟环境管理器 virtualenv sudo dnf install -y python3-pip python3-virtualenv # 创建虚拟环境 virtualenv -p /usr/bin/python3 $RETICULATE_PYTHON_ENV # 激活虚拟环境 source $RETICULATE_PYTHON_ENV/bin/activate # 将虚拟环境位置写入配置文件 echo &quot;export RETICULATE_PYTHON_ENV=$HOME/.virtualenvs/r-tensorflow&quot; &gt;&gt; ~/.bashrc source ~/.bashrc # 安装 numpy matplotlib 等模块 pip install -r requirements.txt # 导出模块版本信息 pip freeze &gt;&gt; requirements.txt import os os.listdir(&#39;.git&#39;) ## [&#39;HEAD&#39;, &#39;hooks&#39;, &#39;refs&#39;, &#39;branches&#39;, &#39;config&#39;, &#39;shallow&#39;, &#39;description&#39;, &#39;info&#39;, &#39;FETCH_HEAD&#39;, &#39;logs&#39;, &#39;index&#39;, &#39;objects&#39;] 多个代码块共享同一个 Python 进程 os.path ## &lt;module &#39;posixpath&#39; from &#39;/usr/lib/python3.8/posixpath.py&#39;&gt; matplotlib 绘图，支持交叉引用51，如图 B.13 所示 import matplotlib.pyplot as plt from matplotlib import rcParams # 其它可配置选项见 rcParams.keys() rcParams.update({&#39;font.size&#39;: 10, &#39;text.usetex&#39;: True}) # rcParams.update({&#39;font.family&#39;: [&#39;sans-serif&#39;], # &#39;font.monospace&#39;: [&#39;DejaVu Sans Mono&#39;], # &#39;font.sans-serif&#39;: [&#39;DejaVu Sans&#39;], # &#39;font.serif&#39;: [&#39;DejaVu Serif&#39;]}) plt.switch_backend(&#39;agg&#39;) plt.plot([0, 2, 1, 4]) ## [&lt;matplotlib.lines.Line2D object at 0x7f38d5d56c10&gt;] plt.xlabel(r&#39;Coord $x$&#39;) ## Text(0.5, 0, &#39;Coord $x$&#39;) plt.ylabel(r&#39;Coord $y$&#39;) ## Text(0, 0.5, &#39;Coord $y$&#39;) plt.tight_layout() plt.show() 图 B.13: matplotlib 复制示例 有了 reticulate 包，我们可以把任意想要导入到 R 环境中的 Python 模块导进来，实现 R 与 Python 的数据交换和函数调用52 os &lt;- reticulate::import(&quot;os&quot;) # 导入 Python 模块 x &lt;- os$listdir(&quot;.git&quot;) # 调用 os.listdir() 函数 x # 得到 python 中的向量 vector 或数组 array ## [1] &quot;HEAD&quot; &quot;hooks&quot; &quot;refs&quot; &quot;branches&quot; &quot;config&quot; ## [6] &quot;shallow&quot; &quot;description&quot; &quot;info&quot; &quot;FETCH_HEAD&quot; &quot;logs&quot; ## [11] &quot;index&quot; &quot;objects&quot; # https://docs.bokeh.org/en/latest/docs/user_guide/quickstart.html#userguide-quickstart from bokeh.plotting import figure, output_file, show # 准备一些数据 x = [1, 2, 3, 4, 5] y = [6, 7, 2, 4, 5] # 将动态图形以静态 HTML 文件的方式保存 output_file(&quot;lines.html&quot;) # 创建一个简单的图形，设置标题、x,y 轴标签 p = figure(title=&quot;simple line example&quot;, x_axis_label=&#39;x&#39;, y_axis_label=&#39;y&#39;) # 添加一条折线，设置图例，线宽 p.line(x, y, legend_label=&quot;Temp.&quot;, line_width=2) # 显示结果 show(p) 将静态图形嵌入到 R Markdown 中 htmltools::includeHTML(&quot;lines.html&quot;) R 和 Python 之间的交互，Python 负责数据处理和建模， R 负责绘图，有些复杂的机器学习模型及其相关数据操作需要在 Python 中完成，数据集清理至数据框的形式后导入到 R 中，画各种静态或者动态图，这时候需要加载 reticulate 包，只是设置 python.reticulate = TRUE 还不够 R Markdown 文档 (Xie, Allaire, and Grolemund 2018) 中的 Python 代码块是由 knitr 包 (Xie 2015) 负责调度处理的，展示 Matplotlib 绘图的结果使用了 reticulate 包 (Ushey, Allaire, and Tang 2021) 提供的 Python 引擎而不是 knitr 自带的。 在 knitr::opts_chunk 中设置 python.reticulate = TRUE 意味着所有的 Python 代码块共享一个 Python Session，而 python.reticulate = FALSE 意味着使用 knitr 提供的 Python 引擎，所有的 Python 代码块独立运行。 pandas 读取数据，整理后由 reticulate 包传递给 R 环境中的 data.frame 对象，加载 ggplot2 绘图 以 NumPy 为例 import numpy as np a = np.arange(15).reshape(3, 5) a ## array([[ 0, 1, 2, 3, 4], ## [ 5, 6, 7, 8, 9], ## [10, 11, 12, 13, 14]]) a.shape ## (3, 5) a.ndim ## 2 a.dtype.name ## &#39;int64&#39; a.itemsize ## 8 a.size ## 15 type(a) ## &lt;class &#39;numpy.ndarray&#39;&gt; b = np.array([6, 7, 8]) b ## array([6, 7, 8]) type(b) ## &lt;class &#39;numpy.ndarray&#39;&gt; a.transpose() @ b ## array([115, 136, 157, 178, 199]) Python 里面的点号\\(\\cdot\\)对应于R里面的 $ library(reticulate) np &lt;- import(&quot;numpy&quot;, convert=FALSE) # 导入 Python 模块 a &lt;- np$arange(0, 15)$reshape(3L, 5L) a ## [[ 0. 1. 2. 3. 4.] ## [ 5. 6. 7. 8. 9.] ## [10. 11. 12. 13. 14.]] a$shape ## (3, 5) a$ndim ## 2 a$dtype$name ## float64 a$itemsize ## 8 a$size ## 15 a$ctypes ## &lt;numpy.core._internal._ctypes&gt; a$dtype # data type 数据类型 ## float64 a$astype ## &lt;built-in method astype of numpy.ndarray&gt; builtins &lt;- import_builtins() # Python 内建的函数，不需要导入第三方模块 builtins$type(a) ## &lt;class &#39;numpy.ndarray&#39;&gt; 基本线性代数运算 a$transpose() # 转置 ## [[ 0. 5. 10.] ## [ 1. 6. 11.] ## [ 2. 7. 12.] ## [ 3. 8. 13.] ## [ 4. 9. 14.]] a$trace() # 迹 ## 18.0 np$eye(2L) # 单位矩阵 ## [[1. 0.] ## [0. 1.]] a$diagonal() # 对角 ## [ 0. 6. 12.] # 两个矩阵的乘法 b &lt;- np$array(c(6, 7, 8, 9, 10))$reshape(5L, 1L) b ## [[ 6.] ## [ 7.] ## [ 8.] ## [ 9.] ## [10.]] b$shape ## (5, 1) np$multiply(b$transpose(), a) # b 乘以 a ## [[ 0. 7. 16. 27. 40.] ## [ 30. 42. 56. 72. 90.] ## [ 60. 77. 96. 117. 140.]] Python 对象转化为 R 对象 py_to_r(b) ## [,1] ## [1,] 6 ## [2,] 7 ## [3,] 8 ## [4,] 9 ## [5,] 10 参考文献 "],["sec-virtual-vbox.html", "B.20 VBox 虚拟机", " B.20 VBox 虚拟机 B.20.1 从命令行启动虚拟机 当前我的虚拟机里安装了两个系统 Fedora 29 和 CentOS 8.2 VBoxManage list vms &quot;Fedora 29&quot; {d316fe8d-c053-4941-8a45-a59fd476898d} &quot;CentOS 8.2&quot; {f1613f26-ea65-4f02-9cb6-6a79a758a60e} 以无图形化界面的方式启动虚拟机 CentOS 8.2 VBoxManage startvm &quot;CentOS 8.2&quot; --type headless # 或者 VBoxHeadless --startvm &quot;CentOS 8.2&quot; 其它常用的命令还有 VBoxManage list runningvms # 列出运行中的虚拟机 VBoxManage controlvm &quot;CentOS 8.2&quot; acpipowerbutton # 关闭虚拟机，等价于点击系统关闭按钮，正常关机 VBoxManage controlvm &quot;CentOS 8.2&quot; poweroff # 关闭虚拟机，等价于直接关闭电源，非正常关机 VBoxManage controlvm &quot;CentOS 8.2&quot; pause # 暂停虚拟机的运行 VBoxManage controlvm &quot;CentOS 8.2&quot; resume # 恢复暂停的虚拟机 VBoxManage controlvm &quot;CentOS 8.2&quot; savestate # 保存当前虚拟机的运行状态 更多细节解释见 VBox 官方文档 "],["sec-virtual-docker.html", "B.21 Docker 虚拟环境", " B.21 Docker 虚拟环境 docker 创建云实例 rstudio DigitalOcean，docker 支持的驱动类型 https://docs.docker.com/machine/drivers/。Rocker 项目组提供的 shiny 容器 https://github.com/rocker-org/shiny 和构建过程 https://hub.docker.com/r/rocker/shiny/dockerfile 主机 80 端口映射给 shiny 容器 3838 端口 docker run --user shiny -d -p 80:3838 \\ -v /srv/shinyapps/:/srv/shiny-server/ \\ -v /srv/shinylog/:/var/log/shiny-server/ \\ rocker/shiny shiny 服务器默认支持从 80 端口访问 http://localhost:80，shiny 应用放在目录 /srv/shinyapps/appdir，访问 Shiny 应用的位置 http://localhost/appdir/，使用 boot2docker 则访问 http://192.168.59.103:80/appdir/ Docker 相比虚拟机占用资源少，拉起来就可以用，虚拟机还需要各种环境配置，很多与R有关的项目现在都提供Docker镜像，大大方便了开发人员和数据分析师。当然 docker 的环境隔离性，对主机系统侵入小，即使挂了，再拉起来也就是了，安全性和可靠性高。 基于 The Rocker Project 快速构建数据分析环境，Rocker项目 站在 Debian 和 R 的肩膀上，在 Docker 内配置众多数据分析和开发的工具，免去用户手动配置的复杂性。此事非有心者不能为之 ，因为需费时费力找寻依赖库，编译 R 包，还要尽可能地给 Docker 镜像减负，以便部署。如果想抢先试水的赶快去 Rocker 项目主页。 由 Dirk Eddelbuettel 等人担纲的 Rocker 项目， 项目主页 和 Docker镜像 Wei-Chen Chen 等人的大数据编程项目 Programming with Big Data in R， 项目主页 和 Docker 镜像 非常详细的 docker 笔记 Dockerfile 最佳实践 https://docs.docker.com/develop/develop-images/dockerfile_best-practices/ build 构建 https://docs.docker.com/engine/reference/builder/#usage 其它容器相关项目有 Singularity 和 Kubernetes 容器集群管理，更多参见高策的博客 https://gaocegege.com 本节介绍与本书配套的 VBox 镜像和 Docker 容器镜像，方便读者直接运行书籍原稿中的例子，尽量不限于软件环境配置的苦海中，因为对于大多数初学者来说，软件配置是一件不小的麻烦事。 本书依赖的 R 包和配置环境比较复杂，所以将整个运行环境打包成 Docker 镜像，方便读者重现，构建镜像的 Dockerfile 文件随同书籍源文件一起托管在 Github 上，方便读者研究。本地编译书籍只需三步走，先将存放在 Github 上的书籍项目克隆到本地，如果本地环境中没有 Git，你需要从它的官网 https://git-scm.com/ 下载安装适配本地系统的 Git 软件。 git clone https://github.com/XiangyunHuang/masr.git 然后在 Git Bash 的模拟终端器中，启动虚拟机，拉取准备好的镜像文件。为了方便读者重现本书的内容，特将书籍的编译环境打包成 Docker 镜像。在启动镜像前需要确保本地已经安装 Docker 软件 https://www.docker.com/products/docker-desktop，安装过程请看官网教程。 docker-machine.exe start default docker pull xiangyunhuang/masr 最后 cd 进入书籍项目所在目录，运行如下命令编译书籍 docker run --rm -u docker -v &quot;/${PWD}://home/docker/workspace&quot; \\ xiangyunhuang/masr make gitbook 编译成功后，可以在目录 _book/ 下看到生成的文件，点击文件 index.html 选择谷歌浏览器打开，不要使用 IE 浏览器，推荐使用谷歌浏览器获取最佳阅读体验，尽情地阅读吧！ 如果你想了解编译书籍的环境和过程，我推荐你阅读随书籍源文件一起的 Dockerfile 文件， Docker Hub 是根据此文件构建的镜像，打包成功后，大约占用空间 2 Gb，本书在 RStudio IDE 下用 R Markdown (Xie, Allaire, and Grolemund 2018) 编辑的，编译本书获得电子版还需要一些 R 包和软件。Pandoc https://pandoc.org/ 软件是系统 Fedora 30 仓库自带的，版本是 2.2.1，较新的 RStudio IDE 捆绑的 Pandoc 软件一般会高于此版本。如果你打算在本地系统上编译书籍，RStudio IDE 捆绑的 Pandoc 软件版本已经足够，当然你也可以在 https://github.com/jgm/pandoc/releases/latest 下载安装最新版本，此外，你还需参考书籍随附的 Dockerfile 文件配置 C++ 代码编译环境，安装所需的 R 包，并确保本地安装的版本不低于镜像内的版本。 镜像中已安装的 R 包列表可运行如下命令查看。 docker run --rm xiangyunhuang/masr \\ Rscript -e &#39;xfun::session_info(.packages(TRUE))&#39; Docker &amp; Docker Machine &amp; Docker Swarm 容器与镜像的操作 docker --version # Docker version 18.03.0-ce, build 0520e24302 查看容器 docker ps -a 删除容器 docker rm 容器 ID，删除前要确认已经停止该容器的运行 docker rm 6f932357e6ce 查看镜像 docker images 删除镜像 docker rmi 镜像 ID docker rmi 811281c54b23 拉取镜像 docker pull rocker/verse:latest 运行容器 docker run --name verse -d -p 8282:8080 -e ROOT=TRUE \\ -e USER=rstudio -e PASSWORD=cloud rocker/verse 将主机端口 8282 映射给虚拟机/容器的 8080 端口，RStudio Server 默认使用的端口是 8787，因此改为 8080 需要修改 /etc/rstudio/rserver.conf 文件，添加 www-port=8080 然后重启 RStudio Server，之后可以在浏览器中登陆，登陆网址为 http://ip-addr:8080，其中 ip-addr 可在容器中运行如下一行命令获得 ip addr 更多关于服务器版本的 RStudio 介绍，请参考 https://docs.rstudio.com/ide/server-pro/access-and-security.html Docker Machine 基本命令 查看 docker machine 版本信息 docker-machine --version # docker-machine.exe version 0.14.0, build 89b8332 列出创建的虚拟机 # 启动前 docker-machine ls # NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS # default - virtualbox Stopped Unknown # 启动后 docker-machine ls # NAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORS # default * virtualbox Running tcp://192.168.99.100:2376 v18.03.0-ce 查看虚拟机 default 的 ip docker-machine ip default # 192.168.99.100 启动虚拟机 docker-machine start default # Starting &quot;default&quot;... # (default) Check network to re-create if needed... # (default) Windows might ask for the permission to configure a dhcp server. Sometimes, such confirmation window is minimized in the taskbar. # (default) Waiting for an IP... # Machine &quot;default&quot; was started. # Waiting for SSH to be available... # Detecting the provisioner... # Started machines may have new IP addresses. You may need to re-run the `docker-machine env` command. 进入 Docker 环境 docker-machine ssh default ## . ## ## ## == ## ## ## ## ## === /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\\___/ === ~~~ {~~ ~~~~ ~~~ ~~~~ ~~~ ~ / ===- ~~~ \\______ o __/ \\ \\ __/ \\____\\_______/ _ _ ____ _ _ | |__ ___ ___ | |_|___ \\ __| | ___ ___| | _____ _ __ | &#39;_ \\ / _ \\ / _ \\| __| __) / _` |/ _ \\ / __| |/ / _ \\ &#39;__| | |_) | (_) | (_) | |_ / __/ (_| | (_) | (__| &lt; __/ | |_.__/ \\___/ \\___/ \\__|_____\\__,_|\\___/ \\___|_|\\_\\___|_| Boot2Docker version 18.03.0-ce, build HEAD : 404ee40 - Thu Mar 22 17:12:23 UTC 2018 Docker version 18.03.0-ce, build 0520e24 查看容器 docker ps -a # CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 69e6929d269e rocker/verse &quot;/init&quot; 3 weeks ago Exited (0) 10 days ago verse 启动/停止容器 docker start verse # verse docker stop verse # verse 查看虚拟机 default 的环境 docker-machine env default # export DOCKER_TLS_VERIFY=&quot;1&quot; # export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot; # export DOCKER_CERT_PATH=&quot;D:\\Docker\\machines\\default&quot; # export DOCKER_MACHINE_NAME=&quot;default&quot; # export COMPOSE_CONVERT_WINDOWS_PATHS=&quot;true&quot; # # Run this command to configure your shell: # # eval $(&quot;C:\\Program Files\\Docker Toolbox\\docker-machine.exe&quot; env default) 关闭虚拟机 default docker-machine stop default # Stopping &quot;default&quot;... # Machine &quot;default&quot; was stopped. 更多详情见帮助文档 https://docs.docker.com/machine/get-started 参考文献 "],["setup-r.html", "B.22 安装的 R 包", " B.22 安装的 R 包 本小节仅用于展示目前书籍写作过程中安装的 R 包依赖，不会出现在最终的书稿中 sessionInfo(sort(.packages(T))) ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] base compiler datasets graphics grDevices grid methods ## [8] parallel splines stats stats4 tcltk tools utils ## ## other attached packages: ## [1] abind_1.4-5 agridat_1.18 ## [3] arrow_4.0.1 arules_1.6-8 ## [5] askpass_1.1 assertive.base_0.0-9 ## [7] assertive.properties_0.0-4 assertive.types_0.0-3 ## [9] assertthat_0.2.1 autoplotly_0.1.4 ## [11] backports_1.2.1 base64enc_0.1-3 ## [13] bayesplot_1.8.0 beanplot_1.2 ## [15] beeswarm_0.4.0 BH_1.75.0-0 ## [17] BiocGenerics_0.38.0 BiocManager_1.30.15 ## [19] BiocVersion_3.13.1 bit_4.0.4 ## [21] bit64_4.0.5 bitops_1.0-7 ## [23] blob_1.2.1 bookdown_0.22 ## [25] boot_1.3-28 brew_1.0-6 ## [27] bridgesampling_1.1-2 brio_1.1.2 ## [29] brms_2.15.0 Brobdingnag_1.2-6 ## [31] broom_0.7.6 broom.mixed_0.2.6 ## [33] bslib_0.2.5.1 cachem_1.0.5 ## [35] Cairo_1.5-12.2 callr_3.7.0 ## [37] car_3.0-10 carData_3.0-4 ## [39] catboost_0.26 caTools_1.18.2 ## [41] cellranger_1.1.0 checkmate_2.0.0 ## [43] circlize_0.4.12 class_7.3-19 ## [45] classInt_0.4-3 cli_2.5.0 ## [47] clipr_0.7.1 clue_0.3-59 ## [49] cluster_2.1.2 cmdstanr_0.4.0 ## [51] coda_0.19-4 codetools_0.2-18 ## [53] colorspace_2.0-1 colourpicker_1.1.0 ## [55] commonmark_1.7 ComplexHeatmap_2.8.0 ## [57] config_0.3.1 conquer_1.0.2 ## [59] corrplot_0.88 countrycode_1.2.0 ## [61] cowplot_1.1.1 cpp11_0.2.7 ## [63] crayon_1.4.1 credentials_1.3.0 ## [65] crosstalk_1.1.1 cubelyr_1.0.1 ## [67] curl_4.3.1 data.table_1.14.0 ## [69] DBI_1.1.1 dbplyr_2.1.1 ## [71] dendextend_1.15.1 desc_1.3.0 ## [73] devtools_2.4.1 DiagrammeR_1.0.6.1 ## [75] diffobj_0.3.4 digest_0.6.27 ## [77] distributional_0.2.2 doParallel_1.0.16 ## [79] downloader_0.4 dplyr_1.0.6 ## [81] DT_0.18 dtplyr_1.1.0 ## [83] dygraphs_1.1.1.6 e1071_1.7-7 ## [85] echarts4r_0.4.0 egg_0.4.5 ## [87] ellipsis_0.3.2 emo_0.0.0.9000 ## [89] equatiomatic_0.2.0 evaluate_0.14 ## [91] extrafont_0.17 extrafontdb_1.0 ## [93] fansi_0.5.0 farver_2.1.0 ## [95] fastmap_1.1.0 filehash_2.4-2 ## [97] flexdashboard_0.5.2 fontcm_1.1 ## [99] forcats_0.5.1 foreach_1.5.1 ## [101] foreign_0.8-81 forge_0.2.0 ## [103] formatR_1.11 formattable_0.2.1 ## [105] Formula_1.2-4 fresh_0.2.0 ## [107] fs_1.5.0 future_1.21.0 ## [109] gamm4_0.2-6 gapminder_0.3.0 ## [111] gargle_1.1.0 gclus_1.3.2 ## [113] gdtools_0.2.3 generics_0.1.0 ## [115] geoR_1.8-1 gert_1.3.0 ## [117] GetoptLong_1.0.5 gganimate_1.0.7 ## [119] ggbeeswarm_0.6.0 ggdendro_0.1.22 ## [121] ggfittext_0.9.1 ggfortify_0.4.11 ## [123] ggmosaic_0.3.3 ggnormalviolin_0.1.2 ## [125] ggplot2_3.3.3 ggpubr_0.4.0 ## [127] ggrepel_0.9.1 ggridges_0.5.3 ## [129] ggsci_2.9 ggsignif_0.6.1 ## [131] ggstream_0.1.0 gh_1.3.0 ## [133] gifski_1.4.3-1 git2r_0.28.0 ## [135] gitcreds_0.1.1 glmmTMB_1.0.2.1 ## [137] glmnet_4.1-1 GlobalOptions_0.1.2 ## [139] globals_0.14.0 glue_1.4.2 ## [141] googledrive_1.0.1 googlesheets4_0.3.0 ## [143] gplots_3.1.1 gridBase_0.4-7 ## [145] gridExtra_2.3 gt_0.3.0 ## [147] gtable_0.3.0 gtools_3.8.2 ## [149] haven_2.4.1 heatmaply_1.2.1 ## [151] hexbin_1.28.2 highcharter_0.8.2 ## [153] highr_0.9 Hmisc_4.5-0 ## [155] hms_1.1.0 hrbrthemes_0.8.0 ## [157] htmlTable_2.2.1 htmltools_0.5.1.1 ## [159] htmlwidgets_1.5.3 httpuv_1.6.1 ## [161] httr_1.4.2 ids_1.0.1 ## [163] igraph_1.2.6 influenceR_0.1.0 ## [165] ini_0.3.1 INLA_21.02.23 ## [167] inline_0.3.19 IRanges_2.26.0 ## [169] isoband_0.2.4 iterators_1.0.13 ## [171] jpeg_0.1-8.1 jquerylib_0.1.4 ## [173] jsonlite_1.7.2 kableExtra_1.3.4 ## [175] Kendall_2.2 KernSmooth_2.23-20 ## [177] knitr_1.33 labeling_0.4.2 ## [179] later_1.2.0 lattice_0.20-44 ## [181] latticeExtra_0.6-29 lazyeval_0.2.2 ## [183] leaflet_2.0.4.1 leaflet.providers_1.9.0 ## [185] lifecycle_1.0.0 lightgbm_3.2.1 ## [187] listenv_0.8.0 lme4_1.1-27 ## [189] loo_2.4.1 lpSolve_5.6.15 ## [191] lubridate_1.7.10 magick_2.7.2 ## [193] magrittr_2.0.1 mapdata_2.3.0 ## [195] mapproj_1.2.7 maps_3.3.0 ## [197] maptools_1.1-1 markdown_1.1 ## [199] MASS_7.3-54 Matrix_1.3-4 ## [201] MatrixModels_0.5-0 matrixStats_0.59.0 ## [203] maxLik_1.4-8 mcmc_0.9-7 ## [205] memoise_2.0.0 mgcv_1.8-36 ## [207] mime_0.10 miniUI_0.1.1.1 ## [209] minqa_1.2.4 miscTools_0.6-26 ## [211] modelr_0.1.8 munsell_0.5.0 ## [213] mvtnorm_1.1-1 networkD3_0.4 ## [215] nleqslv_3.3.2 nlme_3.1-152 ## [217] nloptr_1.2.2.2 nnet_7.3-16 ## [219] nomnoml_0.2.3 numDeriv_2016.8-1.1 ## [221] odbc_1.3.2 openssl_1.4.4 ## [223] openxlsx_4.2.3 optimx_2020-4.2 ## [225] packrat_0.6.0 palmerpenguins_0.1.0 ## [227] parallelly_1.25.0 patchwork_1.1.1 ## [229] pbkrtest_0.5.1 pdftools_3.0.1 ## [231] pdist_1.2 pillar_1.6.1 ## [233] pkgbuild_1.2.0 pkgconfig_2.0.3 ## [235] pkgload_1.2.1 plogr_0.2.0 ## [237] plotly_4.9.3 plyr_1.8.6 ## [239] png_0.1-7 polynom_1.4-0 ## [241] posterior_0.1.5 praise_1.0.0 ## [243] prettydoc_0.4.1 prettyunits_1.1.1 ## [245] PrevMap_1.5.3 processx_3.5.2 ## [247] productplots_0.1.1 progress_1.2.2 ## [249] projpred_2.0.2 promises_1.2.0.1 ## [251] proxy_0.4-25 ps_1.6.0 ## [253] pspearman_0.3-0 purrr_0.3.4 ## [255] pwr_1.3-0 qap_0.1-1 ## [257] qpdf_1.1 quadprog_1.5-8 ## [259] quantmod_0.4.18 quantreg_5.85 ## [261] r2d3_0.2.5 R6_2.5.0 ## [263] RandomFields_3.3.8 RandomFieldsUtils_0.5.3 ## [265] rappdirs_0.3.3 raster_3.4-10 ## [267] rasterly_0.2.0 rasterVis_0.50.2 ## [269] rcmdcheck_1.3.3 RColorBrewer_1.1-2 ## [271] Rcpp_1.0.6 RcppArmadillo_0.10.5.0.0 ## [273] RcppEigen_0.3.3.9.1 RcppParallel_5.1.4 ## [275] reactable_0.2.3 reactR_0.4.4 ## [277] readr_1.4.0 readxl_1.3.1 ## [279] registry_0.5-1 rematch_1.0.1 ## [281] rematch2_2.1.2 remotes_2.4.0 ## [283] renv_0.13.2 reprex_2.0.0 ## [285] reshape2_1.4.4 reticulate_1.20 ## [287] rgdal_1.5-23 rio_0.5.26 ## [289] rjson_0.2.20 rlang_0.4.11 ## [291] rlist_0.4.6.1 rmarkdown_2.8 ## [293] rngtools_1.5 rootSolve_1.8.2.1 ## [295] roxygen2_7.1.1 rpart_4.1-15 ## [297] rprojroot_2.0.2 rsconnect_0.8.18 ## [299] RSQLite_2.2.7 rstan_2.21.2 ## [301] rstantools_2.1.1 rstatix_0.7.0 ## [303] rstudioapi_0.13 Rttf2pt1_1.3.8 ## [305] rversions_2.1.1 rvest_1.0.0 ## [307] Ryacas_1.1.3.1 S4Vectors_0.30.0 ## [309] sandwich_3.0-1 sass_0.4.0 ## [311] scales_1.1.1 selectr_0.4-2 ## [313] seriation_1.2-9 sessioninfo_1.1.1 ## [315] sf_0.9-8 shades_1.4.0 ## [317] shape_1.4.6 shiny_1.6.0 ## [319] shinydashboard_0.7.1 shinydashboardPlus_2.0.1 ## [321] shinyjs_2.0.0 shinystan_2.5.0 ## [323] shinythemes_1.2.0 shinyWidgets_0.6.0 ## [325] showtext_0.9-2 showtextdb_3.0 ## [327] sm_2.2-5.6 sourcetools_0.1.7 ## [329] sp_1.4-5 sparkline_2.0 ## [331] sparklyr_1.6.3 SparseM_1.81 ## [333] spatial_7.3-14 spDataLarge_0.5.2 ## [335] splancs_2.01-42 StanHeaders_2.21.0-7 ## [337] stringi_1.6.2 stringr_1.4.0 ## [339] SuppDists_1.1-9.5 survival_3.2-11 ## [341] svglite_2.0.0 sys_3.4 ## [343] sysfonts_0.8.3 systemfonts_1.0.2 ## [345] tensorA_0.36.2 tensorflow_2.4.0 ## [347] terra_1.2-10 testthat_3.0.2 ## [349] tfruns_1.5.0 threejs_0.3.3 ## [351] tibble_3.1.2 tidyr_1.1.3 ## [353] tidyselect_1.1.1 tidyverse_1.3.1 ## [355] tikzDevice_0.12.3.1 timeline_0.9 ## [357] timelineS_0.1.1 tint_0.1.3 ## [359] tinytex_0.32 TMB_1.7.20 ## [361] transformr_0.1.3 treemap_2.4-2 ## [363] treemapify_2.5.5 truncnorm_1.0-8 ## [365] TSP_1.1-10 TTR_0.24.2 ## [367] tweenr_1.0.2 units_0.7-1 ## [369] usethis_2.0.1 utf8_1.2.1 ## [371] uuid_0.1-4 V8_3.4.2 ## [373] vctrs_0.3.8 vioplot_0.3.6 ## [375] vipor_0.4.5 viridis_0.6.1 ## [377] viridisLite_0.4.0 visNetwork_2.0.9 ## [379] vistime_1.2.1 waiter_0.2.1 ## [381] waldo_0.2.5 webshot_0.5.2 ## [383] whisker_0.4 withr_2.4.2 ## [385] xfun_0.23 xgboost_1.4.1.1 ## [387] xkcd_0.0.6 XML_3.99-0.6 ## [389] xml2_1.3.2 xopen_1.0.0 ## [391] xtable_1.8-4 xts_0.12.1 ## [393] yaml_2.2.1 zip_2.2.0 ## [395] zoo_1.8-9 library(magrittr) pdb &lt;- tools::CRAN_package_db() pkg &lt;- subset(desc::desc_get_deps(), subset = type == &quot;Imports&quot;, select = &quot;package&quot;, drop = TRUE) pkg &lt;- tools::package_dependencies(packages = pkg, db = pdb, recursive = FALSE) %&gt;% # 是否包含递归依赖 unlist() %&gt;% as.vector() %&gt;% c(., pkg) %&gt;% unique() %&gt;% sort() pkg_quote &lt;- c( &quot;Armadillo&quot;, &quot;Rcpp&quot;, &quot;R&quot;, &quot;Stan&quot;, &quot;DataTables&quot;, &quot;Dygraphs&quot;, &quot;ggplot2&quot;, &quot;Grobs&quot;, &quot;Geospatial&quot;, &quot;Eigen&quot;, &quot;Sundown&quot;, &quot;plog&quot;, &quot;TeX Live&quot;, &quot;Tidyverse&quot;, &quot;LaTeX&quot;, &quot;ADMB&quot;, &quot;matplotlib&quot;, &quot;Yihui Xie&quot;, &quot;With&quot;, &quot;Highcharts&quot;, &quot;kable&quot;, &quot;plotly.js&quot;, &quot;Python&quot;, &quot;Formattable&quot; ) # 单引号 pkg_regexp &lt;- paste(&quot;&#39;(&quot;, paste(pkg_quote, collapse = &quot;|&quot;), &quot;)&#39;&quot;, sep = &quot;&quot;) # R 包列表 subset(pdb, subset = !duplicated(pdb$Package) &amp; Package %in% pkg, select = c(&quot;Package&quot;, &quot;Version&quot;, &quot;Title&quot;) ) %&gt;% transform(., Title = gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, Title), Package = paste(&quot;**&quot;, Package, &quot;**&quot;, sep = &quot;&quot;) ) %&gt;% transform(., Title = gsub(pkg_regexp, &quot;\\\\1&quot;, Title)) %&gt;% transform(., Title = gsub(&#39;&quot;(Grid)&quot;&#39;, &quot;\\\\1&quot;, Title)) %&gt;% knitr::kable(., caption = &quot;依赖的 R 包&quot;, format = &quot;pandoc&quot;, booktabs = TRUE, row.names = FALSE ) 表 B.1: 依赖的 R 包 Package Version Title agridat 1.18 Agricultural Datasets arrow 4.0.1 Integration to ‘Apache’ ‘Arrow’ arules 1.6-8 Mining Association Rules and Frequent Itemsets assertive.types 0.0-3 Assertions to Check Types of Variables assertthat 0.2.1 Easy Pre and Post Assertions autoplotly 0.1.4 Automatic Generation of Interactive Visualizations for Statistical Results base64enc 0.1-3 Tools for base64 encoding bayesplot 1.8.0 Plotting for Bayesian Models beanplot 1.2 Visualization via Beanplots (like Boxplot/Stripchart/Violin Plot) beeswarm 0.4.0 The Bee Swarm Plot, an Alternative to Stripchart BiocManager 1.30.15 Access the Bioconductor Project Package Repository bit64 4.0.5 A S3 Class for Vectors of 64bit Integers bitops 1.0-7 Bitwise Operations blob 1.2.1 A Simple S3 Class for Representing Vectors of Binary Data (‘BLOBS’) bookdown 0.22 Authoring Books and Technical Documents with R Markdown boot 1.3-28 Bootstrap Functions (Originally by Angelo Canty for S) broom 0.7.6 Convert Statistical Objects into Tidy Tibbles broom.mixed 0.2.6 Tidying Methods for Mixed Models bslib 0.2.5.1 Custom ‘Bootstrap’ ‘Sass’ Themes for ‘shiny’ and ‘rmarkdown’ cachem 1.0.5 Cache R Objects with Automatic Pruning callr 3.7.0 Call R from R checkmate 2.0.0 Fast and Versatile Argument Checks classInt 0.4-3 Choose Univariate Class Intervals cli 2.5.0 Helpers for Developing Command Line Interfaces colorspace 2.0-1 A Toolbox for Manipulating and Assessing Colors and Palettes commonmark 1.7 High Performance CommonMark and Github Markdown Rendering in R config 0.3.1 Manage Environment Specific Configuration Values conquer 1.0.2 Convolution-Type Smoothed Quantile Regression corrplot 0.88 Visualization of a Correlation Matrix countrycode 1.2.0 Convert Country Names and Country Codes cowplot 1.1.1 Streamlined Plot Theme and Plot Annotations for ggplot2 cpp11 0.2.7 A C++11 Interface for R’s C Interface crayon 1.4.1 Colored Terminal Output crosstalk 1.1.1 Inter-Widget Interactivity for HTML Widgets curl 4.3.1 A Modern and Flexible Web Client for R data.table 1.14.0 Extension of data.frame DBI 1.1.1 R Database Interface dbplyr 2.1.1 A ‘dplyr’ Back End for Databases dendextend 1.15.1 Extending ‘dendrogram’ Functionality in R desc 1.3.0 Manipulate DESCRIPTION Files devtools 2.4.1 Tools to Make Developing R Packages Easier DiagrammeR 1.0.6.1 Graph/Network Visualization digest 0.6.27 Create Compact Hash Digests of R Objects downloader 0.4 Download Files over HTTP and HTTPS dplyr 1.0.6 A Grammar of Data Manipulation DT 0.18 A Wrapper of the JavaScript Library DataTables dtplyr 1.1.0 Data Table Back-End for ‘dplyr’ echarts4r 0.4.0 Create Interactive Graphs with ‘Echarts JavaScript’ Version 5 egg 0.4.5 Extensions for ggplot2: Custom Geom, Custom Themes, Plot Alignment, Labelled Panels, Symmetric Scales, and Fixed Panel Size ellipsis 0.3.2 Tools for Working with … equatiomatic 0.2.0 Transform Models into LaTeX Equations evaluate 0.14 Parsing and Evaluation Tools that Provide More Details than the Default extrafont 0.17 Tools for using fonts extrafontdb 1.0 Package for holding the database for the extrafont package fastmap 1.1.0 Fast Data Structures filehash 2.4-2 Simple Key-Value Database fontcm 1.1 Computer Modern font for use with extrafont package forcats 0.5.1 Tools for Working with Categorical Variables (Factors) foreach 1.5.1 Provides Foreach Looping Construct forge 0.2.0 Casting Values into Shape formatR 1.11 Format R Code Automatically fs 1.5.0 Cross-Platform File System Operations Based on ‘libuv’ gapminder 0.3.0 Data from Gapminder gdtools 0.2.3 Utilities for Graphical Rendering generics 0.1.0 Common S3 Generics not Provided by Base R Methods Related to Model Fitting geoR 1.8-1 Analysis of Geostatistical Data gganimate 1.0.7 A Grammar of Animated Graphics ggbeeswarm 0.6.0 Categorical Scatter (Violin Point) Plots ggdendro 0.1.22 Create Dendrograms and Tree Diagrams Using ggplot2 ggfittext 0.9.1 Fit Text Inside a Box in ggplot2 ggfortify 0.4.11 Data Visualization Tools for Statistical Analysis Results ggmosaic 0.3.3 Mosaic Plots in the ggplot2 Framework ggnormalviolin 0.1.2 A ggplot2 Extension to Make Normal Violin Plots ggplot2 3.3.3 Create Elegant Data Visualisations Using the Grammar of Graphics ggpubr 0.4.0 ggplot2 Based Publication Ready Plots ggrepel 0.9.1 Automatically Position Non-Overlapping Text Labels with ggplot2 ggridges 0.5.3 Ridgeline Plots in ggplot2 ggsci 2.9 Scientific Journal and Sci-Fi Themed Color Palettes for ggplot2 ggsignif 0.6.1 Significance Brackets for ggplot2 ggstream 0.1.0 Create Streamplots in ggplot2 gifski 1.4.3-1 Highest Quality GIF Encoder git2r 0.28.0 Provides Access to Git Repositories glmmTMB 1.0.2.1 Generalized Linear Mixed Models using Template Model Builder glmnet 4.1-1 Lasso and Elastic-Net Regularized Generalized Linear Models globals 0.14.0 Identify Global Objects in R Expressions glue 1.4.2 Interpreted String Literals googledrive 1.0.1 An Interface to Google Drive googlesheets4 0.3.0 Access Google Sheets using the Sheets API V4 gridBase 0.4-7 Integration of base and grid graphics gridExtra 2.3 Miscellaneous Functions for Grid Graphics gt 0.3.0 Easily Create Presentation-Ready Display Tables gtable 0.3.0 Arrange Grobs in Tables haven 2.4.1 Import and Export ‘SPSS,’ ‘Stata’ and ‘SAS’ Files heatmaply 1.2.1 Interactive Cluster Heat Maps Using ‘plotly’ and ggplot2 hexbin 1.28.2 Hexagonal Binning Routines highcharter 0.8.2 A Wrapper for the Highcharts Library highr 0.9 Syntax Highlighting for R Source Code Hmisc 4.5-0 Harrell Miscellaneous hms 1.1.0 Pretty Time of Day hrbrthemes 0.8.0 Additional Themes, Theme Components and Utilities for ggplot2 htmltools 0.5.1.1 Tools for HTML htmlwidgets 1.5.3 HTML Widgets for R httpuv 1.6.1 HTTP and WebSocket Server Library httr 1.4.2 Tools for Working with URLs and HTTP igraph 1.2.6 Network Analysis and Visualization influenceR 0.1.0 Software Tools to Quantify Structural Importance of Nodes in a Network isoband 0.2.4 Generate Isolines and Isobands from Regularly Spaced Elevation Grids jsonlite 1.7.2 A Simple and Robust JSON Parser and Generator for R kableExtra 1.3.4 Construct Complex Table with kable and Pipe Syntax Kendall 2.2 Kendall rank correlation and Mann-Kendall trend test knitr 1.33 A General-Purpose Package for Dynamic Report Generation in R later 1.2.0 Utilities for Scheduling Functions to Execute Later with Event Loops lattice 0.20-44 Trellis Graphics for R latticeExtra 0.6-29 Extra Graphical Utilities Based on Lattice lazyeval 0.2.2 Lazy (Non-Standard) Evaluation leaflet 2.0.4.1 Create Interactive Web Maps with the JavaScript ‘Leaflet’ Library leaflet.providers 1.9.0 Leaflet Providers lifecycle 1.0.0 Manage the Life Cycle of your Package Functions lightgbm 3.2.1 Light Gradient Boosting Machine lme4 1.1-27 Linear Mixed-Effects Models using Eigen and S4 lpSolve 5.6.15 Interface to ‘Lp_solve’ v. 5.5 to Solve Linear/Integer Programs lubridate 1.7.10 Make Dealing with Dates a Little Easier magick 2.7.2 Advanced Graphics and Image-Processing in R magrittr 2.0.1 A Forward-Pipe Operator for R mapdata 2.3.0 Extra Map Databases mapproj 1.2.7 Map Projections maps 3.3.0 Draw Geographical Maps markdown 1.1 Render Markdown with the C Library Sundown MASS 7.3-54 Support Functions and Datasets for Venables and Ripley’s MASS Matrix 1.3-4 Sparse and Dense Matrix Classes and Methods MatrixModels 0.5-0 Modelling with Sparse and Dense Matrices maxLik 1.4-8 Maximum Likelihood Estimation and Related Tools mcmc 0.9-7 Markov Chain Monte Carlo memoise 2.0.0 Memoisation of Functions mgcv 1.8-36 Mixed GAM Computation Vehicle with Automatic Smoothness Estimation mime 0.10 Map Filenames to MIME Types minqa 1.2.4 Derivative-free optimization algorithms by quadratic approximation modelr 0.1.8 Modelling Functions that Work with the Pipe mvtnorm 1.1-1 Multivariate Normal and t Distributions networkD3 0.4 D3 JavaScript Network Graphs from R nlme 3.1-152 Linear and Nonlinear Mixed Effects Models nloptr 1.2.2.2 R Interface to NLopt nomnoml 0.2.3 Sassy ‘UML’ Diagrams numDeriv 2016.8-1.1 Accurate Numerical Derivatives odbc 1.3.2 Connect to ODBC Compatible Databases (using the DBI Interface) openssl 1.4.4 Toolkit for Encryption, Signatures and Certificates Based on OpenSSL palmerpenguins 0.1.0 Palmer Archipelago (Antarctica) Penguin Data patchwork 1.1.1 The Composer of Plots pdftools 3.0.1 Text Extraction, Rendering and Converting of PDF Documents pdist 1.2 Partitioned Distance Function pillar 1.6.1 Coloured Formatting for Columns pkgbuild 1.2.0 Find Tools Needed to Build R Packages pkgconfig 2.0.3 Private Configuration for R Packages pkgload 1.2.1 Simulate Package Installation and Attach plogr 0.2.0 The plog C++ Logging Library plotly 4.9.3 Create Interactive Web Graphics via plotly.js plyr 1.8.6 Tools for Splitting, Applying and Combining Data png 0.1-7 Read and write PNG images polynom 1.4-0 A Collection of Functions to Implement a Class for Univariate Polynomial Manipulations prettydoc 0.4.1 Creating Pretty Documents from R Markdown PrevMap 1.5.3 Geostatistical Modelling of Spatially Referenced Prevalence Data processx 3.5.2 Execute and Control System Processes productplots 0.1.1 Product Plots for R progress 1.2.2 Terminal Progress Bars promises 1.2.0.1 Abstractions for Promise-Based Asynchronous Programming pspearman 0.3-0 Spearman’s rank correlation test purrr 0.3.4 Functional Programming Tools pwr 1.3-0 Basic Functions for Power Analysis qpdf 1.1 Split, Combine and Compress PDF Files quadprog 1.5-8 Functions to Solve Quadratic Programming Problems quantmod 0.4.18 Quantitative Financial Modelling Framework quantreg 5.85 Quantile Regression r2d3 0.2.5 Interface to ‘D3’ Visualizations R6 2.5.0 Encapsulated Classes with Reference Semantics RandomFields 3.3.8 Simulation and Analysis of Random Fields rappdirs 0.3.3 Application Directories: Determine Where to Save Data, Caches, and Logs raster 3.4-10 Geographic Data Analysis and Modeling rasterly 0.2.0 Easily and Rapidly Generate Raster Image Data with Support for ‘Plotly.js’ rasterVis 0.50.2 Visualization Methods for Raster Data rcmdcheck 1.3.3 Run ‘R CMD check’ from R and Capture Results RColorBrewer 1.1-2 ColorBrewer Palettes Rcpp 1.0.6 Seamless R and C++ Integration RcppEigen 0.3.3.9.1 Rcpp Integration for the Eigen Templated Linear Algebra Library reactable 0.2.3 Interactive Data Tables Based on ‘React Table’ reactR 0.4.4 React Helpers readr 1.4.0 Read Rectangular Text Data readxl 1.3.1 Read Excel Files remotes 2.4.0 R Package Installation from Remote Repositories, Including ‘GitHub’ reprex 2.0.0 Prepare Reproducible Example Code via the Clipboard reshape2 1.4.4 Flexibly Reshape Data: A Reboot of the Reshape Package reticulate 1.20 Interface to Python rgdal 1.5-23 Bindings for the Geospatial Data Abstraction Library rjson 0.2.20 JSON for R rlang 0.4.11 Functions for Base Types and Core R and Tidyverse Features rlist 0.4.6.1 A Toolbox for Non-Tabular Data Manipulation rmarkdown 2.8 Dynamic Documents for R rootSolve 1.8.2.1 Nonlinear Root Finding, Equilibrium and Steady-State Analysis of Ordinary Differential Equations roxygen2 7.1.1 In-Line Documentation for R rprojroot 2.0.2 Finding Files in Project Subdirectories RSQLite 2.2.7 ‘SQLite’ Interface for R rstatix 0.7.0 Pipe-Friendly Framework for Basic Statistical Tests rstudioapi 0.13 Safely Access the RStudio API Rttf2pt1 1.3.8 ‘ttf2pt1’ Program rversions 2.1.1 Query R Versions, Including ‘r-release’ and ‘r-oldrel’ rvest 1.0.0 Easily Harvest (Scrape) Web Pages Ryacas 1.1.3.1 R Interface to the ‘Yacas’ Computer Algebra System sass 0.4.0 Syntactically Awesome Style Sheets (‘Sass’) scales 1.1.1 Scale Functions for Visualization seriation 1.2-9 Infrastructure for Ordering Objects Using Seriation sessioninfo 1.1.1 R Session Information sf 0.9-8 Simple Features for R shape 1.4.6 Functions for Plotting Graphical Shapes, Colors shiny 1.6.0 Web Application Framework for R showtext 0.9-2 Using Fonts More Easily in R Graphs showtextdb 3.0 Font Files for the ‘showtext’ Package sm 2.2-5.6 Smoothing Methods for Nonparametric Regression and Density Estimation sourcetools 0.1.7 Tools for Reading, Tokenizing and Parsing R Code sp 1.4-5 Classes and Methods for Spatial Data sparkline 2.0 ‘jQuery’ Sparkline ‘htmlwidget’ sparklyr 1.6.3 R Interface to Apache Spark SparseM 1.81 Sparse Linear Algebra splancs 2.01-42 Spatial and Space-Time Point Pattern Analysis stringi 1.6.2 Character String Processing Facilities stringr 1.4.0 Simple, Consistent Wrappers for Common String Operations SuppDists 1.1-9.5 Supplementary Distributions survival 3.2-11 Survival Analysis svglite 2.0.0 An ‘SVG’ Graphics Device sysfonts 0.8.3 Loading Fonts into R tensorflow 2.4.0 R Interface to ‘TensorFlow’ terra 1.2-10 Spatial Data Analysis testthat 3.0.2 Unit Testing for R tfruns 1.5.0 Training Run Tools for ‘TensorFlow’ tibble 3.1.2 Simple Data Frames tidyr 1.1.3 Tidy Messy Data tidyselect 1.1.1 Select from a Set of Strings tidyverse 1.3.1 Easily Install and Load the Tidyverse tikzDevice 0.12.3.1 R Graphics Output in LaTeX Format timeline 0.9 Timelines for a Grammar of Graphics timelineS 0.1.1 Timeline and Time Duration-Related Tools tint 0.1.3 ‘tint’ is not ‘Tufte’ tinytex 0.32 Helper Functions to Install and Maintain TeX Live, and Compile LaTeX Documents TMB 1.7.20 Template Model Builder: A General Random Effect Tool Inspired by ADMB transformr 0.1.3 Polygon and Path Transformations treemap 2.4-2 Treemap Visualization treemapify 2.5.5 Draw Treemaps in ggplot2 truncnorm 1.0-8 Truncated Normal Distribution tweenr 1.0.2 Interpolate Data for Smooth Animations units 0.7-1 Measurement Units for R Vectors usethis 2.0.1 Automate Package and Project Setup uuid 0.1-4 Tools for Generating and Handling of UUIDs V8 3.4.2 Embedded JavaScript and WebAssembly Engine for R vctrs 0.3.8 Vector Helpers vioplot 0.3.6 Violin Plot vipor 0.4.5 Plot Categorical Data Using Quasirandom Noise and Density Estimates viridis 0.6.1 Colorblind-Friendly Color Maps for R viridisLite 0.4.0 Colorblind-Friendly Color Maps (Lite Version) visNetwork 2.0.9 Network Visualization using ‘vis.js’ Library vistime 1.2.1 Pretty Timelines in R webshot 0.5.2 Take Screenshots of Web Pages withr 2.4.2 Run Code With Temporarily Modified Global State xfun 0.23 Supporting Functions for Packages Maintained by Yihui Xie xgboost 1.4.1.1 Extreme Gradient Boosting xkcd 0.0.6 Plotting ggplot2 Graphics in an XKCD Style xml2 1.3.2 Parse XML xtable 1.8-4 Export Tables to LaTeX or HTML xts 0.12.1 eXtensible Time Series yaml 2.2.1 Methods to Convert R Data to YAML and Back zoo 1.8-9 S3 Infrastructure for Regular and Irregular Time Series (Z’s Ordered Observations) 本书意欲覆盖的内容 inla_pdb &lt;- data.frame( Package = &quot;INLA&quot;, Title = paste( &quot;Full Bayesian Analysis of Latent Gaussian Models&quot;, &quot;using Integrated Nested Laplace Approximations&quot; ) ) pkgs &lt;- c( &quot;ggplot2&quot;, &quot;cowplot&quot;, &quot;patchwork&quot;, &quot;rgl&quot;, &quot;MASS&quot;, &quot;nlme&quot;, &quot;mgcv&quot;, &quot;lme4&quot;, &quot;gee&quot;, &quot;gam&quot;, &quot;gamm4&quot;, &quot;cgam&quot;, &quot;cglm&quot;, &quot;pscl&quot;, &quot;GLMMadaptive&quot;, &quot;gee4&quot;, &quot;geoR&quot;, &quot;LaplacesDemon&quot;, &quot;glmnet&quot;, &quot;betareg&quot;, &quot;quantreg&quot;, &quot;agridat&quot;, &quot;moments&quot;, &quot;R2BayesX&quot;, &quot;geoRglm&quot;, &quot;spaMM&quot;, &quot;spBayes&quot;, &quot;CARBayes&quot;, &quot;PrevMap&quot;, &quot;FRK&quot;, &quot;lgcp&quot;, &quot;HSAR&quot;, &quot;spNNGP&quot;, &quot;MuMIn&quot;, &quot;BANOVA&quot;, &quot;rpql&quot;, &quot;QGglmm&quot;, &quot;glmmsr&quot;, &quot;glmmboot&quot;, &quot;glmm&quot;, &quot;glmmML&quot;, &quot;glmmEP&quot;, &quot;r2glmm&quot;, &quot;hglm&quot;, &quot;glmmLasso&quot;, &quot;blme&quot;, &quot;MCMCglmm&quot;, &quot;MCMCpack&quot;, &quot;glmmTMB&quot;, &quot;geepack&quot;, &quot;glmmfields&quot;, &quot;rstan&quot;, &quot;rstanarm&quot;, &quot;brms&quot;, &quot;greta&quot;, &quot;BayesX&quot;, &quot;Boom&quot;, &quot;nimble&quot;, &quot;rjags&quot;, &quot;R2OpenBUGS&quot;, &quot;R2BayesX&quot;, &quot;BoomSpikeSlab&quot;, &quot;inlabru&quot;, &quot;INLABMA&quot;, &quot;lmtest&quot;, &quot;VGAM&quot;, &quot;plotly&quot;, &quot;leaflet&quot;, &quot;LatticeKrig&quot; ) pdb &lt;- tools::CRAN_package_db() book_pdb &lt;- subset(pdb, subset = !duplicated(pdb$Package) &amp; Package %in% pkgs, select = c(&quot;Package&quot;, &quot;Title&quot;) ) book_pdb &lt;- rbind.data.frame(book_pdb, inla_pdb) book_pdb$Title &lt;- gsub(&quot;(\\\\\\n)&quot;, &quot; &quot;, book_pdb$Title) book_pdb$Title &lt;- gsub(&quot;&#39;(Armadillo|BayesX|Eigen|ggplot2|lme4|mgcv|Stan|Leaflet|plotly.js)&#39;&quot;, &quot;\\\\1&quot;, book_pdb$Title) book_pdb$Package &lt;- paste(&quot;**&quot;, book_pdb$Package, &quot;**&quot;, sep = &quot;&quot;) knitr::kable(book_pdb, caption = &quot;本书使用的 R 包&quot;, format = &quot;pandoc&quot;, booktabs = TRUE, row.names = FALSE ) 表 B.2: 本书使用的 R 包 Package Title agridat Agricultural Datasets BANOVA Hierarchical Bayesian ANOVA Models BayesX R Utilities Accompanying the Software Package BayesX betareg Beta Regression blme Bayesian Linear Mixed-Effects Models Boom Bayesian Object Oriented Modeling BoomSpikeSlab MCMC for Spike and Slab Regression brms Bayesian Regression Models using Stan CARBayes Spatial Generalised Linear Mixed Models for Areal Unit Data cgam Constrained Generalized Additive Model cglm Fits Conditional Generalized Linear Models cowplot Streamlined Plot Theme and Plot Annotations for ggplot2 FRK Fixed Rank Kriging gam Generalized Additive Models gamm4 Generalized Additive Mixed Models using mgcv and lme4 gee Generalized Estimation Equation Solver geepack Generalized Estimating Equation Package geoR Analysis of Geostatistical Data ggplot2 Create Elegant Data Visualisations Using the Grammar of Graphics glmm Generalized Linear Mixed Models via Monte Carlo Likelihood Approximation GLMMadaptive Generalized Linear Mixed Models using Adaptive Gaussian Quadrature glmmboot Bootstrap Resampling for Mixed Effects and Plain Models glmmEP Generalized Linear Mixed Model Analysis via Expectation Propagation glmmfields Generalized Linear Mixed Models with Robust Random Fields for Spatiotemporal Modeling glmmLasso Variable Selection for Generalized Linear Mixed Models by L1-Penalized Estimation glmmML Generalized Linear Models with Clustering glmmsr Fit a Generalized Linear Mixed Model glmmTMB Generalized Linear Mixed Models using Template Model Builder glmnet Lasso and Elastic-Net Regularized Generalized Linear Models greta Simple and Scalable Statistical Modelling in R hglm Hierarchical Generalized Linear Models HSAR Hierarchical Spatial Autoregressive Model INLABMA Bayesian Model Averaging with INLA inlabru Bayesian Latent Gaussian Modelling using INLA and Extensions LaplacesDemon Complete Environment for Bayesian Inference LatticeKrig Multi-Resolution Kriging Based on Markov Random Fields leaflet Create Interactive Web Maps with the JavaScript Leaflet Library lgcp Log-Gaussian Cox Process lme4 Linear Mixed-Effects Models using Eigen and S4 lmtest Testing Linear Regression Models MASS Support Functions and Datasets for Venables and Ripley’s MASS MCMCglmm MCMC Generalised Linear Mixed Models MCMCpack Markov Chain Monte Carlo (MCMC) Package mgcv Mixed GAM Computation Vehicle with Automatic Smoothness Estimation moments Moments, cumulants, skewness, kurtosis and related tests MuMIn Multi-Model Inference nimble MCMC, Particle Filtering, and Programmable Hierarchical Modeling nlme Linear and Nonlinear Mixed Effects Models patchwork The Composer of Plots plotly Create Interactive Web Graphics via plotly.js PrevMap Geostatistical Modelling of Spatially Referenced Prevalence Data pscl Political Science Computational Laboratory QGglmm Estimate Quantitative Genetics Parameters from Generalised Linear Mixed Models quantreg Quantile Regression R2BayesX Estimate Structured Additive Regression Models with BayesX r2glmm Computes R Squared for Mixed (Multilevel) Models R2OpenBUGS Running OpenBUGS from R rgl 3D Visualization Using OpenGL rjags Bayesian Graphical Models using MCMC rpql Regularized PQL for Joint Selection in GLMMs rstan R Interface to Stan rstanarm Bayesian Applied Regression Modeling via Stan spaMM Mixed-Effect Models, Particularly Spatial Models spBayes Univariate and Multivariate Spatial-Temporal Modeling spNNGP Spatial Regression Models for Large Datasets using Nearest Neighbor Gaussian Processes VGAM Vector Generalized Linear and Additive Models INLA Full Bayesian Analysis of Latent Gaussian Models using Integrated Nested Laplace Approximations "],["chap-mixed-programming.html", "附录 C 混合编程", " 附录 C 混合编程 R 语言 (Ihaka and Gentleman 1996) 是一个统计计算和绘图的环境，以下各个节不介绍具体 R 包函数用法和参数设置，重点在历史发展趋势脉络，详细介绍去见《现代统计图形》的相应章节。R 语言的目标在于统计计算和绘图，设计优势在数据结构、图形语法、动态文档和交互图形 参考文献 "],["sec-function-source.html", "C.1 函数源码", " C.1 函数源码 funflow 包可以将函数调用的过程以流程图的方式呈现，代码结构一目了然，快速理清源代码 remotes::install_github(&#39;moodymudskipper/funflow&#39;) funflow::view_flow(&#39;median.default&#39;) methods(predict) ## [1] predict.ar* predict.Arima* ## [3] predict.arima0* predict.glm ## [5] predict.HoltWinters* predict.lm ## [7] predict.loess* predict.mlm* ## [9] predict.nls* predict.poly* ## [11] predict.ppr* predict.prcomp* ## [13] predict.princomp* predict.smooth.spline* ## [15] predict.smooth.spline.fit* predict.StructTS* ## see &#39;?methods&#39; for accessing help and source code stats 包里找不到这个函数 ls(&quot;package:stats&quot;, all.names = TRUE, pattern = &quot;predict.poly&quot;) ## character(0) predict.poly ## Error in eval(expr, envir, enclos): object &#39;predict.poly&#39; not found 可见函数 predict.poly() 默认没有导出 stats:::predict.poly ## function (object, newdata, ...) ## { ## if (missing(newdata)) ## object ## else if (is.null(attr(object, &quot;coefs&quot;))) ## poly(newdata, degree = max(attr(object, &quot;degree&quot;)), raw = TRUE, ## simple = TRUE) ## else poly(newdata, degree = max(attr(object, &quot;degree&quot;)), ## coefs = attr(object, &quot;coefs&quot;), simple = TRUE) ## } ## &lt;bytecode: 0x5654e4e276c8&gt; ## &lt;environment: namespace:stats&gt; 或者 getAnywhere(predict.poly) ## A single object matching &#39;predict.poly&#39; was found ## It was found in the following places ## registered S3 method for predict from namespace stats ## namespace:stats ## with value ## ## function (object, newdata, ...) ## { ## if (missing(newdata)) ## object ## else if (is.null(attr(object, &quot;coefs&quot;))) ## poly(newdata, degree = max(attr(object, &quot;degree&quot;)), raw = TRUE, ## simple = TRUE) ## else poly(newdata, degree = max(attr(object, &quot;degree&quot;)), ## coefs = attr(object, &quot;coefs&quot;), simple = TRUE) ## } ## &lt;bytecode: 0x5654e4e276c8&gt; ## &lt;environment: namespace:stats&gt; getAnywhere(&quot;predict.poly&quot;)$where ## [1] &quot;registered S3 method for predict from namespace stats&quot; ## [2] &quot;namespace:stats&quot; 函数参数个数 names(formals(read.table)) ## [1] &quot;file&quot; &quot;header&quot; &quot;sep&quot; &quot;quote&quot; ## [5] &quot;dec&quot; &quot;numerals&quot; &quot;row.names&quot; &quot;col.names&quot; ## [9] &quot;as.is&quot; &quot;na.strings&quot; &quot;colClasses&quot; &quot;nrows&quot; ## [13] &quot;skip&quot; &quot;check.names&quot; &quot;fill&quot; &quot;strip.white&quot; ## [17] &quot;blank.lines.skip&quot; &quot;comment.char&quot; &quot;allowEscapes&quot; &quot;flush&quot; ## [21] &quot;stringsAsFactors&quot; &quot;fileEncoding&quot; &quot;encoding&quot; &quot;text&quot; ## [25] &quot;skipNul&quot; "],["sec-naming-conventions.html", "C.2 命名约定", " C.2 命名约定 R 语言当前的命名状态 https://journal.r-project.org/archive/2012-2/RJournal_2012-2_Baaaath.pdf 和 https://essentials.togaware.com/StyleO.pdf R 与不同的编程语言如何交互 "],["sec-r-javascripts.html", "C.3 R 与 JavaScripts", " C.3 R 与 JavaScripts library(htmlwidgets) "],["sec-r-python.html", "C.4 R 与 Python", " C.4 R 与 Python R 包 knitr 和 reticulate 支持 R Markdown 文档中嵌入 Python 代码块， reticulate 包还支持 Python 和 R 之间的数据对象通信交流。 library(reticulate) 如图 C.1 所示，在 R Markdown 中执行 Python 绘图代码，并且将图形插入文档。 import matplotlib.pyplot as plt plt.switch_backend(&#39;agg&#39;) plt.plot([0, 2, 1, 4]) ## [&lt;matplotlib.lines.Line2D object at 0x7f8849f2d730&gt;] plt.show() 图 C.1: Python 图形 "],["sec-r-c.html", "C.5 R 与 C", " C.5 R 与 C knitr 支持在 R Markdown 中嵌入 C 语言代码 void useC(int *i){ i[0] = 11; } ## make[1]: Entering directory &#39;/home/runner/work/masr/masr&#39; ## gcc -I&quot;/opt/R/4.1.0/lib/R/include&quot; -DNDEBUG -I/usr/local/include -fpic -g -O2 -c c56ec32d8a974.c -o c56ec32d8a974.o ## gcc -shared -L/opt/R/4.1.0/lib/R/lib -L/usr/local/lib -o c56ec32d8a974.so c56ec32d8a974.o -L/opt/R/4.1.0/lib/R/lib -lR ## make[1]: Leaving directory &#39;/home/runner/work/masr/masr&#39; a &lt;- rep(2,10) out &lt;- .C(&quot;useC&quot;, b = as.integer(a)) out ## $b ## [1] 11 2 2 2 2 2 2 2 2 2 out$b ## [1] 11 2 2 2 2 2 2 2 2 2 一步一步地命令行操作 R CMD SHLIB useC1.c dyn.load(&quot;useC1.dll&quot;) a &lt;- rep(2,10) out &lt;- .C(&quot;useC&quot;, b = as.integer(a)) out$b "],["sec-r-cpp.html", "C.6 R 与 C++", " C.6 R 与 C++ Dirk Eddelbuettel 是 Rcpp 的核心开发者。 Dirk Eddelbuettel celebRtion 2020, Copenhagen, Denmark Introduction to Rcpp: from simple examples to machine learning Online Tutorial for useR! 2020 Seamless R and C++ Introduction with Rcpp 视频 https://vimeo.com/438283959 James Balamuta unofficial rcpp api documentation https://github.com/coatless/rcpp-api Rcpp for everyone https://github.com/teuder/rcpp4everyone_en 课程 Foundations of Data Science library(Rcpp) "],["sec-r-latex.html", "C.7 R 与 LaTeX", " C.7 R 与 LaTeX tikzDevice 包将 LaTeX 公式和绘图系统 TikZ 引入 R 语言生态，贡献在于提供更加漂亮的公式输出，对图形进行后期布局排版加工，达到设计师出品的质量水平。图 C.2 展示了复杂的 TeX 生态系统， R 语言只是取其精华，使用 TikZ 绘制。 \\begin{tikzpicture} \\path [ mindmap, text = white, level 1 concept/.append style = {font=\\Large\\bfseries\\sffamily, sibling angle=90, level distance=125}, level 2 concept/.append style = {font=\\normalsize\\bfseries\\sffamily}, level 3 concept/.append style = {font=\\small\\bfseries\\sffamily}, tex/.style = {concept, ball color=blue, font=\\Huge\\bfseries}, engines/.style = {concept, ball color=green!50!black}, formats/.style = {concept, ball color=purple!50!black}, systems/.style = {concept, ball color=red!90!black}, editors/.style = {concept, ball color=orange!90!black} ] node [tex] {\\TeX} [clockwise from=0] child[concept color=green!50!black, nodes={engines}] { node {Engines} [clockwise from=90] child { node {\\TeX} } child { node {pdf\\TeX} } child { node {XeTeX} } child { node {Lua\\TeX} }} child [concept color=purple, nodes={formats}] { node {Formats} [clockwise from=300] child { node {\\LaTeX} } child { node {Con\\TeX t} }} child [concept color=red, nodes={systems}] { node {Systems} [clockwise from=210] child { node {\\TeX Live} [clockwise from=300] child { node {Mac \\TeX} }} child { node {MiK\\TeX} [clockwise from=60] child { node {Pro \\TeX t} }}} child [concept color=orange, nodes={editors}] { node {Editors} [clockwise from=180] child { node {WinEdt} } child { node {\\TeX works} } child { node {\\TeX studio} } child { node {\\TeX maker} }}; \\end{tikzpicture} 图 C.2: TeX 系统 "],["sec-mixed-programming-session-info.html", "C.8 运行环境", " C.8 运行环境 sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 20.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] Rcpp_1.0.7 reticulate_1.20 htmlwidgets_1.5.3 shiny_1.6.0 ## [5] magrittr_2.0.1 ## ## loaded via a namespace (and not attached): ## [1] knitr_1.33 lattice_0.20-44 xtable_1.8-4 R6_2.5.0 ## [5] rlang_0.4.11 fastmap_1.1.0 highr_0.9 stringr_1.4.0 ## [9] tools_4.1.0 grid_4.1.0 xfun_0.24 png_0.1-7 ## [13] jquerylib_0.1.4 htmltools_0.5.1.1 ellipsis_0.3.2 yaml_2.2.1 ## [17] digest_0.6.27 lifecycle_1.0.0 bookdown_0.22 Matrix_1.3-4 ## [21] later_1.2.0 sass_0.4.0 promises_1.2.0.1 evaluate_0.14 ## [25] mime_0.11 rmarkdown_2.9 stringi_1.7.3 compiler_4.1.0 ## [29] bslib_0.2.5.1 jsonlite_1.7.2 httpuv_1.6.1 "],["chap-object-oriented-programming.html", "附录 D 面向对象编程", " 附录 D 面向对象编程 进入这一章的读者都是对编程感兴趣的读者，希望在工程能力上有所提升的读者。那么最重要的是： Code should be written to minimize the time it would take for someone else to understand it. — The Art of Readable Code, Boswell, D. / Foucher, T. 代码可读性，代码复用性，代码维护性，代码扩展性，代码简洁性，代码高效性，代码容错性，我们共勉吧！如果读者已投身商业公司，应当以完成任务为第一，这自不必说！ "],["sec-environment.html", "D.1 环境", " D.1 环境 environment(fun = NULL) environment(fun) &lt;- value is.environment(x) .GlobalEnv globalenv() .BaseNamespaceEnv emptyenv() baseenv() new.env(hash = TRUE, parent = parent.frame(), size = 29L) parent.env(env) parent.env(env) &lt;- value environmentName(env) env.profile(env) "],["sec-quote.html", "D.2 引用", " D.2 引用 get(x, pos = -1, envir = as.environment(pos), mode = &quot;any&quot;, inherits = TRUE) mget(x, envir = as.environment(-1), mode = &quot;any&quot;, ifnotfound, inherits = FALSE) dynGet(x, ifnotfound = , minframe = 1L, inherits = FALSE) get Return the Value of a Named Object exists Is an Object Defined? exists(x, where = -1, envir = , frame, mode = &quot;any&quot;, inherits = TRUE) get0(x, envir = pos.to.env(-1L), mode = &quot;any&quot;, inherits = TRUE, ifnotfound = NULL) "],["sec-call-stack.html", "D.3 调用栈", " D.3 调用栈 Functions to Access the Function Call Stack sys.call(which = 0) sys.frame(which = 0) sys.nframe() sys.function(which = 0) sys.parent(n = 1) sys.calls() sys.frames() sys.parents() sys.on.exit() sys.status() parent.frame(n = 1) sys.source Parse and Evaluate Expressions from a File "],["sec-closure.html", "D.4 闭包", " D.4 闭包 An illustration of lexical scoping. demo(scoping) "],["sec-recursion.html", "D.5 递归", " D.5 递归 Using recursion for adaptive integration demo(recursion) 斐波那契数列 # 递归 Recall fibonacci &lt;- function(n) { if (n &lt;= 2) { if (n &gt;= 0) 1 else 0 } else { Recall(n - 1) + Recall(n - 2) } } fibonacci(10) # 55 ## [1] 55 "],["sec-catching-and-handling-errors.html", "D.6 异常", " D.6 异常 异常捕获和处理 demo(error.catching) "],["sec-is-things.html", "D.7 对象", " D.7 对象 判断对象类型 demo(is.things) "],["sec-generic.html", "D.8 泛型", " D.8 泛型 I’d like to prefix all these solutions with ‘Here’s how to do it, but don’t actually do it you crazy fool.’ It’s on a par with redefining pi, or redefining ‘+.’ And then redefining ‘&lt;-.’ These techniques have their proper place, and that would be in the currently non-existent obfuscated R contest. No, the R-ish (iRish?) way is to index vectors from 1. That’s what the R gods intended! — Barry Rowlingson53 如果要让下标从 0 开始的话，我们需要在现有的向量类型 vector 上定义新的向量类型 vector0，在其上并且实现索引运算 [ 和赋值修改元素的运算 [&lt;- # https://stat.ethz.ch/pipermail/r-help/2004-March/048682.html as.vector0 &lt;- function(x) structure(x, class = &quot;vector0&quot;) # 创建一种新的数据结构 vector0 as.vector.vector0 &lt;- function(x) unclass(x) &quot;[.vector0&quot; &lt;- function(x, i) as.vector0(as.vector.vector0(x)[i + 1]) # 索引操作 &quot;[&lt;-.vector0&quot; &lt;- function(x, i, value) { # 赋值操作 x &lt;- as.vector.vector0(x) x[i + 1] &lt;- value as.vector0(x) } print.vector0 &lt;- function(x) print(as.vector.vector0(x)) # 实现 print 方法 举个例子看看 1:10 # 是一个内置的现有向量类型 vector ## [1] 1 2 3 4 5 6 7 8 9 10 x &lt;- as.vector0(1:10) # 转化为新建的 vector0 类型 x[0:4] &lt;- 100 * x[0:4] # 对 x 的元素替换修改 x ## [1] 100 200 300 400 500 6 7 8 9 10 第三方 R 包大大扩展了 Base R 函数 plot() 的功能，比如 mgcv ，nlme 包和 lattice 包等，表 D.1 列出当前环境下， plot() 绘图方法。 ## Warning in matrix(methods(&quot;plot&quot;), ncol = 3): data length [52] is not a sub- ## multiple or multiple of the number of rows [18] 表 D.1: 泛型函数 A B C plot.acf plot.intervals.lmList plot.ranef.lme plot.ACF plot.isoreg plot.ranef.lmList plot.augPred plot.jam plot.raster plot.compareFits plot.lm plot.shingle plot.data.frame plot.lme plot.simulate.lme plot.decomposed.ts plot.lmList plot.spec plot.default plot.medpolish plot.spline plot.dendrogram plot.mlm plot.stepfun plot.density plot.nffGroupedData plot.stl plot.ecdf plot.nfnGroupedData plot.table plot.factor plot.nls plot.trellis plot.formula plot.nmGroupedData plot.ts plot.function plot.pdMat plot.tskernel plot.gam plot.ppr plot.TukeyHSD plot.gls plot.prcomp plot.Variogram plot.hclust plot.princomp plot.xyVector plot.histogram plot.profile.nls plot.acf plot.HoltWinters plot.R6 plot.ACF https://stat.ethz.ch/pipermail/r-help/2004-March/048688.html↩︎ "],["sec-code-debug.html", "D.9 除虫", " D.9 除虫 Debugging with RStudio "],["sec-code-performance.html", "D.10 性能", " D.10 性能 "],["sec-code-quality.html", "D.11 质量", " D.11 质量 Github Action 提供的测试环境支持单元测试 testthat、静态代码检查 lintr、覆盖测试 covr、集成测试 Travis-CI、集成部署 Netlify 等一系列代码检查，还有额外的辅助工具，见 Github Action 工具合集，相关学习材料见快速参考手册 https://github.com/github/actions-cheat-sheet PDF 版本，以创建 R 包为例，展示工程开发的流程 https://mdneuzerling.com/post/data-science-workflows/ 标准计算和非标准计算 Standard and non-standard evaluation in R https://www.brodieg.com/2020/05/05/on-nse/ "],["references.html", "参考文献", " 参考文献 "]]
