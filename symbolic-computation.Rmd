# 符号计算 {#chap:symbolic-computation}

```{r setup, include=FALSE}
library(reticulate)
knitr::opts_chunk$set(python.reticulate = TRUE, cache = TRUE)
# 启用 required = TRUE 是让 reticulate 使用指定的 Python 虚拟环境，而不是让它漫无目的地到处找
if (identical(.Platform$OS.type, "windows")) {
  # 在我的 Windows 机器上用的是 Miniconda3
  reticulate::use_condaenv(condaenv = Sys.getenv("RETICULATE_PYTHON_ENV"), required = TRUE)
} else {
  reticulate::use_virtualenv(virtualenv = Sys.getenv("RETICULATE_PYTHON_ENV"), required = TRUE)
}
```

Python 的符号计算模块 [sympy](https://github.com/sympy/sympy) [@SymPy] 不仅支持简单的四则运算，还支持微分、积分、解方程等，详见官方文档 <https://sympy.org/> 

```{python}
from sympy import * 
# 设置显示样式
init_printing(use_unicode=False, wrap_line=False)
x = Symbol('x')
# 积分
integrate(x**2 + x + 1, x)
# 因式分解
factor(5*x**4/2 + 3*x**3 - 108*x**2/5 - 27*x - 81/10)
```

[symengine](https://github.com/symengine/symengine.R) [SymEngine C++ 库](https://github.com/symengine/symengine)

```{r}
library(symengine)
```

简单多项式展开

```{r}
use_vars(x, y, z)
expr <- (x + y + z)^2L - 42L
expand(expr)
```

洛伦兹方程

```{r}
sigma <- 10
rho <- 28
beta <- 8 / 3
```

龙格-库塔数值计算方法求解

```{r}
# 方程形式
lorenz_sys <- list(
  dxdt(x) == sigma * (y - x),
  dxdt(y) == (rho - z) * x - y,
  dxdt(z) == -beta * z + x * y
)
```

求解方程组需要额外安装 odeintr 包

```{r}
lorenz_sys <- ODESystem(lorenz_sys, method = "rk5_i")
```

代入初始值，开始迭代，获取数值解

```{r}
res <- predict(lorenz_sys,
  init = c(x = 1, y = 1, z = 1),
  duration = 100, step_size = 0.001, start = 0
)
head(res)
```

将数值解绘制图形

```{r lorenz-attractor,fig.cap="洛伦兹吸引子",fig.width=4,fig.height=4,out.width="50%"}
plot(res[, c(2, 4)], type = "l", col = "steelblue", main = "Lorenz Attractor")
```
